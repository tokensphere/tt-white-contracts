{
  "language": "Solidity",
  "sources": {
    "contracts/exchange/ExchangeAccessFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../lib/LibAddressSet.sol';\nimport '../lib/LibPaginate.sol';\nimport '../spc/SpcTopFacet.sol';\nimport '../interfaces/IHasMembers.sol';\nimport '../interfaces/IHasActiveMembers.sol';\nimport './lib/LibExchangeAccess.sol';\nimport './lib/AExchangeFacet.sol';\n\n\n/** @title The Exchange Smart Contract.\n *  @dev The Exchange Access facet is in charge of keeping track of exchange members.\n */\ncontract ExchangeAccessFacet is AExchangeFacet, IHasMembers, IHasActiveMembers {\n  using LibAddressSet for LibAddressSet.Data;\n\n  // Membership management.\n\n  /** @dev Queries whether a given address is a member of this Exchange or not.\n   *  @param candidate is the address to test.\n   *  @return A `boolean` flag.\n   */\n  function isMember(address candidate)\n      external override view returns(bool) {\n    return LibExchangeAccess.data().memberSet.contains(candidate);\n  }\n\n  /** @dev Counts the numbers of members present in this Exchange.\n   *  @return The number of members in this exchange.\n   */\n  function memberCount()\n      external override view returns(uint256) {\n    return LibExchangeAccess.data().memberSet.values.length;\n  }\n\n  /** @dev Paginates the members of this Exchange based on a starting cursor and a number of records per page.\n   *  @param cursor is the index at which to start.\n   *  @param perPage is how many records should be returned at most.\n   *  @return A `address[]` list of values at most `perPage` big.\n   *  @return A `uint256` index to the next page.\n   */\n  function paginateMembers(uint256 cursor, uint256 perPage)\n      external override view returns(address[] memory, uint256) {\n    return LibPaginate.addresses(LibExchangeAccess.data().memberSet.values, cursor, perPage);\n  }\n\n  /** @dev Adds a member to this Exchange member list.\n   *  @param member is the address of the member to be added.\n   *  @notice Requires that the caller is a member of the linked SPC.\n   *  @notice Emits a `IHasMembers.MemberAdded` event.\n   */\n  function addMember(address payable member)\n      external override\n      onlySpcMember {\n    // Add the member to our list.\n    LibExchangeAccess.data().memberSet.add(member, false);\n    // Emit!\n    emit MemberAdded(member);\n  }\n\n  /** @dev Removes a member from this Exchange.\n   *  @param member is the address of the member to be removed.\n   *  @notice Requires that the caller is a member of the linked SPC.\n   *  @notice Emits a `IHasMembers.MemberRemoved` event.\n   */\n  function removeMember(address member)\n      external override\n      onlySpcMember {\n    LibExchangeAccess.Data storage s = LibExchangeAccess.data();\n    // Ensure that member doesn't have any FAST membership.\n    require(s.fastMemberships[member].values.length == 0, LibConstants.REQUIRES_NO_FAST_MEMBERSHIPS);\n    // Remove member.\n    s.memberSet.remove(member, false);\n    // Emit!\n    emit MemberRemoved(member);\n  }\n\n  /** @dev Allows to query FAST memberships for a given member address.\n   *  @param member Is the address to check.\n   *  @param cursor The index at which to start.\n   *  @param perPage How many records should be returned at most.\n   */\n  function fastMemberships(address member, uint256 cursor, uint256 perPage)\n      external view returns(address[] memory, uint256) {\n    return LibPaginate.addresses(LibExchangeAccess.data().fastMemberships[member].values, cursor, perPage);\n  }\n\n  /** @dev Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.\n   *  @param member The member for which a new FAST membership has been added.\n   */\n  function memberAddedToFast(address member) \n      external {\n    // Verify that the given address is in fact a registered FAST contract.\n    require(\n      SpcTopFacet(LibExchange.data().spc).isFastRegistered(msg.sender),\n      LibConstants.REQUIRES_FAST_CONTRACT_CALLER\n    );\n    // Keep track of the member's FAST membership.\n    LibAddressSet.Data storage memberFasts = LibExchangeAccess.data().fastMemberships[member];\n    memberFasts.add(msg.sender, false);\n  }\n\n  /** @dev Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.\n   *  @param member The member for which a FAST membership has been removed.\n   */\n  function memberRemovedFromFast(address member)\n      external {\n    require(\n      SpcTopFacet(LibExchange.data().spc).isFastRegistered(msg.sender),\n      LibConstants.REQUIRES_FAST_CONTRACT_CALLER\n    );\n    // Remove the tracked membership.\n    LibAddressSet.Data storage memberFasts = LibExchangeAccess.data().fastMemberships[member];\n    memberFasts.remove(msg.sender, false);\n  }\n\n  /** @dev Given a member returns it's activation status.\n   *  @param member The member to check activation status on.\n   */\n  function isMemberActive(address member) external override view returns(bool) {\n    return !LibExchangeAccess.data().deactivatedMemberSet.contains(member);\n  }\n\n  /** @dev Activates a member at the Exchange level.\n   *  @param member The member to remove from the deactivation member set.\n   */\n  function activateMember(address member)\n    external\n    override\n    onlySpcMember\n    onlyMember(member) {\n    // Guard against attempting to activate an already active member.\n    require(\n      !this.isMemberActive(member),\n      LibConstants.REQUIRES_EXCHANGE_DEACTIVATED_MEMBER\n    );\n\n    // Remove the member from the deactivated members list.\n    LibExchangeAccess.data().deactivatedMemberSet.remove(member, false);\n\n    // Emit!\n    emit MemberActivated(member);\n  }\n\n  /** @dev Deactivates a member at the Exchange level.\n   *  @param member The member to add to the deactivation member set.\n   */\n  function deactivateMember(address payable member)\n    external\n    override\n    onlySpcMember\n    onlyMember(member) {\n    // Guard against attempting to deactivate an already deactivated member.\n    require(\n      this.isMemberActive(member),\n      LibConstants.REQUIRES_EXCHANGE_ACTIVE_MEMBER\n    );\n\n    // Add the member to the deactivated members list.\n    LibExchangeAccess.data().deactivatedMemberSet.add(member, false);\n\n    // Emit!\n    emit MemberDeactivated(member);\n  }\n}\n"
    },
    "contracts/lib/LibAddressSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\nlibrary LibAddressSet {\n  /// @dev Represents a list of addresses.\n  struct Data {\n    mapping(address => uint256) indices;\n    address[] values;\n  }\n\n  /**\n   * @dev Adds an item into the storage set. If the address already exists in the\n   *      set, the function reverts.\n   * @param d is the internal data storage to use.\n   * @param key is the address to be added.\n   */\n  function add(Data storage d, address key, bool noThrow)\n      internal {\n    bool exists = contains(d, key);\n    if (noThrow && exists) { return; }\n    require(!exists, 'Address already in set');\n    d.indices[key] = d.values.length;\n    d.values.push(key);\n  }\n\n  /**\n   * @dev Removes an item from the storage set. If the address does not exist in the\n   *      set, the function reverts.\n   * @param d is the internal data storage to use.\n   * @param key is the address to be removed.\n   */\n  function remove(Data storage d, address key, bool noThrow)\n      internal {\n    bool exists = contains(d, key);\n    if (noThrow && !exists) { return; }\n    require(exists, 'Address does not exist in set');\n    uint256 lastIndex = d.values.length - 1;\n    address keyToMove = d.values[lastIndex];\n    uint256 idxToReplace = d.indices[key];\n    d.indices[keyToMove] = idxToReplace;\n    d.values[idxToReplace] = keyToMove;\n    delete d.indices[key];\n    d.values.pop();\n  }\n\n  /**\n   * @dev Tests whether or not a given item already exists in the set.\n   * @param d is the internal data storage to use.\n   * @param key is the address to test.\n   * @return a boolean.\n   */\n  function contains(Data storage d, address key)\n      internal view returns(bool) {\n    return d.values.length == 0\n      ? false\n      : d.values[d.indices[key]] == key;\n  }\n}\n"
    },
    "contracts/lib/LibPaginate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../fast/lib/LibFastHistory.sol';\n\n\nlibrary LibPaginate {\n  function addresses(address[] storage collection, uint256 cursor, uint256 perPage)\n    internal view returns(address[] memory, uint256) {\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\n      address[] memory values = new address[](length);\n      for (uint256 i = 0; i < length; i++) {\n        values[i] = collection[cursor + i];\n      }\n      return (values, cursor + length);\n  }\n\n  function uint256s(uint256[] storage collection, uint256 cursor, uint256 perPage)\n    internal view returns(uint256[] memory, uint256) {\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\n      uint256[] memory values = new uint256[](length);\n      for (uint256 i = 0; i < length; i++) {\n        values[i] = collection[cursor + i];\n      }\n      return (values, cursor + length);\n  }\n\n  function supplyProofs(LibFastHistory.SupplyProof[] storage collection, uint256 cursor, uint256 perPage)\n    internal view returns(LibFastHistory.SupplyProof[] memory, uint256) {\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\n      LibFastHistory.SupplyProof[] memory values = new LibFastHistory.SupplyProof[](length);\n      for (uint256 i = 0; i < length; i++) {\n        values[i] = collection[cursor + i];\n      }\n      return (values, cursor + length);\n  }\n\n  function transferProofs(LibFastHistory.TransferProof[] storage collection, uint256 cursor, uint256 perPage)\n    internal view returns(LibFastHistory.TransferProof[] memory, uint256) {\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\n      LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\n      for (uint256 i = 0; i < length; i++) {\n        values[i] = collection[cursor + i];\n      }\n      return (values, cursor + length);\n  }\n}"
    },
    "contracts/spc/SpcTopFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../lib/LibAddressSet.sol';\nimport '../lib/LibPaginate.sol';\nimport '../lib/LibHelpers.sol';\nimport '../fast/FastTopFacet.sol';\nimport '../fast/FastTokenFacet.sol';\nimport './lib/ASpcFacet.sol';\nimport './lib/LibSpc.sol';\n\n\ncontract SpcTopFacet is ASpcFacet {\n  using LibAddressSet for LibAddressSet.Data;\n  // Constants.\n\n  // This represents how much Eth we provision new SPC members with.\n  uint256 constant private MEMBER_ETH_PROVISION = 10 ether;\n  // This represents how much Eth new FASTs are provisioned with.\n  uint256 constant private FAST_ETH_PROVISION = 250 ether;\n\n  // Eth provisioning stuff.\n\n  /** @dev A function that alllows provisioning this SPC with Eth.\n   *  @notice Emits a `EthReceived` event.\n   */\n  function provisionWithEth()\n      external payable {\n    require(msg.value > 0, LibConstants.MISSING_ATTACHED_ETH);\n    emit EthReceived(msg.sender, msg.value);\n  }\n\n  /** @dev A function that alllows draining this SPC from its Eth.\n   *  @notice Requires that the caller is a member of this SPC.\n   *  @notice Emits a `EthDrained` event.\n   */\n  function drainEth()\n      onlyMember(msg.sender) nonContract(msg.sender)\n      external {\n    uint256 amount = payable(address(this)).balance;\n    payable(msg.sender).transfer(amount);\n    emit EthDrained(msg.sender, amount);\n  }\n\n  // FAST management related methods.\n\n  /** @dev Queries whether a given address is a known and registered FAST contract.\n   * @param fast The address of the contract to check.\n   * @return A boolean.\n   */\n  function isFastRegistered(address fast)\n      external view returns(bool) {\n    return LibSpc.data().fastSet.contains(fast);\n  }\n\n  /** @dev Allows to retrieve the address of a FAST diamond given its symbol.\n   *  @param symbol The symbol of the FAST diamond to get the address of.\n   *  @return The address of the corresponding FAST diamond, or the Zero Address if not found.\n   */\n  function fastBySymbol(string calldata symbol)\n      external view returns(address) {\n    return LibSpc.data().fastSymbols[symbol];\n  }\n\n  /** @dev Allows the registration of a given FAST diamond with this SPC.\n   *  @param fast The address of the FAST diamond to be registered.\n   *  @notice Requires that the caller is a member of this SPC.\n   *  @notice Emits a `FastRegistered` event.\n   */\n  function registerFast(address fast)\n      external\n      onlyMember(msg.sender) {\n    LibSpc.Data storage s = LibSpc.data();\n    string memory symbol = FastTokenFacet(fast).symbol();\n    require(s.fastSymbols[symbol] == address(0), LibConstants.DUPLICATE_ENTRY);\n\n    // Add the FAST to our list.\n    s.fastSet.add(fast, false);\n    // Add the fast symbol to our list.\n    s.fastSymbols[symbol] = fast;\n\n    // Provision the new fast with Eth.\n    uint256 amount = LibHelpers.upTo(payable(fast), FAST_ETH_PROVISION);\n    // Only provision the fast if possible.\n    if (amount > 0) {\n      FastTopFacet(fast).provisionWithEth{ value: amount }();\n    }\n    // Emit!\n    emit FastRegistered(fast);\n  }\n\n  /** @dev Counts the number of FAST diamonds registered with this SPC.\n   *  @return The number of FAST diamonds registered with this SPC.\n   */\n  function fastCount()\n      external view returns(uint256) {\n    return LibSpc.data().fastSet.values.length;\n  }\n\n  /** @dev Paginates the FAST diamonds registered with this SPC based on a starting cursor and a number of records per page.\n   *  @param cursor The index at which to start.\n   *  @param perPage How many records should be returned at most.\n   *  @return A `address[]` list of values at most `perPage` big.\n   *  @return A `uint256` index to the next page.\n   */\n  function paginateFasts(uint256 cursor, uint256 perPage)\n      external view\n      returns(address[] memory, uint256) {\n    return LibPaginate.addresses(LibSpc.data().fastSet.values, cursor, perPage);\n  }\n}\n"
    },
    "contracts/interfaces/IHasMembers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\ninterface IHasMembers {\n  function isMember(address member) external view returns(bool);\n  function memberCount() external view returns(uint256);\n  function paginateMembers(uint256 index, uint256 perPage) external view returns(address[] memory, uint256);\n  function addMember(address payable member) external;\n  function removeMember(address member) external;\n}\n"
    },
    "contracts/interfaces/IHasActiveMembers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\ninterface IHasActiveMembers {\n  function isMemberActive(address member) external view returns(bool);\n  function deactivateMember(address payable member) external;\n  function activateMember(address member) external;\n}\n"
    },
    "contracts/exchange/lib/LibExchangeAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../../lib/LibAddressSet.sol';\n\n\nlibrary LibExchangeAccess {\n  // The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  // This is keccak256('Exchange.storage.Access'):\n  bytes32 internal constant STORAGE_SLOT = 0x238f5ead2481aef1ec60acdfe5b3de34c076d0a86bb41e30c913f5f3885d7c47;\n\n  struct Data {\n    /// @dev The latest intializer version that was called.\n    uint16 version;\n    /// @dev This is where we hold our members data.\n    LibAddressSet.Data memberSet;\n    /// @dev This is where we keep track of our member FAST memberships.\n    mapping(address => LibAddressSet.Data) fastMemberships;\n    /// @dev This is where we keep track of our deactivated memberships.\n    LibAddressSet.Data deactivatedMemberSet;\n  }\n\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/exchange/lib/AExchangeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../../lib/LibConstants.sol';\nimport '../../lib/LibAddressSet.sol';\nimport '../lib/LibExchange.sol';\nimport '../lib/LibExchangeAccess.sol';\nimport '../../interfaces/IERC173.sol';\nimport '../../interfaces/IHasMembers.sol';\nimport './IExchangeEvents.sol';\n\n\n/**\n* @dev This contract is a group of modifiers that can be used by any Exchange facets to guard against\n*       certain permissions.\n*/\nabstract contract AExchangeFacet is IExchangeEvents {\n  using LibAddressSet for LibAddressSet.Data;\n\n  // Modifiers.\n\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\n  modifier onlyDeployer() {\n    require(\n      msg.sender == LibConstants.DEPLOYER_CONTRACT,\n      LibConstants.INTERNAL_METHOD\n    );\n    _;\n  }\n\n  /** @dev Requires that the message sender is a member of the linked SPC.\n   */\n  modifier onlySpcMember() {\n    require(\n      IHasMembers(LibExchange.data().spc).isMember(msg.sender),\n      LibConstants.REQUIRES_SPC_MEMBERSHIP\n    );\n    _;\n  }\n\n  /** @dev Requires that the given address is a member of the exchange.\n   *  @param candidate is the address to be checked.\n   */\n  modifier onlyMember(address candidate) {\n    require(\n      LibExchangeAccess.data().memberSet.contains(candidate),\n      LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP\n    );\n    _;\n  }\n}\n"
    },
    "contracts/fast/lib/LibFastHistory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\nlibrary LibFastHistory {\n  // The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  // This is keccak256('Fast.storage.History'):\n  bytes32 internal constant STORAGE_SLOT = 0x6bc8b61a9dd5fc049ea98027492a801d74e35fdf4d80d7fecd551a16e88fdbb4;\n\n  // Storage structures.\n\n  struct Data {\n    /// @dev The latest intializer version that was called.\n    uint16 version;\n    /// @dev All minting proofs are kept here.\n    SupplyProof[] supplyProofs;\n    /// @dev All transfer proofs are kept here.\n    TransferProof[] transferProofs;\n    /// @dev All transfers indices involving a given address are kept here.\n    mapping(address => uint256[]) transferProofInvolvements;\n  }\n\n  // Other structures.\n\n  /// @dev A minting operation could either be to mint or unmint tokens.\n  enum SupplyOp { Mint, Burn }\n\n  /// @dev Minting operations are recorded for papertrail. This is the structure that keeps track of them.\n  struct SupplyProof {\n    SupplyOp op;\n    uint256 amount;\n    uint256 blockNumber;\n    string ref;\n  }\n\n  /// @dev Every transfer in is recorded. This is the structure that keeps track of them.\n  struct TransferProof {\n    address spender;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 blockNumber;\n    string ref;\n  }\n\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/lib/LibHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary LibHelpers {\n  function upTo(address payable to, uint256 amount)\n      internal view returns(uint256) {\n    // If the recipient has more than what is ought to be paid, return.\n    uint256 toBalance = to.balance;\n    if (toBalance >= amount) { return 0; }\n    // If the recipient has some Eth we should only pay the top-up.\n    amount = amount - toBalance;\n    // If the available eth is less than what we should pay, just cap it.\n    uint256 available = payable(address(this)).balance;\n    if (available < amount) { amount = available; }\n    // Provision the new fast with Eth.\n    return amount;\n  }\n\n  function isContract(address target)\n      internal view returns (bool) {\n    uint32 size;\n    assembly { size := extcodesize(target) }\n    return (size > 0);\n  }\n}\n"
    },
    "contracts/fast/FastTopFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../lib/LibConstants.sol';\nimport '../lib/LibHelpers.sol';\nimport './lib/AFastFacet.sol';\nimport './lib/LibFast.sol';\nimport './lib/IFastEvents.sol';\nimport './FastFrontendFacet.sol';\n\ncontract FastTopFacet is AFastFacet {\n  // Getters and setters for global flags.\n\n  function spcAddress()\n      external view returns(address) {\n    return LibFast.data().spc;\n  }\n\n  function exchangeAddress()\n      external view returns(address) {\n    return LibFast.data().exchange;\n  }\n\n  function isSemiPublic()\n      external view returns(bool) {\n    return LibFast.data().isSemiPublic;\n  }\n\n  function hasFixedSupply()\n      external view returns(bool) {\n    return LibFast.data().hasFixedSupply;\n  }\n\n  // Setters for global flags.\n\n  /// @dev Allows to switch from a private scheme to a semi-public scheme, but not the other way around.\n  function setIsSemiPublic(bool flag)\n      external\n      onlySpcMember {\n    LibFast.Data storage s = LibFast.data();\n    // Someone is trying to toggle back to private?... No can do!isSemiPublic\n    require(!this.isSemiPublic() || this.isSemiPublic() == flag, LibConstants.UNSUPPORTED_OPERATION);\n    s.isSemiPublic = flag;\n    // Emit!\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n  }\n\n  // Provisioning functions.\n\n  function provisionWithEth()\n      external payable {\n    require(msg.value > 0, LibConstants.MISSING_ATTACHED_ETH);\n    emit EthReceived(msg.sender, msg.value);\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n  }\n\n  function drainEth()\n      onlySpcMember nonContract(msg.sender)\n      external {\n    uint256 amount = payable(address(this)).balance;\n    payable(msg.sender).transfer(amount);\n    emit EthDrained(msg.sender, amount);\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n  }\n\n  /**\n  * @dev This function allows contracts of the FAST network to request ETH\n  * provisioning to arbitrary addresses.\n  */\n  function payUpTo(address payable recipient, uint256 amount)\n      nonContract(recipient)\n      external onlyDiamondFacet {\n    require(\n      recipient != address(0),\n      LibConstants.REQUIRES_NON_ZERO_ADDRESS\n    );\n    amount = LibHelpers.upTo(recipient, amount);\n    // Transfer some eth!\n    if (amount != 0) { recipient.transfer(amount); }\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n  }\n}\n"
    },
    "contracts/fast/FastTokenFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../interfaces/IERC20.sol';\nimport '../interfaces/IERC1404.sol';\nimport '../interfaces/IHasMembers.sol';\nimport '../interfaces/IHasGovernors.sol';\nimport '../lib/LibDiamond.sol';\nimport '../lib/LibAddressSet.sol';\nimport '../lib/LibPaginate.sol';\nimport './lib/AFastFacet.sol';\nimport './lib/LibFastToken.sol';\nimport './lib/IFast.sol';\nimport './FastTopFacet.sol';\nimport './FastAccessFacet.sol';\nimport './FastHistoryFacet.sol';\nimport './FastFrontendFacet.sol';\n\n\ncontract FastTokenFacet is AFastFacet, IERC20, IERC1404 {\n  using LibAddressSet for LibAddressSet.Data;\n\n  // Minting methods.\n\n  function mint(uint256 amount, string calldata ref)\n      external\n      onlySpcMember {\n    LibFastToken.Data storage s = LibFastToken.data();\n    // We want to make sure that either of these two is true:\n    // - The token doesn't have fixed supply.\n    // - The token has fixed supply but has no tokens yet (First and only mint).\n    require(\n      !FastTopFacet(address(this)).hasFixedSupply() || (s.totalSupply == 0 && this.balanceOf(address(0)) == 0),\n      LibConstants.REQUIRES_CONTINUOUS_SUPPLY\n    );\n\n    // Prepare the minted amount on the zero address.\n    s.balances[address(0)] += amount;\n\n    // Keep track of the minting operation.\n    FastHistoryFacet(address(this)).minted(amount, ref);\n\n    // Emit!\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n    emit Minted(amount, ref);\n  }\n\n  function burn(uint256 amount, string calldata ref)\n      external\n      onlySpcMember {\n    LibFastToken.Data storage s = LibFastToken.data();\n\n    require(!FastTopFacet(address(this)).hasFixedSupply(), LibConstants.REQUIRES_CONTINUOUS_SUPPLY);\n    require(balanceOf(address(0)) >= amount, LibConstants.INSUFFICIENT_FUNDS);\n\n    // Remove the minted amount from the zero address.\n    s.balances[address(0)] -= amount;\n\n    // Keep track of the minting operation.\n    FastHistoryFacet(address(this)).burnt(amount, ref);\n\n    // Emit!\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n    emit Burnt(amount, ref);\n  }\n\n  // Tranfer Credit management.\n\n  function transferCredits()\n      external view returns(uint256) {\n    return LibFastToken.data().transferCredits;\n  }\n\n  function addTransferCredits(uint256 amount)\n      external\n      onlySpcMember {\n    LibFastToken.data().transferCredits += amount;\n    // Emit!\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n    emit TransferCreditsAdded(msg.sender, amount);\n  }\n\n  function drainTransferCredits()\n      external\n      onlySpcMember {\n    LibFastToken.Data storage s = LibFastToken.data();\n    // Emit!\n    emit TransferCreditsDrained(msg.sender, s.transferCredits);\n    // Drain credits.\n    s.transferCredits = 0;\n    // Emit!\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n  }\n\n  // ERC20 implementation and transfer related methods.\n\n  function name()\n      external view returns(string memory) {\n    return LibFastToken.data().name;\n  }\n\n  function symbol()\n      external view returns(string memory) {\n    return LibFastToken.data().symbol;\n  }\n\n  function decimals()\n      external view returns(uint256) {\n    return LibFastToken.data().decimals;\n  }\n\n  function totalSupply()\n      external override view returns(uint256) {\n    return LibFastToken.data().totalSupply;\n  }\n\n  function balanceOf(address owner)\n      public view override returns(uint256) {\n    return LibFastToken.data().balances[owner];\n  }\n\n  function transfer(address to, uint256 amount)\n      external override returns(bool) {\n    // Make sure the call is performed externally so that we can mock.\n    this.performTransfer(\n      TransferArgs({\n        spender: msg.sender,\n        from: msg.sender,\n        to: to,\n        amount: amount,\n        ref: LibFastToken.DEFAULT_TRANSFER_REFERENCE\n      })\n    );\n    return true;\n  }\n\n  function transferWithRef(address to, uint256 amount, string calldata ref)\n      external {\n    // Make sure the call is performed externally so that we can mock.\n    this.performTransfer(\n      TransferArgs({\n        spender: msg.sender,\n        from: msg.sender,\n        to: to,\n        amount: amount,\n        ref: ref\n      })\n    );\n  }\n\n  function allowance(address owner, address spender)\n      public view override returns(uint256) {\n    LibFastToken.Data storage s = LibFastToken.data();\n    // If the allowance being queried is from the zero address and the spender\n    // is a governor, we want to make sure that the spender has full rights over it.\n    if (owner == address(0)) {\n      require(FastAccessFacet(address(this)).isGovernor(spender), LibConstants.REQUIRES_FAST_GOVERNORSHIP);\n      return s.balances[owner];\n    }\n    return s.allowances[owner][spender];\n  }\n\n  function approve(address spender, uint256 amount)\n      external override returns(bool) {\n    // Make sure the call is performed externally so that we can mock.\n    this.performApproval(msg.sender, spender, amount);\n    return true;\n  }\n\n  function disapprove(address spender)\n      external\n      onlyMember(msg.sender) {\n    // Make sure the call is performed externally so that we can mock.\n    this.performDisapproval(msg.sender, spender);\n  }\n\n  function transferFrom(address from, address to, uint256 amount)\n      external override returns(bool) {\n    transferFromWithRef(from, to, amount, LibFastToken.DEFAULT_TRANSFER_REFERENCE);\n    return true;\n  }\n\n  function transferFromWithRef(address from, address to, uint256 amount, string memory ref)\n      public {\n    // Make sure the call is performed externally so that we can mock.\n    this.performTransfer(\n      TransferArgs({\n        spender: msg.sender,\n        from: from,\n        to: to,\n        amount: amount,\n        ref: ref\n      })\n    );\n  }\n\n  // Allowances query operations.\n\n  function givenAllowanceCount(address owner)\n      external view returns(uint256) {\n    return LibFastToken.data().allowancesByOwner[owner].values.length;\n  }\n\n  function paginateAllowancesByOwner(address owner, uint256 index, uint256 perPage)\n      external view returns(address[] memory, uint256) {\n    return LibPaginate.addresses(\n      LibFastToken.data().allowancesByOwner[owner].values,\n      index,\n      perPage\n    );\n  }\n\n  function receivedAllowanceCount(address spender)\n      external view returns(uint256) {\n    return LibFastToken.data().allowancesBySpender[spender].values.length;\n  }\n\n  function paginateAllowancesBySpender(address spender, uint256 index, uint256 perPage)\n      external view returns(address[] memory, uint256) {\n    return LibPaginate.addresses(\n      LibFastToken.data().allowancesBySpender[spender].values,\n      index,\n      perPage\n    );\n  }\n\n  // ERC1404 implementation.\n\n  function detectTransferRestriction(address from, address to, uint256 amount)\n      external view override returns(uint8) {\n    LibFastToken.Data storage s = LibFastToken.data();\n    if (s.transferCredits < amount) {\n      return LibFastToken.INSUFFICIENT_TRANSFER_CREDITS_CODE;\n    } else if (!FastAccessFacet(address(this)).isMember(from) ||\n               !FastAccessFacet(address(this)).isMember(to)) {\n      return FastTopFacet(address(this)).isSemiPublic()\n        ? LibFastToken.REQUIRES_EXCHANGE_MEMBERSHIP_CODE\n        : LibFastToken.REQUIRES_FAST_MEMBERSHIP_CODE;\n    } else if (from == to) {\n      return LibFastToken.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE;\n    }\n    return 0;\n  }\n\n  function messageForTransferRestriction(uint8 restrictionCode)\n      external override pure returns(string memory) {\n    if (restrictionCode == LibFastToken.INSUFFICIENT_TRANSFER_CREDITS_CODE) {\n      return LibConstants.INSUFFICIENT_TRANSFER_CREDITS;\n    } else if (restrictionCode == LibFastToken.REQUIRES_EXCHANGE_MEMBERSHIP_CODE) {\n      return LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP;\n    } else if (restrictionCode == LibFastToken.REQUIRES_FAST_MEMBERSHIP_CODE) {\n      return LibConstants.REQUIRES_FAST_MEMBERSHIP;\n    } else if (restrictionCode == LibFastToken.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE) {\n      return LibConstants.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT;\n    }\n    revert(LibConstants.UNKNOWN_RESTRICTION_CODE);\n  }\n\n  // These functions would be internal / private if we weren't using the diamond pattern.\n  // Instead, they're `onlyDiamondFacet` - eg can only be called by facets of the current\n  // FAST.\n\n  struct TransferArgs {\n    address spender;\n    address from;\n    address to;\n    uint256 amount;\n    string ref;\n  }\n\n  function performTransfer(TransferArgs calldata p)\n      external onlyDiamondFacet\n      differentAddresses(p.from, p.to)\n      onlyTokenHolder(p.from)\n      onlyExchangeActiveMember(p.from)\n      onlyTokenHolder(p.to) {\n    LibFastToken.Data storage s = LibFastToken.data();\n\n    // Make sure that there's enough funds.\n    require(\n      s.balances[p.from] >= p.amount,\n      LibConstants.INSUFFICIENT_FUNDS\n    );\n    require(\n      p.amount > 0,\n      LibConstants.UNSUPPORTED_OPERATION\n    );\n\n    // If this is an allowance transfer...\n    if (p.spender != p.from) {\n      // Make sure that the spender has enough allowance.\n      require(\n        FastTokenFacet(address(this)).allowance(p.from, p.spender) >= p.amount,\n        LibConstants.INSUFFICIENT_ALLOWANCE\n      );\n\n      // If the from account isn't the zero address...\n      if (p.from != address(0)) {\n        // Decrease allowance.\n        uint256 newAllowance = s.allowances[p.from][p.spender] -= p.amount;\n        // If the allowance reached zero, we want to remove that allowance from\n        // the various other places where we keep track of it.\n        if (newAllowance == 0) {\n          s.allowancesByOwner[p.from].remove(p.spender, true);\n          s.allowancesBySpender[p.spender].remove(p.from, true);\n        }\n      }\n    }\n\n    // Keep track of the balances - `from` spends, `to` receives.\n    s.balances[p.from] -= p.amount;\n    s.balances[p.to] += p.amount;\n\n    // If the funds are not moving from the zero address, decrease transfer credits.\n    if (p.from != address(0)) {\n      // Make sure enough credits exist.\n      require(\n        s.transferCredits >= p.amount,\n        LibConstants.INSUFFICIENT_TRANSFER_CREDITS\n      );\n      s.transferCredits -= p.amount;\n    }\n\n    // If the funds are going to the ZERO address, decrease total supply.\n    if (p.to == address(0)) {\n      s.totalSupply -= p.amount;\n      // If funds at address zero changed, we can emit a top-level details change event.\n      FastFrontendFacet(address(this)).emitDetailsChanged();\n    }\n    // If the funds are moving from the zero address, increase total supply.\n    else if (p.from == address(0)) {\n      s.totalSupply += p.amount;\n      // If funds at address zero changed, we can emit a top-level details change event.\n      FastFrontendFacet(address(this)).emitDetailsChanged();\n    }\n\n    // Keep track of the transfer in the history facet.\n    FastHistoryFacet(address(this)).transfered(p.spender, p.from, p.to, p.amount, p.ref);\n\n    // Emit!\n    emit Transfer(p.from, p.to, p.amount);\n  }\n\n  function performApproval(address from, address spender, uint256 amount)\n      external\n      onlyDiamondFacet\n      onlyTokenHolder(from) {\n    LibFastToken.Data storage s = LibFastToken.data();\n\n    // Store allowance...\n    s.allowances[from][spender] += amount;\n    // Keep track of given and received allowances.\n    s.allowancesByOwner[from].add(spender, true);\n    s.allowancesBySpender[spender].add(from, true);\n\n    // Emit!\n    emit Approval(from, spender, amount);\n  }\n\n  function performDisapproval(address from, address spender)\n      external\n      onlyDiamondFacet {\n    LibFastToken.Data storage s = LibFastToken.data();\n\n    // Remove allowance.\n    s.allowances[from][spender] = 0;\n    s.allowancesByOwner[from].remove(spender, false);\n    s.allowancesBySpender[spender].remove(from, false);\n\n    // Emit!\n    emit Disapproval(from, spender);\n  }\n\n  // WARNING: This function contains two loops. We know that this should never\n  // happen in solidity. However:\n  // - In the context of our private chain, gas is cheap.\n  // - It can only be called by a governor.\n  function beforeRemovingMember(address member)\n      external onlyDiamondFacet() {\n    require(balanceOf(member) == 0, 'Balance is positive');\n\n    LibFastToken.Data storage s = LibFastToken.data();\n\n    // Remove all given allowances.\n    address[] storage gaData = s.allowancesByOwner[member].values;\n    while (gaData.length > 0) {\n      // Make sure the call is performed externally so that we can mock.\n      this.performDisapproval(member, gaData[0]);\n    }\n\n    // Remove all received allowances.\n    address[] storage raData = s.allowancesBySpender[member].values;\n    while (raData.length > 0) {\n      // Make sure the call is performed externally so that we can mock.\n      this.performDisapproval(raData[0], member);\n    }\n  }\n\n  // Modifiers.\n\n  /** @dev Ensures that the given address is a member of the current FAST or the Zero Address.\n   *  @param candidate The address to check.\n   */\n  modifier onlyTokenHolder(address candidate) {\n    // Only perform checks if the address is non-zero.\n    if (candidate != address(0)) {\n    // FAST is semi-public - the only requirement to hold tokens is to be an exchange member.\n      if (IFast(address(this)).isSemiPublic()) {\n        require(\n          IHasMembers(LibFast.data().exchange).isMember(candidate),\n          LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP\n        );\n      }\n      // FAST is private, the requirement to hold tokens is to be a member of that FAST.\n      else {\n        require(\n          IHasMembers(address(this)).isMember(candidate),\n          LibConstants.REQUIRES_FAST_MEMBERSHIP\n        );\n      }\n    }\n    _;\n  }\n}\n"
    },
    "contracts/spc/lib/ASpcFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../../lib/LibConstants.sol';\nimport '../../lib/LibHelpers.sol';\nimport '../../lib/LibAddressSet.sol';\nimport '../../interfaces/IERC173.sol';\nimport '../lib/LibSpcAccess.sol';\nimport './ISpcEvents.sol';\n\n\n/**\n* @dev This contract is a group of modifiers that can be used by any facets to guard against\n*       certain permissions.\n*/\nabstract contract ASpcFacet is ISpcEvents {\n  using LibAddressSet for LibAddressSet.Data;\n\n  /// Modifiers.\n\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\n  modifier onlyDiamondFacet() {\n    require(\n      msg.sender == address(this),\n      LibConstants.INTERNAL_METHOD\n    );\n    _;\n  }\n\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\n  modifier onlyDiamondOwner() {\n    require(\n      msg.sender == IERC173(address(this)).owner(),\n      LibConstants.REQUIRES_DIAMOND_OWNERSHIP\n    );\n    _;\n  }\n\n  /** @dev Ensures that the given address is **not** a contract.\n   *  @param candidate The address to check.\n   */\n  modifier nonContract(address candidate) {\n    require(\n      !LibHelpers.isContract(candidate),\n      LibConstants.REQUIRES_NON_CONTRACT_ADDR\n    );\n    _;\n  }\n\n  /// @dev Ensures that the given address is a member of the current FAST.\n  modifier onlyMember(address candidate) {\n    require(\n      LibSpcAccess.data().memberSet.contains(candidate),\n      LibConstants.REQUIRES_SPC_MEMBERSHIP\n    );\n    _;\n  }\n}\n"
    },
    "contracts/spc/lib/LibSpc.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../../lib/LibAddressSet.sol';\n\n\nlibrary LibSpc {\n  // The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  // This is keccak256('Spc.storage'):\n  bytes32 internal constant STORAGE_SLOT = 0x89a652f66ca129ef71cab44916bb070742a08af428e08a99df145c8006c94285;\n\n  // Data structures.\n\n  struct Data {\n    /// @dev The latest intializer version that was called.\n    uint16 version;\n    // This is where we keep our list of deployed fast FASTs.\n    LibAddressSet.Data fastSet;\n    // We keep track of the FAST symbols that were already used.\n    mapping(string => address) fastSymbols;\n  }\n\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/lib/LibConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\nlibrary LibConstants {\n  address internal constant ZERO_ADDRESS = address(0);\n  address internal constant DEPLOYER_CONTRACT = 0x6DF2D25d8C6FD680730ee658b530A05a99BB769a;\n\n  string internal constant ALREADY_INITIALIZED = 'Already initialized';\n  string internal constant INTERNAL_METHOD = 'Internal method';\n  string internal constant REQUIRES_DIAMOND_OWNERSHIP = 'Requires diamond ownership';\n  string internal constant REQUIRES_FAST_CONTRACT_CALLER = 'Caller must be a FAST contract';\n\n  string internal constant REQUIRES_SPC_MEMBERSHIP = 'Requires SPC membership';\n  string internal constant REQUIRES_EXCHANGE_MEMBERSHIP = 'Requires Exchange membership';\n  string internal constant REQUIRES_EXCHANGE_ACTIVE_MEMBER = 'Requires active Exchange member';\n  string internal constant REQUIRES_EXCHANGE_DEACTIVATED_MEMBER = 'Requires a deactivated Exchange member';\n\n  string internal constant REQUIRES_FAST_GOVERNORSHIP = 'Requires FAST governorship';\n  string internal constant REQUIRES_FAST_MEMBERSHIP = 'Requires FAST membership';\n  string internal constant REQUIRES_NO_FAST_MEMBERSHIPS = 'Member still part of at least one FAST';\n\n  string internal constant DUPLICATE_ENTRY = 'Duplicate entry';\n  string internal constant UNSUPPORTED_OPERATION = 'Unsupported operation';\n  string internal constant REQUIRES_NON_ZERO_ADDRESS = 'Requires non-zero address';\n  string internal constant REQUIRES_NON_CONTRACT_ADDR = 'Address cannot be a contract';\n\n  string internal constant MISSING_ATTACHED_ETH = 'Missing attached ETH';\n\n  string internal constant REQUIRES_CONTINUOUS_SUPPLY = 'Requires continuous supply';\n  string internal constant INSUFFICIENT_FUNDS = 'Insufficient token balance';\n  string internal constant INSUFFICIENT_ALLOWANCE = 'Insufficient allowance';\n  string internal constant INSUFFICIENT_TRANSFER_CREDITS = 'Insufficient transfer credits';\n  string internal constant REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT = 'Requires different sender and recipient';\n  string internal constant UNKNOWN_RESTRICTION_CODE = 'Unknown restriction code';\n}\n"
    },
    "contracts/fast/lib/AFastFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../../lib/LibConstants.sol';\nimport '../../lib/LibHelpers.sol';\nimport '../../lib/LibAddressSet.sol';\nimport '../../interfaces/IHasMembers.sol';\nimport '../../interfaces/IHasGovernors.sol';\nimport '../../interfaces/IHasActiveMembers.sol';\nimport '../../interfaces/IERC173.sol';\nimport '../lib/LibFast.sol';\nimport './IFastEvents.sol';\n\n\n/**\n* @dev This contract is a group of modifiers that can be used by any facets to guard against\n*       certain permissions.\n*/\nabstract contract AFastFacet is IFastEvents {\n  using LibAddressSet for LibAddressSet.Data;\n\n  /// Modifiers.\n\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\n  modifier onlyDiamondFacet() {\n    require(\n      msg.sender == address(this),\n      LibConstants.INTERNAL_METHOD\n    );\n    _;\n  }\n\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\n  modifier onlyDiamondOwner() {\n    require(\n      msg.sender == IERC173(address(this)).owner(),\n      LibConstants.REQUIRES_DIAMOND_OWNERSHIP\n    );\n    _;\n  }\n\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\n  modifier onlyDeployer() {\n    require(\n      msg.sender == LibConstants.DEPLOYER_CONTRACT,\n      LibConstants.INTERNAL_METHOD\n    );\n    _;\n  }\n\n  /** @dev Ensures that the given address is **not** a contract.\n   *  @param candidate The address to check.\n   */\n  modifier nonContract(address candidate) {\n    require(\n      !LibHelpers.isContract(candidate),\n      LibConstants.REQUIRES_NON_CONTRACT_ADDR\n    );\n    _;\n  }\n\n  /** @dev Ensures that the given address is a member of the Exchange.\n   *  @param candidate The address to check.\n   */\n  modifier onlyExchangeMember(address candidate) {\n    require(\n      IHasMembers(LibFast.data().exchange).isMember(candidate),\n      LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP\n    );\n    _;\n  }\n\n  /** @dev Ensures a candidate is active.\n   *  @param candidate The address to check activation status on.\n   */\n  modifier onlyExchangeActiveMember(address candidate) {\n    require(\n      IHasActiveMembers(LibFast.data().exchange).isMemberActive(candidate),\n      LibConstants.REQUIRES_EXCHANGE_ACTIVE_MEMBER\n    );\n    _;\n  }\n\n  /** @dev Ensures that the message sender is a member of the SPC.\n   */\n  modifier onlySpcMember() {\n    require(\n      IHasMembers(LibFast.data().spc).isMember(msg.sender),\n      LibConstants.REQUIRES_SPC_MEMBERSHIP\n    );\n    _;\n  }\n\n  /** @dev Ensures that the given address is a governor of the FAST.\n   *  @param candidate The address to check.\n   */\n  modifier onlyGovernor(address candidate) {\n    require(\n      IHasGovernors(address(this)).isGovernor(candidate),\n      LibConstants.REQUIRES_FAST_GOVERNORSHIP\n    );\n    _;\n  }\n\n  /** @dev Ensures that the given address is a member of the FAST.\n   *  @param candidate The address to check.\n   */\n  modifier onlyMember(address candidate) {\n    require(\n      IHasMembers(address(this)).isMember(candidate),\n      LibConstants.REQUIRES_FAST_MEMBERSHIP\n    );\n    _;\n  }\n\n  /** @dev Ensures address a is different from address b.\n   *  @param a Address a\n   *  @param b Address b\n   */\n  modifier differentAddresses(address a, address b) {\n    require(a != b, LibConstants.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT);\n    _;\n  }\n}\n"
    },
    "contracts/fast/lib/LibFast.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\nlibrary LibFast {\n  // The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  // This is keccak256('Fast.storage'):\n  bytes32 internal constant STORAGE_SLOT = 0x80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705;\n\n  // Data structures.\n\n  struct Data {\n    /// @dev The latest intializer version that was called.\n    uint16 version;\n    /// @dev The internal pointer to the SPC contract.\n    address spc;\n    /// @dev The internal pointer to the Exchange contract.\n    address exchange;\n    /// @dev We have to track whether the token facet provides continuous minting or fixed supply.\n    bool hasFixedSupply;\n    /// @dev Whether or not this FAST requires to be a member to hold tokens.\n    bool isSemiPublic;\n  }\n\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/fast/lib/IFastEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\ninterface IFastEvents {\n  // ETH provisioning events.\n\n  /** @dev Emited when someone provisions this SPC with Eth.\n   *  @param from The sender of the Eth.\n   *  @param amount The quantity of Eth, expressed in Wei.\n   */\n  event EthReceived(address indexed from, uint256 amount);\n  /** @dev Emited when Eth is drained from this SPC.\n   *  @param to The caller and recipient of the drained Eth.\n   *  @param amount The quantity of Eth that was drained, expressed in Wei.\n   */\n  event EthDrained(address indexed to, uint256 amount);\n\n  // IHasMembers.\n\n  event MemberAdded(address indexed member);\n  event MemberRemoved(address indexed member);\n\n  // IHasGovernors.\n\n  event GovernorAdded(address indexed governor);\n  event GovernorRemoved(address indexed governor);\n\n  // Token related events.\n\n  // Issuance related events.\n  event Minted(uint256 indexed amount, string indexed ref);\n  event Burnt(uint256 indexed amount, string indexed ref);\n\n  // Transfer credits related events.\n  event TransferCreditsAdded(address indexed spcMember, uint256 amount);\n  event TransferCreditsDrained(address indexed spcMember, uint256 amount);\n\n  // ERC20 stuff.\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Disapproval(address indexed owner, address indexed spender);\n\n  // General events.\n\n  // This is an event that is fired whenever any of some of the FAST parameters\n  // change, so that the frontend can react to it and refresh the general header\n  // for that fast as well as the baseball cards in the FASTs list.\n  event DetailsChanged(\n    uint256 memberCount,\n    uint256 governorCount,\n    uint256 totalSupply,\n    uint256 transferCredits,\n    uint256 reserveBalance,\n    uint256 ethBalance\n  );\n}\n"
    },
    "contracts/fast/FastFrontendFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../lib/LibAddressSet.sol';\nimport '../lib/LibPaginate.sol';\nimport './lib/AFastFacet.sol';\nimport './lib/LibFastAccess.sol';\nimport './lib/LibFastToken.sol';\n\n\ncontract FastFrontendFacet is AFastFacet {\n  using LibAddressSet for LibAddressSet.Data;\n\n  // Data structures.\n\n  struct Details {\n    address addr;\n    string name;\n    string symbol;\n    uint256 decimals;\n    uint256 totalSupply;\n    uint256 transferCredits;\n    bool isSemiPublic;\n    bool hasFixedSupply;\n    uint256 reserveBalance;\n    uint256 ethBalance;\n    uint256 memberCount;\n    uint256 governorCount;\n  }\n\n  struct MemberDetails {\n    address addr;\n    uint256 balance;\n    uint256 ethBalance;\n    bool isGovernor;\n  }\n\n  // Emitters.\n\n  function emitDetailsChanged()\n      external onlyDiamondFacet {\n    LibFastAccess.Data storage accessData = LibFastAccess.data();\n    LibFastToken.Data storage tokenData = LibFastToken.data();\n    emit DetailsChanged({\n      memberCount: accessData.memberSet.values.length,\n      governorCount: accessData.governorSet.values.length,\n      totalSupply: tokenData.totalSupply,\n      transferCredits: tokenData.transferCredits,\n      reserveBalance: tokenData.balances[LibConstants.ZERO_ADDRESS],\n      ethBalance: payable(address(this)).balance\n    });\n  }\n\n  // Public functions.\n\n  function details()\n      public view returns(Details memory) {\n    LibFast.Data storage topStorage = LibFast.data();\n    LibFastAccess.Data storage accessStorage = LibFastAccess.data();\n    LibFastToken.Data storage tokenStorage = LibFastToken.data();\n    return Details({\n      addr: address(this),\n      name: tokenStorage.name,\n      symbol: tokenStorage.symbol,\n      decimals: tokenStorage.decimals,\n      totalSupply: tokenStorage.totalSupply,\n      transferCredits: tokenStorage.transferCredits,\n      isSemiPublic: topStorage.isSemiPublic,\n      hasFixedSupply: topStorage.hasFixedSupply,\n      reserveBalance: tokenStorage.balances[LibConstants.ZERO_ADDRESS],\n      ethBalance: payable(address(this)).balance,\n      memberCount: accessStorage.memberSet.values.length,\n      governorCount: accessStorage.governorSet.values.length\n    });\n  }\n\n  function detailedMember(address member)\n      public view returns(MemberDetails memory) {\n    LibFastToken.Data storage tokenStorage = LibFastToken.data();\n    LibFastAccess.Data storage accessStorage = LibFastAccess.data();\n    return MemberDetails({\n      addr: member,\n      balance: tokenStorage.balances[member],\n      ethBalance: member.balance,\n      isGovernor: accessStorage.governorSet.contains(member)\n    });\n  }\n\n  function paginateDetailedMembers(uint256 index, uint256 perPage)\n      external view returns(MemberDetails[] memory, uint256) {\n    LibFastAccess.Data storage accessStorage = LibFastAccess.data();\n    (address[] memory members, uint256 nextCursor) =\n      LibPaginate.addresses(accessStorage.memberSet.values, index, perPage);\n    MemberDetails[] memory values = new MemberDetails[](members.length);\n    for (uint256 i = 0; i < members.length; ++i) {\n      values[i] = detailedMember(members[i]);\n    }\n    return (values, nextCursor);\n  }\n}\n"
    },
    "contracts/interfaces/IHasGovernors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\ninterface IHasGovernors {\n  function isGovernor(address governor) external view returns(bool);\n  function governorCount() external view returns(uint256);\n  function paginateGovernors(uint256 index, uint256 perPage) external view returns(address[] memory, uint256);\n  function addGovernor(address payable governor) external;\n  function removeGovernor(address governor) external;\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/fast/lib/LibFastAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../../lib/LibAddressSet.sol';\n\nlibrary LibFastAccess {\n  // The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  // This is keccak256('Fast.storage.Access'):\n  bytes32 internal constant STORAGE_SLOT = 0x87ed8063ac9ead3b2eb7551ed3d89b29fcbf44d6733084b5c82e95d5120ece9a;\n\n  struct Data {\n    /// @dev The latest intializer version that was called.\n    uint16 version;\n    /// @dev We hold the list of the FAST governors in there.\n    LibAddressSet.Data governorSet;\n    // @dev The FAST members are held in there.\n    LibAddressSet.Data memberSet;\n  }\n\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/fast/lib/LibFastToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../../lib/LibAddressSet.sol';\n\n\nlibrary LibFastToken {\n  // The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  // This is keccak256('Fast.storage.Token'):\n  bytes32 internal constant STORAGE_SLOT = 0xb098747b87c5c0e2a32eb9b06725e9bad4263809bcda628ceadc1a686bcb8261;\n\n  // Constants.\n\n  // ERC1404 Restriction codes.\n  uint8 internal constant INSUFFICIENT_TRANSFER_CREDITS_CODE = 1;\n  uint8 internal constant REQUIRES_FAST_MEMBERSHIP_CODE = 2;\n  uint8 internal constant REQUIRES_EXCHANGE_MEMBERSHIP_CODE = 3;\n  uint8 internal constant REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE = 4;\n\n  string internal constant DEFAULT_TRANSFER_REFERENCE = 'Unspecified - via ERC20';\n\n  // Data structures.\n\n  struct Data {\n    /// @dev The latest intializer version that was called.\n    uint16 version;\n    // ERC20 related properties for this FAST Token.\n    string name;\n    string symbol;\n    uint256 decimals;\n    uint256 totalSupply;\n    // Every time a transfer is executed, the credit decreases by the amount\n    // of said transfer.\n    // It becomes impossible to transact once it reaches zero, and must\n    // be provisioned by an SPC governor.\n    uint256 transferCredits;\n    // Our members balances are held here.\n    mapping(address => uint256) balances;\n    // Allowances are stored here.\n    mapping(address => mapping(address => uint256)) allowances;\n    mapping(address => LibAddressSet.Data) allowancesByOwner;\n    mapping(address => LibAddressSet.Data) allowancesBySpender;\n  }\n\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC1404.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\n/**\n * @dev Interface of the ERC1404 standard as defined in the EIP.\n */\ninterface IERC1404 {\n  /**\n   * @dev Returns a transfer restriction error code if the transfer shoudln't be permitted,\n   *      or otherwise returns zero if everything looks fine.\n   * @param owner is the account from which the tokens should be transfered.\n   * @param recipient is the target of the transfer.\n   * @param amount is the amount to be transfered.\n   * @return a uint8 error code if a problem was detected, otherwise zero.\n   */\n  function detectTransferRestriction(address owner, address recipient, uint256 amount)\n    external\n    view\n    returns (uint8);\n\n  /**\n   * @dev Maps a transfer restriction error code into a human-readable string.\n   * @param code is the code that should be transformed into a string.\n   * @return A string that describes the given error code.\n   */\n  function messageForTransferRestriction(uint8 code) external pure returns (string memory);\n}\n"
    },
    "contracts/lib/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/fast/lib/IFast.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\ninterface IFast {\n  function isSemiPublic() external view returns(bool);\n  function hasFixedSupply() external view returns(bool);\n}\n"
    },
    "contracts/fast/FastAccessFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../interfaces/IHasMembers.sol';\nimport '../interfaces/IHasGovernors.sol';\nimport '../lib/LibAddressSet.sol';\nimport '../lib/LibPaginate.sol';\nimport '../exchange/ExchangeAccessFacet.sol';\nimport './FastTokenFacet.sol';\nimport './lib/AFastFacet.sol';\nimport './lib/LibFast.sol';\nimport './lib/LibFastAccess.sol';\nimport './FastTopFacet.sol';\nimport './FastFrontendFacet.sol';\n\n\n/**\n* @dev The FAST Access Smart Contract is the source of truth when it comes to\n* permissioning and ACLs within a given FAST network.\n*/\ncontract FastAccessFacet is AFastFacet, IHasMembers, IHasGovernors {\n  using LibAddressSet for LibAddressSet.Data;\n  // Structs.\n\n  /**\n   * @dev This structure isn't used anywhere in storage. Instead, it\n   * allows various methods of the contract to return all the flags\n   * associated with a given address in one go.\n   */\n  struct Flags {\n    bool isGovernor;\n    bool isMember;\n  }\n\n  // Constants.\n\n  // This represents how much Eth we provision new governors with.\n  uint256 constant private GOVERNOR_ETH_PROVISION = 10 ether;\n  // This represents how much Eth we provision new members with.\n  uint256 constant private MEMBER_ETH_PROVISION = 1 ether;\n\n  // Governorship related stuff.\n\n  /**\n   * @dev Queries whether a given address is a governor or not.\n   */\n  function isGovernor(address candidate)\n      external view override returns(bool) {\n    return LibFastAccess.data().governorSet.contains(candidate);\n  }\n\n  /**\n   * @dev Queries the number of governors in the governor list.\n   */\n  function governorCount()\n      external override view returns(uint256) {\n    return LibFastAccess.data().governorSet.values.length;\n  }\n\n  /**\n   * @dev Returns a page of governors.\n   */\n  function paginateGovernors(uint256 index, uint256 perPage)\n      external override view returns(address[] memory, uint256) {\n    return LibPaginate.addresses(LibFastAccess.\n      data().governorSet.values,\n      index,\n      perPage\n    );\n  }\n\n  /**\n   * @dev Adds a governor to the governor list.\n   */\n  function addGovernor(address payable governor)\n      external override\n      onlySpcMember\n      onlyExchangeMember(governor) {\n    // Add governor to list.\n    LibFastAccess.data().governorSet.add(governor, false);\n    // If the address is a regular wallet...\n    if (!LibHelpers.isContract(governor)) {\n      // Provision the new governor with Eth if possible.\n      FastTopFacet(payable(address(this))).payUpTo(governor, GOVERNOR_ETH_PROVISION);\n    }\n    // Emit!\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n    emit GovernorAdded(governor);\n  }\n\n  /**\n   * @dev Removes a governor from the governor list.\n   */\n  function removeGovernor(address governor)\n      external override\n      onlySpcMember {\n    // Remove governor.\n    LibFastAccess.data().governorSet.remove(governor, false);\n    // Emit!\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n    emit GovernorRemoved(governor);\n  }\n\n  /// Membership related stuff.\n\n  /**\n   * @dev Queries whether a given address is a member or not.\n   */\n  function isMember(address candidate)\n      external override view returns(bool) {\n    return LibFastAccess.data().memberSet.contains(candidate);\n  }\n\n  /**\n   * @dev Queries the number of members in the membership list.\n   */\n  function memberCount()\n      external override view returns(uint256) {\n    return LibFastAccess.data().memberSet.values.length;\n  }\n\n  /**\n   * @dev Returns a page of members.\n   */\n  function paginateMembers(uint256 index, uint256 perPage)\n      external override view returns(address[] memory, uint256) {\n    return LibPaginate.addresses(\n      LibFastAccess.data().memberSet.values,\n      index,\n      perPage\n    );\n  }\n\n  /**\n   * @dev Adds a member to the membership list.\n   */\n  function addMember(address payable member)\n      external override \n      onlyGovernor(msg.sender) onlyExchangeMember(member) {\n    // Add the member.\n    LibFastAccess.data().memberSet.add(member, false);\n    // If the address is a regular wallet...\n    if (!LibHelpers.isContract(member)) {\n      // Provision the new member with Eth if possible.\n      FastTopFacet(payable(address(this))).payUpTo(member, MEMBER_ETH_PROVISION);\n    }\n    // Notify exchange that this member was added to this FAST.\n    ExchangeAccessFacet(LibFast.data().exchange).memberAddedToFast(member);\n    // Emit!\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n    emit MemberAdded(member);\n  }\n\n  /**\n   * @dev Removes a member from the membership list.\n   */\n  function removeMember(address member)\n      external override \n      onlyGovernor(msg.sender) {\n    // Remove member.\n    LibFastAccess.data().memberSet.remove(member, false);\n    // Notify token facet that this member was removed.\n    FastTokenFacet(address(this)).beforeRemovingMember(member);\n    // Notify exchange that this member was removed from this FAST.\n    ExchangeAccessFacet(LibFast.data().exchange).memberRemovedFromFast(member);\n    // Emit!\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n    emit MemberRemoved(member);\n  }\n\n  /// Flags.\n\n  /**\n   * @dev Retrieves flags for a given address.\n   */\n  function flags(address a)\n      external view returns(Flags memory) {\n    LibFastAccess.Data storage s = LibFastAccess.data();\n    return\n      Flags({\n        isGovernor: s.governorSet.contains(a),\n        isMember: s.memberSet.contains(a)\n      });\n  }\n}\n"
    },
    "contracts/fast/FastHistoryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../lib/LibPaginate.sol';\nimport './lib/AFastFacet.sol';\nimport './lib/LibFastHistory.sol';\n\n\ncontract FastHistoryFacet is AFastFacet {\n  /// Minting history-keeping methods.\n\n  function minted(uint256 amount, string calldata ref)\n      external onlyDiamondFacet() {\n    // Keep track of the mint.\n    LibFastHistory.data().supplyProofs.push(\n      LibFastHistory.SupplyProof({\n        op: LibFastHistory.SupplyOp.Mint,\n        amount: amount,\n        blockNumber: block.number,\n        ref: ref\n      })\n    );\n  }\n\n  function burnt(uint256 amount, string calldata ref)\n      external onlyDiamondFacet() {\n    // Keep track of the unmint.\n    LibFastHistory.data().supplyProofs.push(\n      LibFastHistory.SupplyProof({\n        op: LibFastHistory.SupplyOp.Burn,\n        amount: amount,\n        blockNumber: block.number,\n        ref: ref\n      })\n    );\n  }\n\n  function supplyProofCount()\n      external view returns(uint256) {\n    return LibFastHistory.data().supplyProofs.length;\n  }\n\n  function paginateSupplyProofs(uint256 cursor, uint256 perPage)\n      external view returns(LibFastHistory.SupplyProof[] memory, uint256) {\n    return LibPaginate.supplyProofs(LibFastHistory.data().supplyProofs, cursor, perPage);\n  }\n\n  /// Transfer history-keeping methods.\n\n  function transfered(address spender, address from, address to, uint256 amount, string calldata ref)\n      external onlyDiamondFacet() {\n    LibFastHistory.Data storage s = LibFastHistory.data();\n    // Keep track of the transfer proof ID for the sender and for the recipient.\n    s.transferProofInvolvements[from].push(s.transferProofs.length);\n    s.transferProofInvolvements[to].push(s.transferProofs.length);\n    // Keep track of the transfer proof globally.\n    s.transferProofs.push(\n      LibFastHistory.TransferProof({\n        spender: spender,\n        from: from,\n        to: to,\n        amount: amount,\n        blockNumber: block.number,\n        ref: ref\n      })\n    );\n  }\n\n  function transferProofCount()\n      external view returns(uint256) {\n    return LibFastHistory.data().transferProofs.length;\n  }\n\n  function paginateTransferProofs(uint256 cursor, uint256 perPage)\n      external view returns(LibFastHistory.TransferProof[] memory, uint256) {\n    return LibPaginate.transferProofs(LibFastHistory.data().transferProofs, cursor, perPage);\n  }\n\n  function transferProofByInvolveeCount(address involvee)\n      external view returns(uint256) {\n    return LibFastHistory.data().transferProofInvolvements[involvee].length;\n  }\n\n  function paginateTransferProofIndicesByInvolvee(address involvee, uint256 cursor, uint256 perPage)\n      external view returns(uint256[] memory, uint256) {\n    return LibPaginate.uint256s(LibFastHistory.data().transferProofInvolvements[involvee], cursor, perPage);\n  }\n\n  function paginateTransferProofsByInvolvee(address involvee, uint256 cursor, uint256 perPage)\n      external view returns(LibFastHistory.TransferProof[] memory, uint256) {\n    LibFastHistory.Data storage s = LibFastHistory.data();\n    uint256[] storage collection  = s.transferProofInvolvements[involvee];\n    uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\n    LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\n    for (uint256 i = 0; i < length; i++) {\n      values[i] = s.transferProofs[collection[cursor + i]];\n    }\n    return (values, cursor + length);\n  }\n}\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/exchange/lib/LibExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../../lib/LibAddressSet.sol';\n\n\nlibrary LibExchange {\n  // The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  // This is keccak256('Exchange.storage'):\n  bytes32 internal constant STORAGE_SLOT = 0x58cca9481e011ced58c1d520ef5aad456e5805265d66de8df7c52f680c417394;\n\n  struct Data {\n    /// @dev The latest intializer version that was called.\n    uint16 version;\n    /// @dev The internal pointer to the SPC contract.\n    address spc;\n  }\n\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/exchange/lib/IExchangeEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\ninterface IExchangeEvents {\n  // IHasMembers.\n\n  event MemberAdded(address indexed member);\n  event MemberRemoved(address indexed member);\n\n  // IHasActiveMembers.\n  event MemberActivated(address indexed member);\n  event MemberDeactivated(address indexed member);\n}\n"
    },
    "contracts/spc/lib/LibSpcAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../../lib/LibAddressSet.sol';\n\n\nlibrary LibSpcAccess {\n  // The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  // This is keccak256('Spc.storage.Access'):\n  bytes32 internal constant STORAGE_SLOT = 0xe275f58a6a7f532ee3fa7fff24450c253df494fca407d91f5c35e83236f64d7c;\n\n  struct Data {\n    /// @dev The latest intializer version that was called.\n    uint16 version;\n    // This is where we hold our members data.\n    LibAddressSet.Data memberSet;\n  }\n\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/spc/lib/ISpcEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\n// WARNING: These events must be maintained 1:1 with LibSpcEvents!\n// They also should never be emitted directly, they only help us defining\n// typescript types!\ninterface ISpcEvents {\n  // ETH provisioning events.\n\n  /** @dev Emited when someone provisions this SPC with Eth.\n   *  @param from The sender of the Eth.\n   *  @param amount The quantity of Eth, expressed in Wei.\n   */\n  event EthReceived(address indexed from, uint256 amount);\n  /** @dev Emited when Eth is drained from this SPC.\n   *  @param to The caller and recipient of the drained Eth.\n   *  @param amount The quantity of Eth that was drained, expressed in Wei.\n   */\n  event EthDrained(address indexed to, uint256 amount);\n\n  // Fast registration events.\n\n  /** @dev Emited when a new FAST is registered.\n   *  @param fast The address of the newly registered FAST diamond.\n   */\n  event FastRegistered(address indexed fast);\n\n  // IHasMembers.\n\n  event MemberAdded(address indexed member);\n  event MemberRemoved(address indexed member);\n}\n"
    },
    "contracts/spc/SpcAccessFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../lib/LibAddressSet.sol';\nimport '../lib/LibPaginate.sol';\nimport '../lib/LibHelpers.sol';\nimport '../interfaces/IHasMembers.sol';\nimport '../fast/FastTopFacet.sol';\nimport '../fast/FastTokenFacet.sol';\nimport './lib/ASpcFacet.sol';\nimport './lib/LibSpcAccess.sol';\n\n\ncontract SpcAccessFacet is ASpcFacet, IHasMembers {\n  using LibAddressSet for LibAddressSet.Data;\n  // Constants.\n\n  // This represents how much Eth we provision new SPC members with.\n  uint256 constant private MEMBER_ETH_PROVISION = 10 ether;\n  // This represents how much Eth new FASTs are provisioned with.\n  uint256 constant private FAST_ETH_PROVISION = 250 ether;\n\n  // Membership management.\n\n  /** @dev Queries whether a given address is a member of this SPC or not.\n   *  @param candidate The address to test.\n   *  @return A `boolean` flag.\n   */\n  function isMember(address candidate)\n      external override view returns(bool) {\n    return LibSpcAccess.data().memberSet.contains(candidate);\n  }\n\n  /** @dev Counts the numbers of members present in this SPC.\n   *  @return The number of members in this SPC.\n   */\n  function memberCount()\n      external override view returns(uint256) {\n    return LibSpcAccess.data().memberSet.values.length;\n  }\n\n  /** @dev Paginates the members of this SPC based on a starting cursor and a number of records per page.\n   *  @param cursor The index at which to start.\n   *  @param perPage How many records should be returned at most.\n   *  @return A `address[]` list of values at most `perPage` big.\n   *  @return A `uint256` index to the next page.\n   */\n  function paginateMembers(uint256 cursor, uint256 perPage)\n      external override view returns(address[] memory, uint256) {\n    return LibPaginate.addresses(LibSpcAccess.data().memberSet.values, cursor, perPage);\n  }\n\n  /** @dev Adds a member to this SPC member list.\n   *  @param member The address of the member to be added.\n   *  @notice Requires that the caller is a member of this SPC.\n   *  @notice Emits a `IHasMembers.MemberAdded` event.\n   */\n  function addMember(address payable member)\n      external override\n      onlyMember(msg.sender) {\n    // Add the member to our list.\n    LibSpcAccess.data().memberSet.add(member, false);\n\n    // Provision the member with some Eth.\n    uint256 amount = LibHelpers.upTo(member, MEMBER_ETH_PROVISION);\n    if (amount != 0 && !LibHelpers.isContract(member)) {\n      member.transfer(amount);\n    }\n\n    // Emit!\n    emit MemberAdded(member);\n  }\n\n  /** @dev Removes a member from this SPC.\n   *  @param member The address of the member to be removed.\n   *  @notice Requires that the caller is a member of this SPC.\n   *  @notice Emits a `IHasMembers.MemberRemoved` event.\n   */\n  function removeMember(address member)\n      external override\n      onlyMember(msg.sender) {\n    // No suicide allowed.\n    require(msg.sender != member, 'Cannot remove self');\n    // Remove the member from the set.\n    LibSpcAccess.data().memberSet.remove(member, false);\n    // Emit!\n    emit MemberRemoved(member);\n  }\n}\n"
    },
    "contracts/fast/FastInitFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../interfaces/IERC20.sol';        // Token.\nimport '../interfaces/IERC165.sol';       // Interface Support.\nimport '../interfaces/IERC173.sol';       // Ownership.\nimport '../interfaces/IERC1404.sol';      // Transfer Restriction.\nimport '../interfaces/IDiamondCut.sol';   // Facet management.\nimport '../interfaces/IDiamondLoupe.sol'; // Facet introspection.\nimport '../interfaces/IHasGovernors.sol'; // Governorship management.\nimport '../interfaces/IHasMembers.sol';   // Membership management.\nimport '../lib/LibDiamond.sol';\nimport '../lib/LibAddressSet.sol';\nimport '../exchange/ExchangeTopFacet.sol';\nimport './lib/AFastFacet.sol';\n\n\n/**\n* @dev Note that although this contract doesn't explicitelly inherit from IERC173, ERC165, IDiamondLoupe etc, all\n*       methods are in fact implemented by the underlaying Diamond proxy. It is therefore safe to\n*       perform casts directly on the current contract address into these interfaces.\n*/ \ncontract FastInitFacet is AFastFacet {\n  using LibAddressSet for LibAddressSet.Data;\n\n  // Initializers.\n\n  struct InitializerParams {\n    // Top-level stuff.\n    address spc;\n    address exchange;\n    // Access stuff.\n    address payable governor;\n    // Token stuff.\n    string name;\n    string symbol;\n    uint256 decimals;\n    bool hasFixedSupply;\n    bool isSemiPublic;\n  }\n\n  function initialize(InitializerParams calldata params)\n      external\n      onlyDeployer {\n    // Make sure we haven't initialized yet.\n    require(LibFast.data().version < LibFast.STORAGE_VERSION, 'Already initialized');\n\n    // Register interfaces.\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    ds.supportedInterfaces[type(IERC20).interfaceId] = true;\n    ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n    ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n    ds.supportedInterfaces[type(IERC1404).interfaceId] = true;\n    ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n    ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n    ds.supportedInterfaces[type(IHasGovernors).interfaceId] = true;\n    ds.supportedInterfaces[type(IHasMembers).interfaceId] = true;\n\n    // ------------------------------------- //\n\n    // Initialize top-level storage.\n    LibFast.Data storage topData = LibFast.data();\n    topData.version = LibFast.STORAGE_VERSION;\n    topData.spc = params.spc;\n    topData.exchange = params.exchange;\n    topData.hasFixedSupply = params.hasFixedSupply;\n    topData.isSemiPublic = params.isSemiPublic;\n\n    // ------------------------------------- //\n\n    // Initialize access storage.\n    LibFastAccess.Data storage accessData = LibFastAccess.data();\n    accessData.version = LibFastAccess.STORAGE_VERSION;\n    // Add the governor and emit.\n    accessData.governorSet.add(params.governor, false);\n    emit GovernorAdded(params.governor);\n\n    // ------------------------------------- //\n\n    // Initialize token storage.\n    LibFastToken.Data storage tokenData = LibFastToken.data();\n    tokenData.version = LibFastToken.STORAGE_VERSION;\n    // Set up ERC20 related stuff.\n    (tokenData.name, tokenData.symbol, tokenData.decimals) =\n      (params.name,   params.symbol,   params.decimals);\n    tokenData.totalSupply = 0;\n    // Initialize other internal stuff.\n    tokenData.transferCredits = 0;\n  }\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/exchange/ExchangeTopFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport '../lib/LibAddressSet.sol';\nimport '../lib/LibPaginate.sol';\nimport '../spc/SpcTopFacet.sol';\nimport './lib/LibExchange.sol';\nimport '../interfaces/IHasMembers.sol';\nimport './lib/AExchangeFacet.sol';\n\n\n/** @title The Exchange Smart Contract.\n *  @dev The Exchange Top facet is in charge of keeping track of common parameters and provides\n *        generic functionality.\n */\ncontract ExchangeTopFacet is AExchangeFacet {\n  // Getters.\n\n  function spcAddress()\n    external view returns(address) {\n      return LibExchange.data().spc;\n  }\n}\n"
    }
  },
  "settings": {
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}