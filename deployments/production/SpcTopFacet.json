{
  "address": "0xeb4B8cBd66BAe11c0C74135E12A0709101455d44",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "EthDrained",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "EthReceived",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "fast",
          "type": "address"
        }
      ],
      "name": "FastRegistered",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "drainEth",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "symbol",
          "type": "string"
        }
      ],
      "name": "fastBySymbol",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fastCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "fast",
          "type": "address"
        }
      ],
      "name": "isFastRegistered",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "cursor",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "perPage",
          "type": "uint256"
        }
      ],
      "name": "paginateFasts",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "provisionWithEth",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "fast",
          "type": "address"
        }
      ],
      "name": "registerFast",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x7dfae5f107a1cd1392a1a05c37958bb93e788c9effa36e55e2842e67f06d8dda",
  "receipt": {
    "to": "0x6DF2D25d8C6FD680730ee658b530A05a99BB769a",
    "from": "0x717634cfe06FFAB2CEAA7fcf1b9019813f4B25FE",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "1377573",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x68103902bd2b14a73aa54e57ded6b7f5b5b8c1381702c2ccaaa637a34e2cf08e",
    "transactionHash": "0x7dfae5f107a1cd1392a1a05c37958bb93e788c9effa36e55e2842e67f06d8dda",
    "logs": [],
    "blockNumber": 5993685,
    "cumulativeGasUsed": "1377573",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "c4586ac12f594900f43c4b002a96518d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthDrained\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fast\",\"type\":\"address\"}],\"name\":\"FastRegistered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"drainEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"fastBySymbol\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fastCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fast\",\"type\":\"address\"}],\"name\":\"isFastRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perPage\",\"type\":\"uint256\"}],\"name\":\"paginateFasts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"provisionWithEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fast\",\"type\":\"address\"}],\"name\":\"registerFast\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"The SPC contract is the central place for top-level governorship. It requires that a        first member address is passed at construction time.\",\"events\":{\"EthDrained(address,uint256)\":{\"details\":\"Emited when Eth is drained from this SPC.\",\"params\":{\"amount\":\"The quantity of Eth that was drained, expressed in Wei.\",\"to\":\"The caller and recipient of the drained Eth.\"}},\"EthReceived(address,uint256)\":{\"details\":\"Emited when someone provisions this SPC with Eth.\",\"params\":{\"amount\":\"The quantity of Eth, expressed in Wei.\",\"from\":\"The sender of the Eth.\"}},\"FastRegistered(address)\":{\"details\":\"Emited when a new FAST is registered.\",\"params\":{\"fast\":\"The address of the newly registered FAST diamond.\"}}},\"kind\":\"dev\",\"methods\":{\"drainEth()\":{\"details\":\"A function that alllows draining this SPC from its Eth.\"},\"fastBySymbol(string)\":{\"details\":\"Allows to retrieve the address of a FAST diamond given its symbol.\",\"params\":{\"symbol\":\"The symbol of the FAST diamond to get the address of.\"},\"returns\":{\"_0\":\"The address of the corresponding FAST diamond, or the Zero Address if not found.\"}},\"fastCount()\":{\"details\":\"Counts the number of FAST diamonds registered with this SPC.\",\"returns\":{\"_0\":\"The number of FAST diamonds registered with this SPC.\"}},\"isFastRegistered(address)\":{\"details\":\"Queries whether a given address is a known and registered FAST contract.\",\"params\":{\"fast\":\"The address of the contract to check.\"},\"returns\":{\"_0\":\"A boolean.\"}},\"paginateFasts(uint256,uint256)\":{\"details\":\"Paginates the FAST diamonds registered with this SPC based on a starting cursor and a number of records per page.\",\"params\":{\"cursor\":\"The index at which to start.\",\"perPage\":\"How many records should be returned at most.\"},\"returns\":{\"_0\":\"A `address[]` list of values at most `perPage` big.\",\"_1\":\"A `uint256` index to the next page.\"}},\"provisionWithEth()\":{\"details\":\"A function that alllows provisioning this SPC with Eth.\"},\"registerFast(address)\":{\"details\":\"Allows the registration of a given FAST diamond with this SPC.\",\"params\":{\"fast\":\"The address of the FAST diamond to be registered.\"}}},\"title\":\"The SPC Smart Contract.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"drainEth()\":{\"notice\":\"Requires that the caller is a member of this SPC.Emits a `EthDrained` event.\"},\"provisionWithEth()\":{\"notice\":\"Emits a `EthReceived` event.\"},\"registerFast(address)\":{\"notice\":\"Requires that the caller is a member of this SPC.Emits a `FastRegistered` event.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/spc/SpcTopFacet.sol\":\"SpcTopFacet\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/exchange/ExchangeAccessFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../spc/SpcTopFacet.sol';\\nimport '../interfaces/IHasMembers.sol';\\nimport './lib/LibExchangeAccess.sol';\\nimport './lib/AExchangeFacet.sol';\\n\\n\\n/** @title The Exchange Smart Contract.\\n *  @dev The Exchange Access facet is in charge of keeping track of exchange members.\\n */\\ncontract ExchangeAccessFacet is AExchangeFacet, IHasMembers {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Membership management.\\n\\n  /** @dev Queries whether a given address is a member of this Exchange or not.\\n   *  @param candidate is the address to test.\\n   *  @return A `boolean` flag.\\n   */\\n  function isMember(address candidate)\\n      external override view returns(bool) {\\n    return LibExchangeAccess.data().memberSet.contains(candidate);\\n  }\\n\\n  /** @dev Counts the numbers of members present in this Exchange.\\n   *  @return The number of members in this exchange.\\n   */\\n  function memberCount()\\n      external override view returns(uint256) {\\n    return LibExchangeAccess.data().memberSet.values.length;\\n  }\\n\\n  /** @dev Paginates the members of this Exchange based on a starting cursor and a number of records per page.\\n   *  @param cursor is the index at which to start.\\n   *  @param perPage is how many records should be returned at most.\\n   *  @return A `address[]` list of values at most `perPage` big.\\n   *  @return A `uint256` index to the next page.\\n   */\\n  function paginateMembers(uint256 cursor, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibExchangeAccess.data().memberSet.values, cursor, perPage);\\n  }\\n\\n  /** @dev Adds a member to this Exchange member list.\\n   *  @param member is the address of the member to be added.\\n   *  @notice Requires that the caller is a member of the linked SPC.\\n   *  @notice Emits a `IHasMembers.MemberAdded` event.\\n   */\\n  function addMember(address payable member)\\n      external override\\n      spcMembership {\\n    // Add the member to our list.\\n    LibExchangeAccess.data().memberSet.add(member, false);\\n    // Emit!\\n    emit IHasMembers.MemberAdded(member);\\n  }\\n\\n  /** @dev Removes a member from this Exchange.\\n   *  @param member is the address of the member to be removed.\\n   *  @notice Requires that the caller is a member of the linked SPC.\\n   *  @notice Emits a `IHasMembers.MemberRemoved` event.\\n   */\\n  function removeMember(address member)\\n      external override\\n      spcMembership {\\n    LibExchangeAccess.Data storage s = LibExchangeAccess.data();\\n    // Ensure that member doesn't have any FAST membership.\\n    require(s.fastMemberships[member].values.length == 0, LibConstants.REQUIRES_NO_FAST_MEMBERSHIPS);\\n    // Remove member.\\n    s.memberSet.remove(member, false);\\n    // Emit!\\n    emit IHasMembers.MemberRemoved(member);\\n  }\\n\\n  /** @dev Allows to query FAST memberships for a given member address.\\n   *  @param member Is the address to check.\\n   *  @param cursor The index at which to start.\\n   *  @param perPage How many records should be returned at most.\\n   */\\n  function fastMemberships(address member, uint256 cursor, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibExchangeAccess.data().fastMemberships[member].values, cursor, perPage);\\n  }\\n\\n  /** @dev Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.\\n   *  @param member The member for which a new FAST membership has been added.\\n   */\\n  function memberAddedToFast(address member) \\n      external {\\n    // Verify that the given address is in fact a registered FAST contract.\\n    require(SpcTopFacet(LibExchange.data().spc).isFastRegistered(msg.sender), LibConstants.REQUIRES_FAST_CONTRACT_CALLER);\\n    // Keep track of the member's FAST membership.\\n    LibAddressSet.Data storage memberFasts = LibExchangeAccess.data().fastMemberships[member];\\n    memberFasts.add(msg.sender, false);\\n  }\\n\\n  /** @dev Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.\\n   *  @param member The member for which a FAST membership has been removed.\\n   */\\n  function memberRemovedFromFast(address member)\\n      external {\\n    require(SpcTopFacet(LibExchange.data().spc).isFastRegistered(msg.sender), LibConstants.REQUIRES_FAST_CONTRACT_CALLER);\\n    // Remove the tracked membership.\\n    LibAddressSet.Data storage memberFasts = LibExchangeAccess.data().fastMemberships[member];\\n    memberFasts.remove(msg.sender, false);\\n  }\\n}\\n\",\"keccak256\":\"0x0188718ea6904debf4513656c2cc7474c316eef84e625a3090a8859a0344f21e\",\"license\":\"MIT\"},\"contracts/exchange/lib/AExchangeFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../lib/LibExchange.sol';\\nimport '../lib/LibExchangeAccess.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../../interfaces/IHasMembers.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any Exchange facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract AExchangeFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\\n  modifier deployerContract() {\\n    require(msg.sender == LibConstants.DEPLOYER_CONTRACT, LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /** @dev Requires that the message sender is a member of the linked SPC.\\n   */\\n  modifier spcMembership() {\\n    require(IHasMembers(LibExchange.data().spc).isMember(msg.sender), LibConstants.REQUIRES_SPC_MEMBERSHIP);\\n    _;\\n  }\\n\\n  /** @dev Requires that the given address is a member of the exchange.\\n   *  @param candidate is the address to be checked.\\n   */\\n  modifier membership(address candidate) {\\n    require(LibExchangeAccess.data().memberSet.contains(candidate), LibConstants.REQUIRES_FAST_MEMBERSHIP);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x0cf3d4ffb7c5b85e336c1588cca845c7b03c6a3a72a421582d4dd26a0f1fe253\",\"license\":\"MIT\"},\"contracts/exchange/lib/LibExchange.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibExchange {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Exchange.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x58cca9481e011ced58c1d520ef5aad456e5805265d66de8df7c52f680c417394;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev The internal pointer to the SPC contract.\\n    address spc;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x3a8c32be0f6d238ec402d9afada3bbe00c69875e98fb9968b0f206be0ff23062\",\"license\":\"MIT\"},\"contracts/exchange/lib/LibExchangeAccess.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibExchangeAccess {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Exchange.storage.Access'):\\n  bytes32 internal constant STORAGE_SLOT = 0x238f5ead2481aef1ec60acdfe5b3de34c076d0a86bb41e30c913f5f3885d7c47;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev This is where we hold our members data.\\n    LibAddressSet.Data memberSet;\\n    /// @dev This is where we keep track of our member FAST memberships.\\n    mapping(address => LibAddressSet.Data) fastMemberships;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xe149dab743298b8c5c48f6c9d70e40f1d52588d073f800993f7d0e3ba20b9437\",\"license\":\"MIT\"},\"contracts/fast/FastAccessFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../interfaces/IHasMembers.sol';\\nimport '../interfaces/IHasGovernors.sol';\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../exchange/ExchangeAccessFacet.sol';\\nimport './FastTokenFacet.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFast.sol';\\nimport './lib/LibFastAccess.sol';\\nimport './FastTopFacet.sol';\\nimport './FastFrontendFacet.sol';\\n\\n\\n/**\\n* @dev The FAST Access Smart Contract is the source of truth when it comes to\\n* permissioning and ACLs within a given FAST network.\\n*/\\ncontract FastAccessFacet is AFastFacet, IHasMembers, IHasGovernors {\\n  using LibAddressSet for LibAddressSet.Data;\\n  // Structs.\\n\\n  /**\\n   * @dev This structure isn't used anywhere in storage. Instead, it\\n   * allows various methods of the contract to return all the flags\\n   * associated with a given address in one go.\\n   */\\n  struct Flags {\\n    bool isGovernor;\\n    bool isMember;\\n  }\\n\\n  // Constants.\\n\\n  // This represents how much Eth we provision new governors with.\\n  uint256 constant private GOVERNOR_ETH_PROVISION = 10 ether;\\n  // This represents how much Eth we provision new members with.\\n  uint256 constant private MEMBER_ETH_PROVISION = 1 ether;\\n\\n  // Initializers.\\n\\n  function initialize(address payable governor)\\n      external\\n      diamondInternal {\\n    // Grab our storage.\\n    LibFastAccess.Data storage s = LibFastAccess.data();\\n    // Make sure we havn't initialized yet.\\n    require(s.version < LibFastAccess.STORAGE_VERSION, 'Already initialized');\\n    // Initialize access storage.\\n    s.version = LibFastAccess.STORAGE_VERSION;\\n\\n    // Add the governor.\\n    s.governorSet.add(governor, false);\\n    // Emit!\\n    emit GovernorAdded(governor);\\n  }\\n\\n  // Governorship related stuff.\\n\\n  /**\\n   * @dev Queries whether a given address is a governor or not.\\n   */\\n  function isGovernor(address candidate)\\n      external view override returns(bool) {\\n    return LibFastAccess.data().governorSet.contains(candidate);\\n  }\\n\\n  /**\\n   * @dev Queries the number of governors in the governorship list.\\n   */\\n  function governorCount()\\n      external override view returns(uint256) {\\n    return LibFastAccess.data().governorSet.values.length;\\n  }\\n\\n  /**\\n   * @dev Returns a page of governors.\\n   */\\n  function paginateGovernors(uint256 index, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibFastAccess.\\n      data().governorSet.values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  /**\\n   * @dev Adds a governor to the governorship list.\\n   */\\n  function addGovernor(address payable governor)\\n      external override\\n      spcMembership {\\n    // Add governor to list.\\n    LibFastAccess.data().governorSet.add(governor, false);\\n    // If the address is a regular wallet...\\n    if (!LibHelpers.isContract(governor)) {\\n      // Provision the new governor with Eth if possible.\\n      FastTopFacet(payable(address(this))).payUpTo(governor, GOVERNOR_ETH_PROVISION);\\n    }\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit IHasGovernors.GovernorAdded(governor);\\n  }\\n\\n  /**\\n   * @dev Removes a governor from the governorship list.\\n   */\\n  function removeGovernor(address governor)\\n      external override\\n      spcMembership {\\n    // Remove governor.\\n    LibFastAccess.data().governorSet.remove(governor, false);\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit IHasGovernors.GovernorRemoved(governor);\\n  }\\n\\n  /// Membership related stuff.\\n\\n  /**\\n   * @dev Queries whether a given address is a member or not.\\n   */\\n  function isMember(address candidate)\\n      external override view returns(bool) {\\n    return LibFastAccess.data().memberSet.contains(candidate);\\n  }\\n\\n  /**\\n   * @dev Queries the number of members in the membership list.\\n   */\\n  function memberCount()\\n      external override view returns(uint256) {\\n    return LibFastAccess.data().memberSet.values.length;\\n  }\\n\\n  /**\\n   * @dev Returns a page of members.\\n   */\\n  function paginateMembers(uint256 index, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastAccess.data().memberSet.values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  /**\\n   * @dev Adds a member to the membership list.\\n   */\\n  function addMember(address payable member)\\n      external override \\n      governance(msg.sender) exchangeMember(member) {\\n    // Add the member.\\n    LibFastAccess.data().memberSet.add(member, false);\\n    // If the address is a regular wallet...\\n    if (!LibHelpers.isContract(member)) {\\n      // Provision the new member with Eth if possible.\\n      FastTopFacet(payable(address(this))).payUpTo(member, MEMBER_ETH_PROVISION);\\n    }\\n    // Notify exchange that this member was added to this FAST.\\n    ExchangeAccessFacet(LibFast.data().exchange).memberAddedToFast(member);\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit IHasMembers.MemberAdded(member);\\n  }\\n\\n  /**\\n   * @dev Removes a member from the membership list.\\n   */\\n  function removeMember(address member)\\n      external override \\n      governance(msg.sender) {\\n    // Remove member.\\n    LibFastAccess.data().memberSet.remove(member, false);\\n    // Notify exchange that this member was removed from this FAST.\\n    ExchangeAccessFacet(LibFast.data().exchange).memberRemovedFromFast(member);\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit IHasMembers.MemberRemoved(member);\\n  }\\n\\n  /// Flags.\\n\\n  /**\\n   * @dev Retrieves flags for a given address.\\n   */\\n  function flags(address a)\\n      external view returns(Flags memory) {\\n    LibFastAccess.Data storage s = LibFastAccess.data();\\n    return\\n      Flags({\\n        isGovernor: s.governorSet.contains(a),\\n        isMember: s.memberSet.contains(a)\\n      });\\n  }\\n}\\n\",\"keccak256\":\"0x4cc8e1a98399f6514da8acf277677313f7f75ef2b21b77eae4238d2a39244d23\",\"license\":\"MIT\"},\"contracts/fast/FastFrontendFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFastAccess.sol';\\nimport './lib/LibFastToken.sol';\\n\\n\\n/** @title The SPC Smart Contract.\\n *  @dev The SPC contract is the central place for top-level governorship. It requires that a\\n *        first member address is passed at construction time.\\n */\\ncontract FastFrontendFacet is AFastFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Events.\\n\\n  // This is an event that is fired whenever any of some of the FAST parameters\\n  // change, so that the frontend can react to it and refresh the general header\\n  // for that fast as well as the baseball cards in the FASTs list.\\n  event DetailsChanged(\\n    uint256 memberCount,\\n    uint256 governorCount,\\n    uint256 totalSupply,\\n    uint256 transferCredits,\\n    uint256 reserveBalance,\\n    uint256 ethBalance\\n  );\\n\\n  // Data structures.\\n\\n  struct Details {\\n    address addr;\\n    string name;\\n    string symbol;\\n    uint256 decimals;\\n    uint256 totalSupply;\\n    uint256 transferCredits;\\n    bool isSemiPublic;\\n    bool hasFixedSupply;\\n    uint256 reserveBalance;\\n    uint256 memberCount;\\n    uint256 governorCount;\\n  }\\n\\n  struct MemberDetails {\\n    address addr;\\n    uint256 balance;\\n    uint256 ethBalance;\\n    bool isGovernor;\\n  }\\n\\n  // Emitters.\\n\\n  function emitDetailsChanged()\\n      external diamondInternal {\\n    LibFastAccess.Data storage accessData = LibFastAccess.data();\\n    LibFastToken.Data storage tokenData = LibFastToken.data();\\n    emit DetailsChanged({\\n      memberCount: accessData.memberSet.values.length,\\n      governorCount: accessData.governorSet.values.length,\\n      totalSupply: tokenData.totalSupply,\\n      transferCredits: tokenData.transferCredits,\\n      reserveBalance: tokenData.balances[LibConstants.ZERO_ADDRESS],\\n      ethBalance: payable(address(this)).balance\\n    });\\n  }\\n\\n  // Public functions.\\n\\n  function details()\\n      public view returns(Details memory) {\\n    LibFast.Data storage topStorage = LibFast.data();\\n    LibFastAccess.Data storage accessStorage = LibFastAccess.data();\\n    LibFastToken.Data storage tokenStorage = LibFastToken.data();\\n    return Details({\\n      addr: address(this),\\n      name: tokenStorage.name,\\n      symbol: tokenStorage.symbol,\\n      decimals: tokenStorage.decimals,\\n      totalSupply: tokenStorage.totalSupply,\\n      transferCredits: tokenStorage.transferCredits,\\n      isSemiPublic: topStorage.isSemiPublic,\\n      hasFixedSupply: topStorage.hasFixedSupply,\\n      reserveBalance: tokenStorage.balances[LibConstants.ZERO_ADDRESS],\\n      memberCount: accessStorage.memberSet.values.length,\\n      governorCount: accessStorage.governorSet.values.length\\n    });\\n  }\\n\\n  function detailedMember(address member)\\n      public view returns(MemberDetails memory) {\\n    LibFastToken.Data storage tokenStorage = LibFastToken.data();\\n    LibFastAccess.Data storage accessStorage = LibFastAccess.data();\\n    return MemberDetails({\\n      addr: member,\\n      balance: tokenStorage.balances[member],\\n      ethBalance: member.balance,\\n      isGovernor: accessStorage.governorSet.contains(member)\\n    });\\n  }\\n\\n  function paginateDetailedMembers(uint256 index, uint256 perPage)\\n      external view returns(MemberDetails[] memory, uint256) {\\n    LibFastAccess.Data storage accessStorage = LibFastAccess.data();\\n    (address[] memory members, uint256 nextCursor) =\\n      LibPaginate.addresses(accessStorage.memberSet.values, index, perPage);\\n    MemberDetails[] memory values = new MemberDetails[](members.length);\\n    for (uint256 i = 0; i < members.length; ++i) {\\n      values[i] = detailedMember(members[i]);\\n    }\\n    return (values, nextCursor);\\n  }\\n}\\n\",\"keccak256\":\"0x9bc27617d7c845b32b184f65d2c38ba5a12955e6387152732de8834326a0da4c\",\"license\":\"MIT\"},\"contracts/fast/FastHistoryFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibPaginate.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFastHistory.sol';\\n\\n\\ncontract FastHistoryFacet is AFastFacet {\\n  /// Minting history-keeping methods.\\n\\n  function minted(uint256 amount, string calldata ref)\\n      external diamondInternal() {\\n    // Keep track of the mint.\\n    LibFastHistory.data().supplyProofs.push(\\n      LibFastHistory.SupplyProof({\\n        op: LibFastHistory.SupplyOp.Mint,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function burnt(uint256 amount, string calldata ref)\\n      external diamondInternal() {\\n    // Keep track of the unmint.\\n    LibFastHistory.data().supplyProofs.push(\\n      LibFastHistory.SupplyProof({\\n        op: LibFastHistory.SupplyOp.Burn,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function supplyProofCount()\\n      external view returns(uint256) {\\n    return LibFastHistory.data().supplyProofs.length;\\n  }\\n\\n  function paginateSupplyProofs(uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.SupplyProof[] memory, uint256) {\\n    return LibPaginate.supplyProofs(LibFastHistory.data().supplyProofs, cursor, perPage);\\n  }\\n\\n  /// Transfer history-keeping methods.\\n\\n  function transfered(address spender, address from, address to, uint256 amount, string calldata ref)\\n      external diamondInternal() {\\n    LibFastHistory.Data storage s = LibFastHistory.data();\\n    // Keep track of the transfer proof ID for the sender and for the recipient.\\n    s.transferProofInvolvements[from].push(s.transferProofs.length);\\n    s.transferProofInvolvements[to].push(s.transferProofs.length);\\n    // Keep track of the transfer proof globally.\\n    s.transferProofs.push(\\n      LibFastHistory.TransferProof({\\n        spender: spender,\\n        from: from,\\n        to: to,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function transferProofCount()\\n      external view returns(uint256) {\\n    return LibFastHistory.data().transferProofs.length;\\n  }\\n\\n  function paginateTransferProofs(uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n    return LibPaginate.transferProofs(LibFastHistory.data().transferProofs, cursor, perPage);\\n  }\\n\\n  function transferProofByInvolveeCount(address involvee)\\n      external view returns(uint256) {\\n    return LibFastHistory.data().transferProofInvolvements[involvee].length;\\n  }\\n\\n  function paginateTransferProofIndicesByInvolvee(address involvee, uint256 cursor, uint256 perPage)\\n      external view returns(uint256[] memory, uint256) {\\n    return LibPaginate.uint256s(LibFastHistory.data().transferProofInvolvements[involvee], cursor, perPage);\\n  }\\n\\n  function paginateTransferProofsByInvolvee(address involvee, uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n    LibFastHistory.Data storage s = LibFastHistory.data();\\n    uint256[] storage collection  = s.transferProofInvolvements[involvee];\\n    uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n    LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\\n    for (uint256 i = 0; i < length; i++) {\\n      values[i] = s.transferProofs[collection[cursor + i]];\\n    }\\n    return (values, cursor + length);\\n  }\\n}\\n\",\"keccak256\":\"0x5596e26868dce38659495b3acddbaec7045698d0ecc9039f1170c5a9f1e21cb1\",\"license\":\"MIT\"},\"contracts/fast/FastTokenFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../interfaces/IERC20.sol';\\nimport '../interfaces/IERC1404.sol';\\nimport '../lib/LibDiamond.sol';\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFastToken.sol';\\nimport './FastTopFacet.sol';\\nimport './FastAccessFacet.sol';\\nimport './FastHistoryFacet.sol';\\nimport './FastFrontendFacet.sol';\\n\\n\\ncontract FastTokenFacet is AFastFacet, IERC20, IERC1404 {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Events.\\n\\n  // Issuance related events.\\n  event Minted(uint256 indexed amount, string indexed ref);\\n  event Burnt(uint256 indexed amount, string indexed ref);\\n\\n  // Transfer credits related events.\\n  event TransferCreditsAdded(address indexed spcMember, uint256 amount);\\n  event TransferCreditsDrained(address indexed spcMember, uint256 amount);\\n\\n  /// Minting methods.\\n\\n  function mint(uint256 amount, string calldata ref)\\n      external\\n      spcMembership {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // We want to make sure that either of these two is true:\\n    // - The token doesn't have fixed supply.\\n    // - The token has fixed supply but has no tokens yet (First and only mint).\\n    require(\\n      !FastTopFacet(address(this)).hasFixedSupply() || (s.totalSupply == 0 && this.balanceOf(address(0)) == 0),\\n      LibConstants.REQUIRES_CONTINUOUS_SUPPLY\\n    );\\n\\n    // Prepare the minted amount on the zero address.\\n    s.balances[address(0)] += amount;\\n\\n    // Keep track of the minting operation.\\n    FastHistoryFacet(address(this)).minted(amount, ref);\\n\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit Minted(amount, ref);\\n  }\\n\\n  function burn(uint256 amount, string calldata ref)\\n      external\\n      spcMembership {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    require(!FastTopFacet(address(this)).hasFixedSupply(), LibConstants.REQUIRES_CONTINUOUS_SUPPLY);\\n    require(balanceOf(address(0)) >= amount, LibConstants.INSUFFICIENT_FUNDS);\\n\\n    // Remove the minted amount from the zero address.\\n    s.balances[address(0)] -= amount;\\n\\n    // Keep track of the minting operation.\\n    FastHistoryFacet(address(this)).burnt(amount, ref);\\n\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit Burnt(amount, ref);\\n  }\\n\\n  /// Tranfer Credit management.\\n\\n  function transferCredits()\\n      external view returns(uint256) {\\n    return LibFastToken.data().transferCredits;\\n  }\\n\\n  function addTransferCredits(uint256 amount)\\n      external\\n      spcMembership {\\n    LibFastToken.data().transferCredits += amount;\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit TransferCreditsAdded(msg.sender, amount);\\n  }\\n\\n  function drainTransferCredits()\\n      external\\n      spcMembership {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // Emit!\\n    emit TransferCreditsDrained(msg.sender, s.transferCredits);\\n    // Drain credits.\\n    s.transferCredits = 0;\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n  }\\n\\n  /// ERC20 implementation and transfer related methods.\\n\\n  function name()\\n      external view returns(string memory) {\\n    return LibFastToken.data().name;\\n  }\\n\\n  function symbol()\\n      external view returns(string memory) {\\n    return LibFastToken.data().symbol;\\n  }\\n\\n  function decimals()\\n      external view returns(uint256) {\\n    return LibFastToken.data().decimals;\\n  }\\n\\n  function totalSupply()\\n      external override view returns(uint256) {\\n    return LibFastToken.data().totalSupply;\\n  }\\n\\n  function balanceOf(address owner)\\n      public view override returns(uint256) {\\n    return LibFastToken.data().balances[owner];\\n  }\\n\\n  function transfer(address to, uint256 amount)\\n      external override returns(bool) {\\n    // Make sure the call is performed externally so that we can mock.\\n    this.performTransfer(\\n      TransferArgs({\\n        spender: msg.sender,\\n        from: msg.sender,\\n        to: to,\\n        amount: amount,\\n        ref: LibFastToken.DEFAULT_TRANSFER_REFERENCE\\n      })\\n    );\\n    return true;\\n  }\\n\\n  function transferWithRef(address to, uint256 amount, string calldata ref)\\n      external {\\n    // Make sure the call is performed externally so that we can mock.\\n    this.performTransfer(\\n      TransferArgs({\\n        spender: msg.sender,\\n        from: msg.sender,\\n        to: to,\\n        amount: amount,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function allowance(address owner, address spender)\\n      public view override returns(uint256) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // If the allowance being queried is from the zero address and the spender\\n    // is a governor, we want to make sure that the spender has full rights over it.\\n    if (owner == address(0)) {\\n      require(FastAccessFacet(address(this)).isGovernor(spender), LibConstants.REQUIRES_FAST_GOVERNORSHIP);\\n      return s.balances[owner];\\n    }\\n    return s.allowances[owner][spender];\\n  }\\n\\n  function approve(address spender, uint256 amount)\\n      external override returns(bool) {\\n    // Make sure the call is performed externally so that we can mock.\\n    this.performApproval(msg.sender, spender, amount);\\n    return true;\\n  }\\n\\n  function disapprove(address spender)\\n      external\\n      membership(msg.sender) {\\n    // Make sure the call is performed externally so that we can mock.\\n    this.performDisapproval(msg.sender, spender);\\n  }\\n\\n  function transferFrom(address from, address to, uint256 amount)\\n      external override returns(bool) {\\n    transferFromWithRef(from, to, amount, LibFastToken.DEFAULT_TRANSFER_REFERENCE);\\n    return true;\\n  }\\n\\n  function transferFromWithRef(address from, address to, uint256 amount, string memory ref)\\n      public {\\n    // Make sure the call is performed externally so that we can mock.\\n    this.performTransfer(\\n      TransferArgs({\\n        spender: msg.sender,\\n        from: from,\\n        to: to,\\n        amount: amount,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  /// Allowances query operations.\\n\\n  function givenAllowanceCount(address owner)\\n      external view returns(uint256) {\\n    return LibFastToken.data().allowancesByOwner[owner].values.length;\\n  }\\n\\n  function paginateAllowancesByOwner(address owner, uint256 index, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastToken.data().allowancesByOwner[owner].values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  function receivedAllowanceCount(address spender)\\n      external view returns(uint256) {\\n    return LibFastToken.data().allowancesBySpender[spender].values.length;\\n  }\\n\\n  function paginateAllowancesBySpender(address spender, uint256 index, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastToken.data().allowancesBySpender[spender].values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  /// ERC1404 implementation.\\n\\n  function detectTransferRestriction(address from, address to, uint256 amount)\\n      external view override returns(uint8) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    if (s.transferCredits < amount) {\\n      return LibFastToken.INSUFFICIENT_TRANSFER_CREDITS_CODE;\\n    } else if (!FastAccessFacet(address(this)).isMember(from) ||\\n               !FastAccessFacet(address(this)).isMember(to)) {\\n      return FastTopFacet(address(this)).isSemiPublic()\\n        ? LibFastToken.REQUIRES_EXCHANGE_MEMBERSHIP_CODE\\n        : LibFastToken.REQUIRES_FAST_MEMBERSHIP_CODE;\\n    } else if (from == to) {\\n      return LibFastToken.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE;\\n    }\\n    return 0;\\n  }\\n\\n  function messageForTransferRestriction(uint8 restrictionCode)\\n      external override pure returns(string memory) {\\n    if (restrictionCode == LibFastToken.INSUFFICIENT_TRANSFER_CREDITS_CODE) {\\n      return LibConstants.INSUFFICIENT_TRANSFER_CREDITS;\\n    } else if (restrictionCode == LibFastToken.REQUIRES_EXCHANGE_MEMBERSHIP_CODE) {\\n      return LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP;\\n    } else if (restrictionCode == LibFastToken.REQUIRES_FAST_MEMBERSHIP_CODE) {\\n      return LibConstants.REQUIRES_FAST_MEMBERSHIP;\\n    } else if (restrictionCode == LibFastToken.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE) {\\n      return LibConstants.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT;\\n    }\\n    revert(LibConstants.UNKNOWN_RESTRICTION_CODE);\\n  }\\n\\n  // These functions would be internal / private if we weren't using the diamond pattern.\\n  // Instead, they're `diamondInternal` - eg can only be called by facets of the current\\n  // FAST.\\n\\n  struct TransferArgs {\\n    address spender;\\n    address from;\\n    address to;\\n    uint256 amount;\\n    string ref;\\n  }\\n\\n  function performTransfer(TransferArgs calldata p)\\n      external diamondInternal\\n      canHoldTokens(p.from) canHoldTokens(p.to) differentAddresses(p.from, p.to) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Make sure that there's enough funds.\\n    require(\\n      s.balances[p.from] >= p.amount,\\n      LibConstants.INSUFFICIENT_FUNDS\\n    );\\n\\n    // If this is an allowance transfer...\\n    if (p.spender != p.from) {\\n      // Make sure that the spender has enough allowance.\\n      require(\\n        FastTokenFacet(address(this)).allowance(p.from, p.spender) >= p.amount,\\n        LibConstants.INSUFFICIENT_ALLOWANCE\\n      );\\n\\n      // If the from account isn't the zero address...\\n      if (p.from != address(0)) {\\n        // Make sure enough credits exist.\\n        require(\\n          s.transferCredits >= p.amount,\\n          LibConstants.INSUFFICIENT_TRANSFER_CREDITS\\n        );\\n\\n        // Decrease allowance.\\n        uint256 newAllowance = s.allowances[p.from][p.spender] -= p.amount;\\n        // If the allowance reached zero, we want to remove that allowance from\\n        // the various other places where we keep track of it.\\n        if (newAllowance == 0) {\\n          s.allowancesByOwner[p.from].remove(p.spender, true);\\n          s.allowancesBySpender[p.spender].remove(p.from, true);\\n        }\\n      }\\n    }\\n\\n    // Keep track of the balances - `from` spends, `to` receives.\\n    s.balances[p.from] -= p.amount;\\n    s.balances[p.to] += p.amount;\\n\\n    // If the funds are not moving from the zero address, decrease transfer credits.\\n    if (p.from != address(0)) {\\n      s.transferCredits -= p.amount;\\n    }\\n\\n    // If the funds are going to the ZERO address, decrease total supply.\\n    if (p.to == address(0)) {\\n      s.totalSupply -= p.amount;\\n      // If funds at address zero changed, we can emit a top-level details change event.\\n      FastFrontendFacet(address(this)).emitDetailsChanged();\\n    }\\n    // If the funds are moving from the zero address, increase total supply.\\n    else if (p.from == address(0)) {\\n      s.totalSupply += p.amount;\\n      // If funds at address zero changed, we can emit a top-level details change event.\\n      FastFrontendFacet(address(this)).emitDetailsChanged();\\n    }\\n\\n    // Keep track of the transfer in the history facet.\\n    FastHistoryFacet(address(this)).transfered(p.spender, p.from, p.to, p.amount, p.ref);\\n\\n    // Emit!\\n    emit IERC20.Transfer(p.from, p.to, p.amount);\\n  }\\n\\n  function performApproval(address from, address spender, uint256 amount)\\n      external\\n      diamondInternal\\n      canHoldTokens(from) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Store allowance...\\n    s.allowances[from][spender] += amount;\\n    // Keep track of given and received allowances.\\n    s.allowancesByOwner[from].add(spender, true);\\n    s.allowancesBySpender[spender].add(from, true);\\n\\n    // Emit!\\n    emit IERC20.Approval(from, spender, amount);\\n  }\\n\\n  function performDisapproval(address from, address spender)\\n      external\\n      diamondInternal {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Remove allowance.\\n    s.allowances[from][spender] = 0;\\n    s.allowancesByOwner[from].remove(spender, false);\\n    s.allowancesBySpender[spender].remove(from, false);\\n\\n    // Emit!\\n    emit IERC20.Disapproval(from, spender);\\n  }\\n\\n  // WARNING: This function contains two loops. We know that this should never\\n  // happen in solidity. However:\\n  // - In the context of our private chain, gas is cheap.\\n  // - It can only be called by a governor.\\n  function beforeRemovingMember(address member)\\n      external diamondInternal() {\\n    require(balanceOf(member) == 0, 'Balance is positive');\\n\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Remove all given allowances.\\n    address[] storage gaData = s.allowancesByOwner[member].values;\\n    while (gaData.length > 0) {\\n      // Make sure the call is performed externally so that we can mock.\\n      this.performDisapproval(member, gaData[0]);\\n    }\\n\\n    // Remove all received allowances.\\n    address[] storage raData = s.allowancesBySpender[member].values;\\n    while (raData.length > 0) {\\n      // Make sure the call is performed externally so that we can mock.\\n      this.performDisapproval(raData[0], member);\\n    }\\n  }\\n\\n  // Modifiers.\\n\\n  modifier differentAddresses(address a, address b) {\\n    require(a != b, LibConstants.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x0477d763d2d0dfa8474f0f1b1050c25245d5b4b5b91e698d3059e3d325b55861\",\"license\":\"MIT\"},\"contracts/fast/FastTopFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibConstants.sol';\\nimport '../lib/LibHelpers.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFast.sol';\\nimport './FastFrontendFacet.sol';\\n\\ncontract FastTopFacet is AFastFacet {\\n\\n  // Eth provisioning related events.\\n  event EthReceived(address indexed from, uint256 amount);\\n  event EthDrained(address indexed to, uint256 amount);\\n\\n  // Getters and setters for global flags.\\n\\n  function spcAddress()\\n      external view returns(address) {\\n    return LibFast.data().spc;\\n  }\\n\\n  function exchangeAddress()\\n      external view returns(address) {\\n    return LibFast.data().exchange;\\n  }\\n\\n    function isSemiPublic()\\n      external view returns(bool) {\\n    return LibFast.data().isSemiPublic;\\n  }\\n\\n  function hasFixedSupply()\\n      external view returns(bool) {\\n    return LibFast.data().hasFixedSupply;\\n  }\\n\\n  // Setters for global flags.\\n\\n  /// @dev Allows to switch from a private scheme to a semi-public scheme, but not the other way around.\\n  function setIsSemiPublic(bool flag)\\n      external\\n      spcMembership {\\n    LibFast.Data storage s = LibFast.data();\\n    // Someone is trying to toggle back to private?... No can do!isSemiPublic\\n    require(!this.isSemiPublic() || this.isSemiPublic() == flag, LibConstants.UNSUPPORTED_OPERATION);\\n    s.isSemiPublic = flag;\\n  }\\n\\n  // Provisioning functions.\\n\\n  function provisionWithEth()\\n      external payable {\\n    require(msg.value > 0, LibConstants.MISSING_ATTACHED_ETH);\\n    emit EthReceived(msg.sender, msg.value);\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n  }\\n\\n  function drainEth()\\n      external\\n      spcMembership {\\n    uint256 amount = payable(address(this)).balance;\\n    payable(msg.sender).transfer(amount);\\n    emit EthDrained(msg.sender, amount);\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n  }\\n\\n  /**\\n  * @dev This function allows contracts of the FAST network to request ETH\\n  * provisioning to arbitrary addresses.\\n  */\\n  function payUpTo(address payable recipient, uint256 amount)\\n      external diamondInternal() {\\n    require(recipient != address(0), LibConstants.REQUIRES_NON_ZERO_ADDRESS);\\n    amount = LibHelpers.upTo(recipient, amount);\\n    // Transfer some eth!\\n    if (amount != 0) { recipient.transfer(amount); }\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n  }\\n}\\n\",\"keccak256\":\"0xfa8f1639426402661561702703c4042c0bd97726318d95d4c895154519909e10\",\"license\":\"MIT\"},\"contracts/fast/lib/AFastFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibHelpers.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../../interfaces/IHasMembers.sol';\\nimport '../../interfaces/IHasGovernors.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport './IFast.sol';\\nimport '../lib/LibFast.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract AFastFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\\n  modifier diamondInternal() {\\n    require(msg.sender == address(this), LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\\n  modifier diamondOwner() {\\n    require(msg.sender == IERC173(address(this)).owner(), LibConstants.REQUIRES_DIAMOND_OWNERSHIP);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\\n  modifier deployerContract() {\\n    require(msg.sender == LibConstants.DEPLOYER_CONTRACT, LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is **not** a contract.\\n   *  @param candidate The address to check.\\n   */\\n  modifier nonContract(address candidate) {\\n    require(!LibHelpers.isContract(candidate), LibConstants.REQUIRES_NON_CONTRACT_ADDR);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the Exchange.\\n   *  @param candidate The address to check.\\n   */\\n  modifier exchangeMember(address candidate) {\\n    require(\\n      IHasMembers(LibFast.data().exchange).isMember(candidate),\\n      LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures that the message sender is a member of the SPC.\\n   */\\n  modifier spcMembership() {\\n    require(\\n      IHasMembers(LibFast.data().spc).isMember(msg.sender),\\n      LibConstants.REQUIRES_SPC_MEMBERSHIP\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a governor of the FAST.\\n   *  @param candidate The address to check.\\n   */\\n  modifier governance(address candidate) {\\n    require(\\n      IHasGovernors(address(this)).isGovernor(candidate),\\n      LibConstants.REQUIRES_FAST_GOVERNORSHIP\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the FAST.\\n   *  @param candidate The address to check.\\n   */\\n  modifier membership(address candidate) {\\n    require(\\n      IHasMembers(address(this)).isMember(candidate),\\n      LibConstants.REQUIRES_FAST_MEMBERSHIP\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the current FAST or the Zero Address.\\n   *  @param candidate The address to check.\\n   */\\n  modifier canHoldTokens(address candidate) {\\n    // Only perform checks if the address is non-zero.\\n    if (candidate != address(0)) {\\n    // FAST is semi-public - the only requirement to hold tokens is to be an exchange member.\\n      if (IFast(address(this)).isSemiPublic()) {\\n        require(\\n          IHasMembers(LibFast.data().exchange).isMember(candidate),\\n          LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP\\n        );\\n      }\\n      // FAST is private, the requirement to hold tokens is to be a member of that FAST.\\n      else {\\n        require(\\n          IHasMembers(address(this)).isMember(candidate),\\n          LibConstants.REQUIRES_FAST_MEMBERSHIP\\n        );\\n      }\\n    }\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x69d4577fc4c401d88e2113b747efec3fa70e571366aac7b2beb37fb79ca9c2ee\",\"license\":\"MIT\"},\"contracts/fast/lib/IFast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IFast {\\n  function isSemiPublic() external view returns(bool);\\n  function hasFixedSupply() external view returns(bool);\\n}\\n\",\"keccak256\":\"0xea7b5645ce61b4f3c399bb1696603c57833e1f0b2fcce935f6420f55d602ba64\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibFast {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705;\\n\\n  // Data structures.\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev The internal pointer to the SPC contract.\\n    address spc;\\n    /// @dev The internal pointer to the Exchange contract.\\n    address exchange;\\n    /// @dev We have to track whether the token facet provides continuous minting or fixed supply.\\n    bool hasFixedSupply;\\n    /// @dev Whether or not this FAST requires to be a member to hold tokens.\\n    bool isSemiPublic;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xc32df23d24f8ec8c918f1caeb8ca984bfe2ac1b7c370f24ad2a70a52e9d4e999\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastAccess.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\nlibrary LibFastAccess {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.Access'):\\n  bytes32 internal constant STORAGE_SLOT = 0x87ed8063ac9ead3b2eb7551ed3d89b29fcbf44d6733084b5c82e95d5120ece9a;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev We hold the list of the FAST governors in there.\\n    LibAddressSet.Data governorSet;\\n    // @dev The FAST members are held in there.\\n    LibAddressSet.Data memberSet;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x9744c77467b854899d5b5f9beaf4665f461adc8110432d174601a97f00e594ad\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastHistory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibFastHistory {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.History'):\\n  bytes32 internal constant STORAGE_SLOT = 0x6bc8b61a9dd5fc049ea98027492a801d74e35fdf4d80d7fecd551a16e88fdbb4;\\n\\n  // Storage structures.\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev All minting proofs are kept here.\\n    SupplyProof[] supplyProofs;\\n    /// @dev All transfer proofs are kept here.\\n    TransferProof[] transferProofs;\\n    /// @dev All transfers indices involving a given address are kept here.\\n    mapping(address => uint256[]) transferProofInvolvements;\\n  }\\n\\n  // Other structures.\\n\\n  /// @dev A minting operation could either be to mint or unmint tokens.\\n  enum SupplyOp { Mint, Burn }\\n\\n  /// @dev Minting operations are recorded for papertrail. This is the structure that keeps track of them.\\n  struct SupplyProof {\\n    SupplyOp op;\\n    uint256 amount;\\n    uint256 blockNumber;\\n    string ref;\\n  }\\n\\n  /// @dev Every transfer in is recorded. This is the structure that keeps track of them.\\n  struct TransferProof {\\n    address spender;\\n    address from;\\n    address to;\\n    uint256 amount;\\n    uint256 blockNumber;\\n    string ref;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xd6af0fc0867dd0259fa6e0797f2b46cffac8a36f0380bf266e3ccf778aeb724c\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibFastToken {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.Token'):\\n  bytes32 internal constant STORAGE_SLOT = 0xb098747b87c5c0e2a32eb9b06725e9bad4263809bcda628ceadc1a686bcb8261;\\n\\n  // Constants.\\n\\n  // ERC1404 Restriction codes.\\n  uint8 internal constant INSUFFICIENT_TRANSFER_CREDITS_CODE = 1;\\n  uint8 internal constant REQUIRES_FAST_MEMBERSHIP_CODE = 2;\\n  uint8 internal constant REQUIRES_EXCHANGE_MEMBERSHIP_CODE = 3;\\n  uint8 internal constant REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE = 4;\\n\\n  string internal constant DEFAULT_TRANSFER_REFERENCE = 'Unspecified - via ERC20';\\n\\n  // Data structures.\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    // ERC20 related properties for this FAST Token.\\n    string name;\\n    string symbol;\\n    uint256 decimals;\\n    uint256 totalSupply;\\n    // Every time a transfer is executed, the credit decreases by the amount\\n    // of said transfer.\\n    // It becomes impossible to transact once it reaches zero, and must\\n    // be provisioned by an SPC governor.\\n    uint256 transferCredits;\\n    // Our members balances are held here.\\n    mapping(address => uint256) balances;\\n    // Allowances are stored here.\\n    mapping(address => mapping(address => uint256)) allowances;\\n    mapping(address => LibAddressSet.Data) allowancesByOwner;\\n    mapping(address => LibAddressSet.Data) allowancesBySpender;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x7255ca8c82f392258f4178b5c80b66c83796e9f25460f9ca690f5c5e250e03db\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0x7aca95eacea757ff86be09ed6f309fde42e402530ac7beae002e3c2586439a01\",\"license\":\"MIT\"},\"contracts/interfaces/IERC1404.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\n/**\\n * @dev Interface of the ERC1404 standard as defined in the EIP.\\n */\\ninterface IERC1404 {\\n  /**\\n   * @dev Returns a transfer restriction error code if the transfer shoudln't be permitted,\\n   *      or otherwise returns zero if everything looks fine.\\n   * @param owner is the account from which the tokens should be transfered.\\n   * @param recipient is the target of the transfer.\\n   * @param amount is the amount to be transfered.\\n   * @return a uint8 error code if a problem was detected, otherwise zero.\\n   */\\n  function detectTransferRestriction(address owner, address recipient, uint256 amount)\\n    external\\n    view\\n    returns (uint8);\\n\\n  /**\\n   * @dev Maps a transfer restriction error code into a human-readable string.\\n   * @param code is the code that should be transformed into a string.\\n   * @return A string that describes the given error code.\\n   */\\n  function messageForTransferRestriction(uint8 code) external pure returns (string memory);\\n}\\n\",\"keccak256\":\"0x9ecaada095d66283dda203f77cdd17d18f82bdf58d6fbe7830fc87aed2a80c38\",\"license\":\"MIT\"},\"contracts/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\",\"keccak256\":\"0x6ab22e74708905d9c31867461fffbd2e24bc6ad094aa1aab39211d99e296ab32\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  // ERC20 and Token related events.\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n  event Disapproval(address indexed owner, address indexed spender);\\n}\\n\",\"keccak256\":\"0x3c17934228848f70938615b7fe18a3959b96712b8ada23a4d3bbf9bb1c1c2a6b\",\"license\":\"MIT\"},\"contracts/interfaces/IHasGovernors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IHasGovernors {\\n  event GovernorAdded(address indexed governor);\\n  event GovernorRemoved(address indexed governor);\\n\\n  function isGovernor(address a) external view returns(bool);\\n  function governorCount() external view returns(uint256);\\n  function paginateGovernors(uint256 index, uint256 perPage) external view returns(address[] memory, uint256);\\n  function addGovernor(address payable a) external;\\n  function removeGovernor(address a) external;\\n}\\n\",\"keccak256\":\"0x35836b162c19951d87848f098fab3f42b79a0b9f593640e8ad8f2f2fa5b74d25\",\"license\":\"MIT\"},\"contracts/interfaces/IHasMembers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IHasMembers {\\n  event MemberAdded(address indexed member);\\n  event MemberRemoved(address indexed member);\\n\\n  function isMember(address a) external view returns(bool);\\n  function memberCount() external view returns(uint256);\\n  function paginateMembers(uint256 index, uint256 perPage) external view returns(address[] memory, uint256);\\n  function addMember(address payable a) external;\\n  function removeMember(address a) external;\\n}\\n\",\"keccak256\":\"0xab0d7cfb46a5a70bd13783d959df2e8f593269472994ea828273fa563a4c0c39\",\"license\":\"MIT\"},\"contracts/lib/LibAddressSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibAddressSet {\\n  /// @dev Represents a list of addresses.\\n  struct Data {\\n    mapping(address => uint256) indices;\\n    address[] values;\\n  }\\n\\n  /**\\n   * @dev Adds an item into the storage set. If the address already exists in the\\n   *      set, the function reverts.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to be added.\\n   */\\n  function add(Data storage d, address key, bool noThrow)\\n      internal {\\n    bool exists = contains(d, key);\\n    if (noThrow && exists) { return; }\\n    require(!exists, 'Address already in set');\\n    d.indices[key] = d.values.length;\\n    d.values.push(key);\\n  }\\n\\n  /**\\n   * @dev Removes an item from the storage set. If the address does not exist in the\\n   *      set, the function reverts.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to be removed.\\n   */\\n  function remove(Data storage d, address key, bool noThrow)\\n      internal {\\n    bool exists = contains(d, key);\\n    if (noThrow && !exists) { return; }\\n    require(exists, 'Address does not exist in set');\\n    uint256 lastIndex = d.values.length - 1;\\n    address keyToMove = d.values[lastIndex];\\n    uint256 idxToReplace = d.indices[key];\\n    d.indices[keyToMove] = idxToReplace;\\n    d.values[idxToReplace] = keyToMove;\\n    delete d.indices[key];\\n    d.values.pop();\\n  }\\n\\n  /**\\n   * @dev Tests whether or not a given item already exists in the set.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to test.\\n   * @return a boolean.\\n   */\\n  function contains(Data storage d, address key)\\n      internal view returns(bool) {\\n    return d.values.length == 0\\n      ? false\\n      : d.values[d.indices[key]] == key;\\n  }\\n}\\n\",\"keccak256\":\"0x7daf050d0864e085c227521b1157b4ea652fe75ea7e10f685027b42d6e1caf87\",\"license\":\"MIT\"},\"contracts/lib/LibConstants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibConstants {\\n  address internal constant ZERO_ADDRESS = address(0);\\n  address internal constant DEPLOYER_CONTRACT = 0x6DF2D25d8C6FD680730ee658b530A05a99BB769a;\\n\\n  string internal constant ALREADY_INITIALIZED = 'Already initialized';\\n  string internal constant INTERNAL_METHOD = 'Internal method';\\n  string internal constant REQUIRES_DIAMOND_OWNERSHIP = 'Requires diamond ownership';\\n  string internal constant REQUIRES_FAST_CONTRACT_CALLER = 'Caller must be a FAST contract';\\n\\n  string internal constant REQUIRES_SPC_MEMBERSHIP = 'Requires SPC membership';\\n  string internal constant REQUIRES_EXCHANGE_MEMBERSHIP = 'Requires Exchange membership';\\n\\n  string internal constant REQUIRES_FAST_GOVERNORSHIP = 'Requires FAST governorship';\\n  string internal constant REQUIRES_FAST_MEMBERSHIP = 'Requires FAST membership';\\n  string internal constant REQUIRES_NO_FAST_MEMBERSHIPS = 'Member still part of at least one FAST';\\n\\n  string internal constant DUPLICATE_ENTRY = 'Duplicate entry';\\n  string internal constant UNSUPPORTED_OPERATION = 'Unsupported operation';\\n  string internal constant REQUIRES_NON_ZERO_ADDRESS = 'Requires non-zero address';\\n  string internal constant REQUIRES_NON_CONTRACT_ADDR = 'Address cannot be a contract';\\n\\n  string internal constant MISSING_ATTACHED_ETH = 'Missing attached ETH';\\n\\n  string internal constant REQUIRES_CONTINUOUS_SUPPLY = 'Requires continuous supply';\\n  string internal constant INSUFFICIENT_FUNDS = 'Insufficient token balance';\\n  string internal constant INSUFFICIENT_ALLOWANCE = 'Insufficient allowance';\\n  string internal constant INSUFFICIENT_TRANSFER_CREDITS = 'Insufficient transfer credits';\\n  string internal constant REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT = 'Requires different sender and recipient';\\n  string internal constant UNKNOWN_RESTRICTION_CODE = 'Unknown restriction code';\\n}\\n\",\"keccak256\":\"0x4ceefe5db0e5056edaf89b9aea9a130720ed116a5f66f543b6ecf57a0360397a\",\"license\":\"MIT\"},\"contracts/lib/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x1c1bcc2f4ce958b3569ec95530879a584e4cf837d585a5059b3b612ad4a71a47\",\"license\":\"MIT\"},\"contracts/lib/LibHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nlibrary LibHelpers {\\n  function upTo(address payable to, uint256 amount)\\n      internal view returns(uint256) {\\n    // If the recipient has more than what is ought to be paid, return.\\n    uint256 toBalance = to.balance;\\n    if (toBalance >= amount) { return 0; }\\n    // If the recipient has some Eth we should only pay the top-up.\\n    amount = amount - toBalance;\\n    // If the available eth is less than what we should pay, just cap it.\\n    uint256 available = payable(address(this)).balance;\\n    if (available < amount) { amount = available; }\\n    // Provision the new fast with Eth.\\n    return amount;\\n  }\\n\\n  function isContract(address target)\\n      internal view returns (bool) {\\n    uint32 size;\\n    assembly { size := extcodesize(target) }\\n    return (size > 0);\\n  }\\n}\\n\",\"keccak256\":\"0xa3ac21d8e6e5f25d9125d2975e7157e5c660bd481fb102c39a64810955d6eaab\",\"license\":\"MIT\"},\"contracts/lib/LibPaginate.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../fast/lib/LibFastHistory.sol';\\n\\n\\nlibrary LibPaginate {\\n  function addresses(address[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(address[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      address[] memory values = new address[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function uint256s(uint256[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(uint256[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      uint256[] memory values = new uint256[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function supplyProofs(LibFastHistory.SupplyProof[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(LibFastHistory.SupplyProof[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      LibFastHistory.SupplyProof[] memory values = new LibFastHistory.SupplyProof[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function transferProofs(LibFastHistory.TransferProof[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n}\",\"keccak256\":\"0xedbf24531aa1b21a17a7962b2053fe1bd81ddf9e8869f508f14f7fb9087631d9\",\"license\":\"MIT\"},\"contracts/spc/SpcTopFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../lib/LibHelpers.sol';\\nimport '../fast/FastTopFacet.sol';\\nimport '../fast/FastTokenFacet.sol';\\nimport './lib/ASpcFacet.sol';\\nimport './lib/LibSpc.sol';\\n\\n\\n/** @title The SPC Smart Contract.\\n *  @dev The SPC contract is the central place for top-level governorship. It requires that a\\n *        first member address is passed at construction time.\\n */\\ncontract SpcTopFacet is ASpcFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Events.\\n\\n  /** @dev Emited when a new FAST is registered.\\n   *  @param fast The address of the newly registered FAST diamond.\\n   */\\n  event FastRegistered(address indexed fast);\\n\\n  /** @dev Emited when someone provisions this SPC with Eth.\\n   *  @param from The sender of the Eth.\\n   *  @param amount The quantity of Eth, expressed in Wei.\\n   */\\n  event EthReceived(address indexed from, uint256 amount);\\n  /** @dev Emited when Eth is drained from this SPC.\\n   *  @param to The caller and recipient of the drained Eth.\\n   *  @param amount The quantity of Eth that was drained, expressed in Wei.\\n   */\\n  event EthDrained(address indexed to, uint256 amount);\\n\\n  // Constants.\\n\\n  // This represents how much Eth we provision new SPC members with.\\n  uint256 constant private MEMBER_ETH_PROVISION = 10 ether;\\n  // This represents how much Eth new FASTs are provisioned with.\\n  uint256 constant private FAST_ETH_PROVISION = 250 ether;\\n\\n  // Eth provisioning stuff.\\n\\n  /** @dev A function that alllows provisioning this SPC with Eth.\\n   *  @notice Emits a `EthReceived` event.\\n   */\\n  function provisionWithEth()\\n      external payable {\\n    require(msg.value > 0, LibConstants.MISSING_ATTACHED_ETH);\\n    emit EthReceived(msg.sender, msg.value);\\n  }\\n\\n  /** @dev A function that alllows draining this SPC from its Eth.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `EthDrained` event.\\n   */\\n  function drainEth()\\n      external\\n      membership(msg.sender) {\\n    uint256 amount = payable(address(this)).balance;\\n    payable(msg.sender).transfer(amount);\\n    emit EthDrained(msg.sender, amount);\\n  }\\n\\n  // FAST management related methods.\\n\\n  /** @dev Queries whether a given address is a known and registered FAST contract.\\n   * @param fast The address of the contract to check.\\n   * @return A boolean.\\n   */\\n  function isFastRegistered(address fast)\\n      external view returns(bool) {\\n    return LibSpc.data().fastSet.contains(fast);\\n  }\\n\\n  /** @dev Allows to retrieve the address of a FAST diamond given its symbol.\\n   *  @param symbol The symbol of the FAST diamond to get the address of.\\n   *  @return The address of the corresponding FAST diamond, or the Zero Address if not found.\\n   */\\n  function fastBySymbol(string calldata symbol)\\n      external view returns(address) {\\n    return LibSpc.data().fastSymbols[symbol];\\n  }\\n\\n  /** @dev Allows the registration of a given FAST diamond with this SPC.\\n   *  @param fast The address of the FAST diamond to be registered.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `FastRegistered` event.\\n   */\\n  function registerFast(address fast)\\n      external\\n      membership(msg.sender) {\\n    LibSpc.Data storage s = LibSpc.data();\\n    string memory symbol = FastTokenFacet(fast).symbol();\\n    require(s.fastSymbols[symbol] == address(0), LibConstants.DUPLICATE_ENTRY);\\n\\n    // Add the FAST to our list.\\n    s.fastSet.add(fast, false);\\n    // Add the fast symbol to our list.\\n    s.fastSymbols[symbol] = fast;\\n\\n    // Provision the new fast with Eth.\\n    uint256 amount = LibHelpers.upTo(payable(fast), FAST_ETH_PROVISION);\\n    // Only provision the fast if possible.\\n    if (amount > 0) {\\n      FastTopFacet(fast).provisionWithEth{ value: amount }();\\n    }\\n    // Emit!\\n    emit FastRegistered(fast);\\n  }\\n\\n  /** @dev Counts the number of FAST diamonds registered with this SPC.\\n   *  @return The number of FAST diamonds registered with this SPC.\\n   */\\n  function fastCount()\\n      external view returns(uint256) {\\n    return LibSpc.data().fastSet.values.length;\\n  }\\n\\n  /** @dev Paginates the FAST diamonds registered with this SPC based on a starting cursor and a number of records per page.\\n   *  @param cursor The index at which to start.\\n   *  @param perPage How many records should be returned at most.\\n   *  @return A `address[]` list of values at most `perPage` big.\\n   *  @return A `uint256` index to the next page.\\n   */\\n  function paginateFasts(uint256 cursor, uint256 perPage)\\n      external view\\n      returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibSpc.data().fastSet.values, cursor, perPage);\\n  }\\n}\\n\",\"keccak256\":\"0x9de5ab9b06ba54d3451a5935e33085874fb8051e0664e52efa9250ac0e6459bf\",\"license\":\"MIT\"},\"contracts/spc/lib/ASpcFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../lib/LibSpcAccess.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract ASpcFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\\n  modifier diamondInternal() {\\n    require(msg.sender == address(this), LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\\n  modifier diamondOwner() {\\n    require(msg.sender == IERC173(address(this)).owner(), LibConstants.REQUIRES_DIAMOND_OWNERSHIP);\\n    _;\\n  }\\n\\n  /// @dev Ensures that the given address is a member of the current FAST.\\n  modifier membership(address candidate) {\\n    require(LibSpcAccess.data().memberSet.contains(candidate), LibConstants.REQUIRES_SPC_MEMBERSHIP);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x8df4687d03c52532c28f6bc2816c73ae283afdf35870de327ab8cb1dbc7de6f6\",\"license\":\"MIT\"},\"contracts/spc/lib/LibSpc.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibSpc {\\n  // These are from IHasMembers.\\n  event MemberAdded(address indexed member);\\n\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Spc.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x89a652f66ca129ef71cab44916bb070742a08af428e08a99df145c8006c94285;\\n\\n  // Data structures.\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    // This is where we keep our list of deployed fast FASTs.\\n    LibAddressSet.Data fastSet;\\n    // We keep track of the FAST symbols that were already used.\\n    mapping(string => address) fastSymbols;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xb9d103fa8508f5e113612e9945bf58e378392566433141f7b967278a6f8d87a2\",\"license\":\"MIT\"},\"contracts/spc/lib/LibSpcAccess.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibSpcAccess {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Spc.storage.Access'):\\n  bytes32 internal constant STORAGE_SLOT = 0xe275f58a6a7f532ee3fa7fff24450c253df494fca407d91f5c35e83236f64d7c;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    // This is where we hold our members data.\\n    LibAddressSet.Data memberSet;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x29d45304060a54f75b7dfbaada867418c97bac21dd484ac6c777b33f3628eb35\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506113bc806100206000396000f3fe6080604052600436106100705760003560e01c80633eca424b1161004e5780633eca424b146100f457806341d7c02d146100fe578063654eebcb1461013b5780638201d2061461016457610070565b80630baac66f14610075578063112b24c91461008c578063164f8e6a146100b7575b600080fd5b34801561008157600080fd5b5061008a6101a2565b005b34801561009857600080fd5b506100a16102ed565b6040516100ae9190611061565b60405180910390f35b3480156100c357600080fd5b506100de60048036038101906100d99190610d63565b610306565b6040516100eb9190610fb9565b60405180910390f35b6100fc61035a565b005b34801561010a57600080fd5b5061012560048036038101906101209190610d3a565b610426565b6040516101329190611004565b60405180910390f35b34801561014757600080fd5b50610162600480360381019061015d9190610d3a565b61044c565b005b34801561017057600080fd5b5061018b60048036038101906101869190610de9565b6107a1565b604051610199929190610fd4565b60405180910390f35b336101c0816101af6107c8565b6001016107f090919063ffffffff16565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610237576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161022e919061101f565b60405180910390fd5b5060003073ffffffffffffffffffffffffffffffffffffffff163190503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f1935050505015801561029a573d6000803e3d6000fd5b503373ffffffffffffffffffffffffffffffffffffffff167fd5a7a0257eadbfea7ac4432ca8fe62ac277d64736ab6ef67f11abf238a1e0f1a826040516102e19190611061565b60405180910390a25050565b60006102f76108e6565b60010160010180549050905090565b60006103106108e6565b6003018383604051610323929190610f89565b908152602001604051809103902060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905092915050565b600034116040518060400160405280601481526020017f4d697373696e6720617474616368656420455448000000000000000000000000815250906103d5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103cc919061101f565b60405180910390fd5b503373ffffffffffffffffffffffffffffffffffffffff167f85177f287940f2f05425a4029951af0e047a7f9c4eaa9a6e6917bcd869f866953460405161041c9190611061565b60405180910390a2565b6000610445826104346108e6565b6001016107f090919063ffffffff16565b9050919050565b3361046a816104596107c8565b6001016107f090919063ffffffff16565b6040518060400160405280601781526020017f526571756972657320535043206d656d62657273686970000000000000000000815250906104e1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d8919061101f565b60405180910390fd5b5060006104ec6108e6565b905060008373ffffffffffffffffffffffffffffffffffffffff166395d89b416040518163ffffffff1660e01b815260040160006040518083038186803b15801561053657600080fd5b505afa15801561054a573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906105739190610da8565b9050600073ffffffffffffffffffffffffffffffffffffffff16826003018260405161059f9190610fa2565b908152602001604051809103902060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146040518060400160405280600f81526020017f4475706c696361746520656e74727900000000000000000000000000000000008152509061065c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610653919061101f565b60405180910390fd5b506106768460008460010161090e9092919063ffffffff16565b8382600301826040516106899190610fa2565b908152602001604051809103902060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060006106ea85680d8d726b7177a80000610a2b565b90506000811115610757578473ffffffffffffffffffffffffffffffffffffffff16633eca424b826040518263ffffffff1660e01b81526004016000604051808303818588803b15801561073d57600080fd5b505af1158015610751573d6000803e3d6000fd5b50505050505b8473ffffffffffffffffffffffffffffffffffffffff167fa393070be795669766b8f40ecaab0724def57650be5914b232c8fb18ca507f3660405160405180910390a25050505050565b606060006107bd6107b06108e6565b6001016001018585610a9b565b915091509250929050565b60007fe275f58a6a7f532ee3fa7fff24450c253df494fca407d91f5c35e83236f64d7c905090565b6000808360010180549050146108db578173ffffffffffffffffffffffffffffffffffffffff16836001018460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205481548110610894577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146108de565b60005b905092915050565b60007f89a652f66ca129ef71cab44916bb070742a08af428e08a99df145c8006c94285905090565b600061091a84846107f0565b90508180156109265750805b156109315750610a26565b8015610972576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161096990611041565b60405180910390fd5b83600101805490508460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555083600101839080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505b505050565b6000808373ffffffffffffffffffffffffffffffffffffffff16319050828110610a59576000915050610a95565b8083610a659190611188565b925060003073ffffffffffffffffffffffffffffffffffffffff1631905083811015610a8f578093505b83925050505b92915050565b6060600080848680549050610ab09190611188565b8411610abc5783610acd565b848680549050610acc9190611188565b5b905060008167ffffffffffffffff811115610b11577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051908082528060200260200182016040528015610b3f5781602001602082028036833780820191505090505b50905060005b82811015610c4257878188610b5a9190611132565b81548110610b91577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16828281518110610bf5577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508080610c3a90611277565b915050610b45565b50808287610c509190611132565b935093505050935093915050565b6000610c71610c6c846110a1565b61107c565b905082815260208101848484011115610c8957600080fd5b610c94848285611213565b509392505050565b600081359050610cab81611358565b92915050565b60008083601f840112610cc357600080fd5b8235905067ffffffffffffffff811115610cdc57600080fd5b602083019150836001820283011115610cf457600080fd5b9250929050565b600082601f830112610d0c57600080fd5b8151610d1c848260208601610c5e565b91505092915050565b600081359050610d348161136f565b92915050565b600060208284031215610d4c57600080fd5b6000610d5a84828501610c9c565b91505092915050565b60008060208385031215610d7657600080fd5b600083013567ffffffffffffffff811115610d9057600080fd5b610d9c85828601610cb1565b92509250509250929050565b600060208284031215610dba57600080fd5b600082015167ffffffffffffffff811115610dd457600080fd5b610de084828501610cfb565b91505092915050565b60008060408385031215610dfc57600080fd5b6000610e0a85828601610d25565b9250506020610e1b85828601610d25565b9150509250929050565b6000610e318383610e3d565b60208301905092915050565b610e46816111bc565b82525050565b610e55816111bc565b82525050565b6000610e66826110e2565b610e708185611105565b9350610e7b836110d2565b8060005b83811015610eac578151610e938882610e25565b9750610e9e836110f8565b925050600181019050610e7f565b5085935050505092915050565b610ec2816111ce565b82525050565b6000610ed48385611127565b9350610ee1838584611204565b82840190509392505050565b6000610ef8826110ed565b610f028185611116565b9350610f12818560208601611213565b610f1b8161131e565b840191505092915050565b6000610f31826110ed565b610f3b8185611127565b9350610f4b818560208601611213565b80840191505092915050565b6000610f64601683611116565b9150610f6f8261132f565b602082019050919050565b610f83816111fa565b82525050565b6000610f96828486610ec8565b91508190509392505050565b6000610fae8284610f26565b915081905092915050565b6000602082019050610fce6000830184610e4c565b92915050565b60006040820190508181036000830152610fee8185610e5b565b9050610ffd6020830184610f7a565b9392505050565b60006020820190506110196000830184610eb9565b92915050565b600060208201905081810360008301526110398184610eed565b905092915050565b6000602082019050818103600083015261105a81610f57565b9050919050565b60006020820190506110766000830184610f7a565b92915050565b6000611086611097565b90506110928282611246565b919050565b6000604051905090565b600067ffffffffffffffff8211156110bc576110bb6112ef565b5b6110c58261131e565b9050602081019050919050565b6000819050602082019050919050565b600081519050919050565b600081519050919050565b6000602082019050919050565b600082825260208201905092915050565b600082825260208201905092915050565b600081905092915050565b600061113d826111fa565b9150611148836111fa565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0382111561117d5761117c6112c0565b5b828201905092915050565b6000611193826111fa565b915061119e836111fa565b9250828210156111b1576111b06112c0565b5b828203905092915050565b60006111c7826111da565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b82818337600083830152505050565b60005b83811015611231578082015181840152602081019050611216565b83811115611240576000848401525b50505050565b61124f8261131e565b810181811067ffffffffffffffff8211171561126e5761126d6112ef565b5b80604052505050565b6000611282826111fa565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156112b5576112b46112c0565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000601f19601f8301169050919050565b7f4164647265737320616c726561647920696e2073657400000000000000000000600082015250565b611361816111bc565b811461136c57600080fd5b50565b611378816111fa565b811461138357600080fd5b5056fea2646970667358221220a45c7684231dc16f19d9dcafb93ef8a802fa80d7795e0a5511fe9f7528707c4a64736f6c63430008040033",
  "deployedBytecode": "0x6080604052600436106100705760003560e01c80633eca424b1161004e5780633eca424b146100f457806341d7c02d146100fe578063654eebcb1461013b5780638201d2061461016457610070565b80630baac66f14610075578063112b24c91461008c578063164f8e6a146100b7575b600080fd5b34801561008157600080fd5b5061008a6101a2565b005b34801561009857600080fd5b506100a16102ed565b6040516100ae9190611061565b60405180910390f35b3480156100c357600080fd5b506100de60048036038101906100d99190610d63565b610306565b6040516100eb9190610fb9565b60405180910390f35b6100fc61035a565b005b34801561010a57600080fd5b5061012560048036038101906101209190610d3a565b610426565b6040516101329190611004565b60405180910390f35b34801561014757600080fd5b50610162600480360381019061015d9190610d3a565b61044c565b005b34801561017057600080fd5b5061018b60048036038101906101869190610de9565b6107a1565b604051610199929190610fd4565b60405180910390f35b336101c0816101af6107c8565b6001016107f090919063ffffffff16565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610237576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161022e919061101f565b60405180910390fd5b5060003073ffffffffffffffffffffffffffffffffffffffff163190503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f1935050505015801561029a573d6000803e3d6000fd5b503373ffffffffffffffffffffffffffffffffffffffff167fd5a7a0257eadbfea7ac4432ca8fe62ac277d64736ab6ef67f11abf238a1e0f1a826040516102e19190611061565b60405180910390a25050565b60006102f76108e6565b60010160010180549050905090565b60006103106108e6565b6003018383604051610323929190610f89565b908152602001604051809103902060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905092915050565b600034116040518060400160405280601481526020017f4d697373696e6720617474616368656420455448000000000000000000000000815250906103d5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103cc919061101f565b60405180910390fd5b503373ffffffffffffffffffffffffffffffffffffffff167f85177f287940f2f05425a4029951af0e047a7f9c4eaa9a6e6917bcd869f866953460405161041c9190611061565b60405180910390a2565b6000610445826104346108e6565b6001016107f090919063ffffffff16565b9050919050565b3361046a816104596107c8565b6001016107f090919063ffffffff16565b6040518060400160405280601781526020017f526571756972657320535043206d656d62657273686970000000000000000000815250906104e1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104d8919061101f565b60405180910390fd5b5060006104ec6108e6565b905060008373ffffffffffffffffffffffffffffffffffffffff166395d89b416040518163ffffffff1660e01b815260040160006040518083038186803b15801561053657600080fd5b505afa15801561054a573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906105739190610da8565b9050600073ffffffffffffffffffffffffffffffffffffffff16826003018260405161059f9190610fa2565b908152602001604051809103902060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146040518060400160405280600f81526020017f4475706c696361746520656e74727900000000000000000000000000000000008152509061065c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610653919061101f565b60405180910390fd5b506106768460008460010161090e9092919063ffffffff16565b8382600301826040516106899190610fa2565b908152602001604051809103902060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060006106ea85680d8d726b7177a80000610a2b565b90506000811115610757578473ffffffffffffffffffffffffffffffffffffffff16633eca424b826040518263ffffffff1660e01b81526004016000604051808303818588803b15801561073d57600080fd5b505af1158015610751573d6000803e3d6000fd5b50505050505b8473ffffffffffffffffffffffffffffffffffffffff167fa393070be795669766b8f40ecaab0724def57650be5914b232c8fb18ca507f3660405160405180910390a25050505050565b606060006107bd6107b06108e6565b6001016001018585610a9b565b915091509250929050565b60007fe275f58a6a7f532ee3fa7fff24450c253df494fca407d91f5c35e83236f64d7c905090565b6000808360010180549050146108db578173ffffffffffffffffffffffffffffffffffffffff16836001018460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205481548110610894577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146108de565b60005b905092915050565b60007f89a652f66ca129ef71cab44916bb070742a08af428e08a99df145c8006c94285905090565b600061091a84846107f0565b90508180156109265750805b156109315750610a26565b8015610972576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161096990611041565b60405180910390fd5b83600101805490508460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555083600101839080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505b505050565b6000808373ffffffffffffffffffffffffffffffffffffffff16319050828110610a59576000915050610a95565b8083610a659190611188565b925060003073ffffffffffffffffffffffffffffffffffffffff1631905083811015610a8f578093505b83925050505b92915050565b6060600080848680549050610ab09190611188565b8411610abc5783610acd565b848680549050610acc9190611188565b5b905060008167ffffffffffffffff811115610b11577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051908082528060200260200182016040528015610b3f5781602001602082028036833780820191505090505b50905060005b82811015610c4257878188610b5a9190611132565b81548110610b91577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16828281518110610bf5577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508080610c3a90611277565b915050610b45565b50808287610c509190611132565b935093505050935093915050565b6000610c71610c6c846110a1565b61107c565b905082815260208101848484011115610c8957600080fd5b610c94848285611213565b509392505050565b600081359050610cab81611358565b92915050565b60008083601f840112610cc357600080fd5b8235905067ffffffffffffffff811115610cdc57600080fd5b602083019150836001820283011115610cf457600080fd5b9250929050565b600082601f830112610d0c57600080fd5b8151610d1c848260208601610c5e565b91505092915050565b600081359050610d348161136f565b92915050565b600060208284031215610d4c57600080fd5b6000610d5a84828501610c9c565b91505092915050565b60008060208385031215610d7657600080fd5b600083013567ffffffffffffffff811115610d9057600080fd5b610d9c85828601610cb1565b92509250509250929050565b600060208284031215610dba57600080fd5b600082015167ffffffffffffffff811115610dd457600080fd5b610de084828501610cfb565b91505092915050565b60008060408385031215610dfc57600080fd5b6000610e0a85828601610d25565b9250506020610e1b85828601610d25565b9150509250929050565b6000610e318383610e3d565b60208301905092915050565b610e46816111bc565b82525050565b610e55816111bc565b82525050565b6000610e66826110e2565b610e708185611105565b9350610e7b836110d2565b8060005b83811015610eac578151610e938882610e25565b9750610e9e836110f8565b925050600181019050610e7f565b5085935050505092915050565b610ec2816111ce565b82525050565b6000610ed48385611127565b9350610ee1838584611204565b82840190509392505050565b6000610ef8826110ed565b610f028185611116565b9350610f12818560208601611213565b610f1b8161131e565b840191505092915050565b6000610f31826110ed565b610f3b8185611127565b9350610f4b818560208601611213565b80840191505092915050565b6000610f64601683611116565b9150610f6f8261132f565b602082019050919050565b610f83816111fa565b82525050565b6000610f96828486610ec8565b91508190509392505050565b6000610fae8284610f26565b915081905092915050565b6000602082019050610fce6000830184610e4c565b92915050565b60006040820190508181036000830152610fee8185610e5b565b9050610ffd6020830184610f7a565b9392505050565b60006020820190506110196000830184610eb9565b92915050565b600060208201905081810360008301526110398184610eed565b905092915050565b6000602082019050818103600083015261105a81610f57565b9050919050565b60006020820190506110766000830184610f7a565b92915050565b6000611086611097565b90506110928282611246565b919050565b6000604051905090565b600067ffffffffffffffff8211156110bc576110bb6112ef565b5b6110c58261131e565b9050602081019050919050565b6000819050602082019050919050565b600081519050919050565b600081519050919050565b6000602082019050919050565b600082825260208201905092915050565b600082825260208201905092915050565b600081905092915050565b600061113d826111fa565b9150611148836111fa565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0382111561117d5761117c6112c0565b5b828201905092915050565b6000611193826111fa565b915061119e836111fa565b9250828210156111b1576111b06112c0565b5b828203905092915050565b60006111c7826111da565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b82818337600083830152505050565b60005b83811015611231578082015181840152602081019050611216565b83811115611240576000848401525b50505050565b61124f8261131e565b810181811067ffffffffffffffff8211171561126e5761126d6112ef565b5b80604052505050565b6000611282826111fa565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156112b5576112b46112c0565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000601f19601f8301169050919050565b7f4164647265737320616c726561647920696e2073657400000000000000000000600082015250565b611361816111bc565b811461136c57600080fd5b50565b611378816111fa565b811461138357600080fd5b5056fea2646970667358221220a45c7684231dc16f19d9dcafb93ef8a802fa80d7795e0a5511fe9f7528707c4a64736f6c63430008040033",
  "devdoc": {
    "details": "The SPC contract is the central place for top-level governorship. It requires that a        first member address is passed at construction time.",
    "events": {
      "EthDrained(address,uint256)": {
        "details": "Emited when Eth is drained from this SPC.",
        "params": {
          "amount": "The quantity of Eth that was drained, expressed in Wei.",
          "to": "The caller and recipient of the drained Eth."
        }
      },
      "EthReceived(address,uint256)": {
        "details": "Emited when someone provisions this SPC with Eth.",
        "params": {
          "amount": "The quantity of Eth, expressed in Wei.",
          "from": "The sender of the Eth."
        }
      },
      "FastRegistered(address)": {
        "details": "Emited when a new FAST is registered.",
        "params": {
          "fast": "The address of the newly registered FAST diamond."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "drainEth()": {
        "details": "A function that alllows draining this SPC from its Eth."
      },
      "fastBySymbol(string)": {
        "details": "Allows to retrieve the address of a FAST diamond given its symbol.",
        "params": {
          "symbol": "The symbol of the FAST diamond to get the address of."
        },
        "returns": {
          "_0": "The address of the corresponding FAST diamond, or the Zero Address if not found."
        }
      },
      "fastCount()": {
        "details": "Counts the number of FAST diamonds registered with this SPC.",
        "returns": {
          "_0": "The number of FAST diamonds registered with this SPC."
        }
      },
      "isFastRegistered(address)": {
        "details": "Queries whether a given address is a known and registered FAST contract.",
        "params": {
          "fast": "The address of the contract to check."
        },
        "returns": {
          "_0": "A boolean."
        }
      },
      "paginateFasts(uint256,uint256)": {
        "details": "Paginates the FAST diamonds registered with this SPC based on a starting cursor and a number of records per page.",
        "params": {
          "cursor": "The index at which to start.",
          "perPage": "How many records should be returned at most."
        },
        "returns": {
          "_0": "A `address[]` list of values at most `perPage` big.",
          "_1": "A `uint256` index to the next page."
        }
      },
      "provisionWithEth()": {
        "details": "A function that alllows provisioning this SPC with Eth."
      },
      "registerFast(address)": {
        "details": "Allows the registration of a given FAST diamond with this SPC.",
        "params": {
          "fast": "The address of the FAST diamond to be registered."
        }
      }
    },
    "title": "The SPC Smart Contract.",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "drainEth()": {
        "notice": "Requires that the caller is a member of this SPC.Emits a `EthDrained` event."
      },
      "provisionWithEth()": {
        "notice": "Emits a `EthReceived` event."
      },
      "registerFast(address)": {
        "notice": "Requires that the caller is a member of this SPC.Emits a `FastRegistered` event."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}