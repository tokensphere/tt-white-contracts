{
  "address": "0x6ada6fc10D53c96d738ef4D645Cde0889A43540c",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "EthDrained",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "EthReceived",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "fast",
          "type": "address"
        }
      ],
      "name": "FastRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "MemberAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "MemberRemoved",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "addMember",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "drainEth",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "symbol",
          "type": "string"
        }
      ],
      "name": "fastBySymbol",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fastCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "fast",
          "type": "address"
        }
      ],
      "name": "isFastRegistered",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "candidate",
          "type": "address"
        }
      ],
      "name": "isMember",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "memberCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "cursor",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "perPage",
          "type": "uint256"
        }
      ],
      "name": "paginateFasts",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "cursor",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "perPage",
          "type": "uint256"
        }
      ],
      "name": "paginateMembers",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "provisionWithEth",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "fast",
          "type": "address"
        }
      ],
      "name": "registerFast",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "removeMember",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x6693092f3db7bc80c58a08c0e6f7bb02dcfa98889c8836d11f708cdb3fa8c933",
  "receipt": {
    "to": "0x6DF2D25d8C6FD680730ee658b530A05a99BB769a",
    "from": "0x717634cfe06FFAB2CEAA7fcf1b9019813f4B25FE",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "1922500",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xaaba4b96f87a02e25bb280040e714bef3f748638a4a179cc60470a5a19ab2c1a",
    "transactionHash": "0x6693092f3db7bc80c58a08c0e6f7bb02dcfa98889c8836d11f708cdb3fa8c933",
    "logs": [],
    "blockNumber": 5901526,
    "cumulativeGasUsed": "1922500",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "ff01faa9007aa585a44363003101a726",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthDrained\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fast\",\"type\":\"address\"}],\"name\":\"FastRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"addMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"drainEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"fastBySymbol\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fastCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fast\",\"type\":\"address\"}],\"name\":\"isFastRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"}],\"name\":\"isMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"memberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perPage\",\"type\":\"uint256\"}],\"name\":\"paginateFasts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perPage\",\"type\":\"uint256\"}],\"name\":\"paginateMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"provisionWithEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fast\",\"type\":\"address\"}],\"name\":\"registerFast\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"The SPC contract is the central place for top-level governorship. It requires that a        first member address is passed at construction time.\",\"events\":{\"EthDrained(address,uint256)\":{\"details\":\"Emited when Eth is drained from this SPC.\",\"params\":{\"amount\":\"The quantity of Eth that was drained, expressed in Wei.\",\"to\":\"The caller and recipient of the drained Eth.\"}},\"EthReceived(address,uint256)\":{\"details\":\"Emited when someone provisions this SPC with Eth.\",\"params\":{\"amount\":\"The quantity of Eth, expressed in Wei.\",\"from\":\"The sender of the Eth.\"}},\"FastRegistered(address)\":{\"details\":\"Emited when a new FAST is registered.\",\"params\":{\"fast\":\"The address of the newly registered FAST diamond.\"}}},\"kind\":\"dev\",\"methods\":{\"addMember(address)\":{\"details\":\"Adds a member to this SPC member list.\",\"params\":{\"member\":\"The address of the member to be added.\"}},\"drainEth()\":{\"details\":\"A function that alllows draining this SPC from its Eth.\"},\"fastBySymbol(string)\":{\"details\":\"Allows to retrieve the address of a FAST diamond given its symbol.\",\"params\":{\"symbol\":\"The symbol of the FAST diamond to get the address of.\"},\"returns\":{\"_0\":\"The address of the corresponding FAST diamond, or the Zero Address if not found.\"}},\"fastCount()\":{\"details\":\"Counts the number of FAST diamonds registered with this SPC.\",\"returns\":{\"_0\":\"The number of FAST diamonds registered with this SPC.\"}},\"isFastRegistered(address)\":{\"details\":\"Queries whether a given address is a known and registered FAST contract.\",\"params\":{\"fast\":\"The address of the contract to check.\"},\"returns\":{\"_0\":\"A boolean.\"}},\"isMember(address)\":{\"details\":\"Queries whether a given address is a member of this SPC or not.\",\"params\":{\"candidate\":\"The address to test.\"},\"returns\":{\"_0\":\"A `boolean` flag.\"}},\"memberCount()\":{\"details\":\"Counts the numbers of members present in this SPC.\",\"returns\":{\"_0\":\"The number of members in this SPC.\"}},\"paginateFasts(uint256,uint256)\":{\"details\":\"Paginates the FAST diamonds registered with this SPC based on a starting cursor and a number of records per page.\",\"params\":{\"cursor\":\"The index at which to start.\",\"perPage\":\"How many records should be returned at most.\"},\"returns\":{\"_0\":\"A `address[]` list of values at most `perPage` big.\",\"_1\":\"A `uint256` index to the next page.\"}},\"paginateMembers(uint256,uint256)\":{\"details\":\"Paginates the members of this SPC based on a starting cursor and a number of records per page.\",\"params\":{\"cursor\":\"The index at which to start.\",\"perPage\":\"How many records should be returned at most.\"},\"returns\":{\"_0\":\"A `address[]` list of values at most `perPage` big.\",\"_1\":\"A `uint256` index to the next page.\"}},\"provisionWithEth()\":{\"details\":\"A function that alllows provisioning this SPC with Eth.\"},\"registerFast(address)\":{\"details\":\"Allows the registration of a given FAST diamond with this SPC.\",\"params\":{\"fast\":\"The address of the FAST diamond to be registered.\"}},\"removeMember(address)\":{\"details\":\"Removes a member from this SPC.\",\"params\":{\"member\":\"The address of the member to be removed.\"}}},\"title\":\"The SPC Smart Contract.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addMember(address)\":{\"notice\":\"Requires that the caller is a member of this SPC.Emits a `IHasMembers.MemberAdded` event.\"},\"drainEth()\":{\"notice\":\"Requires that the caller is a member of this SPC.Emits a `EthDrained` event.\"},\"provisionWithEth()\":{\"notice\":\"Emits a `EthReceived` event.\"},\"registerFast(address)\":{\"notice\":\"Requires that the caller is a member of this SPC.Emits a `FastRegistered` event.\"},\"removeMember(address)\":{\"notice\":\"Requires that the caller is a member of this SPC.Emits a `IHasMembers.MemberRemoved` event.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/spc/SpcTopFacet.sol\":\"SpcTopFacet\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/exchange/ExchangeTopFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../spc/SpcTopFacet.sol';\\nimport './lib/LibExchange.sol';\\nimport '../interfaces/IHasMembers.sol';\\nimport './lib/AExchangeFacet.sol';\\n\\n\\n/** @title The Exchange Smart Contract.\\n *  @dev The exchange facet is in charge of keeping track of exchange members and has logic\\n *  related to trading.\\n *  It requires an SPC contract instance at initialization-time, as it relies on SPC membership\\n *  to permission governance functions.\\n *  For now, the Exchange contract will only have one facet. Later on, we should split its\\n *  business logic into as many facets as we have domains.\\n */\\ncontract ExchangeTopFacet is AExchangeFacet, IHasMembers {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Getters.\\n\\n  function spcAddress()\\n    external view returns(address) {\\n      return LibExchange.data().spc;\\n  }\\n\\n  // Membership management.\\n\\n  /** @dev Queries whether a given address is a member of this Exchange or not.\\n   *  @param candidate is the address to test.\\n   *  @return A `boolean` flag.\\n   */\\n  function isMember(address candidate)\\n      external override view returns(bool) {\\n    return LibExchange.data().memberSet.contains(candidate);\\n  }\\n\\n  /** @dev Counts the numbers of members present in this Exchange.\\n   *  @return The number of members in this exchange.\\n   */\\n  function memberCount()\\n      external override view returns(uint256) {\\n    return LibExchange.data().memberSet.values.length;\\n  }\\n\\n  /** @dev Paginates the members of this Exchange based on a starting cursor and a number of records per page.\\n   *  @param cursor is the index at which to start.\\n   *  @param perPage is how many records should be returned at most.\\n   *  @return A `address[]` list of values at most `perPage` big.\\n   *  @return A `uint256` index to the next page.\\n   */\\n  function paginateMembers(uint256 cursor, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibExchange.data().memberSet.values, cursor, perPage);\\n  }\\n\\n  /** @dev Adds a member to this Exchange member list.\\n   *  @param member is the address of the member to be added.\\n   *  @notice Requires that the caller is a member of the linked SPC.\\n   *  @notice Emits a `IHasMembers.MemberAdded` event.\\n   */\\n  function addMember(address payable member)\\n      external override\\n      spcMembership(msg.sender) {\\n    // Add the member to our list.\\n    LibExchange.data().memberSet.add(member, false);\\n    // Emit!\\n    emit IHasMembers.MemberAdded(member);\\n  }\\n\\n  /** @dev Removes a member from this Exchange.\\n   *  @param member is the address of the member to be removed.\\n   *  @notice Requires that the caller is a member of the linked SPC.\\n   *  @notice Emits a `IHasMembers.MemberRemoved` event.\\n   */\\n  function removeMember(address member)\\n      external override\\n      spcMembership(msg.sender) {\\n    LibExchange.Data storage s = LibExchange.data();\\n    // Ensure that member doesn't have any FAST membership.\\n    require(s.fastMemberships[member].values.length == 0, LibConstants.REQUIRES_NO_FAST_MEMBERSHIPS);\\n    // Remove member.\\n    s.memberSet.remove(member, false);\\n    // Emit!\\n    emit IHasMembers.MemberRemoved(member);\\n  }\\n\\n  /** @dev Allows to query FAST memberships for a given member address.\\n   *  @param member Is the address to check.\\n   *  @param cursor The index at which to start.\\n   *  @param perPage How many records should be returned at most.\\n   */\\n  function fastMemberships(address member, uint256 cursor, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibExchange.data().fastMemberships[member].values, cursor, perPage);\\n  }\\n\\n  /** @dev Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.\\n   *  @param member The member for which a new FAST membership has been added.\\n   */\\n  function memberAddedToFast(address member) \\n      external {\\n    LibExchange.Data storage s = LibExchange.data();\\n    // Verify that the given address is in fact a registered FAST contract.\\n    require(SpcTopFacet(s.spc).isFastRegistered(msg.sender), LibConstants.REQUIRES_FAST_CONTRACT_CALLER);\\n    // Keep track of the member's FAST membership.\\n    LibAddressSet.Data storage memberFasts = s.fastMemberships[member];\\n    memberFasts.add(msg.sender, false);\\n  }\\n\\n  /** @dev Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.\\n   *  @param member The member for which a FAST membership has been removed.\\n   */\\n  function memberRemovedFromFast(address member)\\n      external {\\n    LibExchange.Data storage s = LibExchange.data();\\n    require(SpcTopFacet(s.spc).isFastRegistered(msg.sender), LibConstants.REQUIRES_FAST_CONTRACT_CALLER);\\n    // Remove the tracked membership.\\n    LibAddressSet.Data storage memberFasts = s.fastMemberships[member];\\n    memberFasts.remove(msg.sender, false);\\n  }\\n}\\n\",\"keccak256\":\"0xcc14c96ccdbc94599a0b5d34e45461c825ee4c28a874cb078edf11018aae0077\",\"license\":\"MIT\"},\"contracts/exchange/lib/AExchangeFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../lib/LibExchange.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../../interfaces/IHasMembers.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any Exchange facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract AExchangeFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\\n  modifier diamondInternal() {\\n    require(msg.sender == address(this), LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\\n  modifier diamondOwner() {\\n    require(msg.sender == IERC173(address(this)).owner(), LibConstants.REQUIRES_DIAMOND_OWNERSHIP);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\\n  modifier deployerContract() {\\n    require(msg.sender == LibConstants.DEPLOYER_CONTRACT, LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /** @dev Requires that the given address is a member of the linked SPC.\\n   *  @param candidate is the address to be checked.\\n   */\\n  modifier spcMembership(address candidate) {\\n    require(IHasMembers(LibExchange.data().spc).isMember(candidate), LibConstants.REQUIRES_SPC_MEMBERSHIP);\\n    _;\\n  }\\n\\n  /** @dev Requires that the given address is a member of the exchange.\\n   *  @param candidate is the address to be checked.\\n   */\\n  modifier membership(address candidate) {\\n    require(LibExchange.data().memberSet.contains(candidate), LibConstants.REQUIRES_FAST_MEMBERSHIP);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x80a065d5ae056ce96159b02adac4fb5f877169f2a9fbaa05434e4644bdc5cef0\",\"license\":\"MIT\"},\"contracts/exchange/lib/LibExchange.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibExchange {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Exchange.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x58cca9481e011ced58c1d520ef5aad456e5805265d66de8df7c52f680c417394;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev The internal pointer to the SPC contract.\\n    address spc;\\n    /// @dev This is where we hold our members data.\\n    LibAddressSet.Data memberSet;\\n    /// @dev This is where we keep track of our member FAST memberships.\\n    mapping(address => LibAddressSet.Data) fastMemberships;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xbaff538549fe11007601a828a4359fbfdcf84253e5bf424e96eb0e55014de80a\",\"license\":\"MIT\"},\"contracts/fast/FastAccessFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../interfaces/IHasMembers.sol';\\nimport '../interfaces/IHasGovernors.sol';\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../exchange/ExchangeTopFacet.sol';\\nimport './FastTokenFacet.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFast.sol';\\nimport './lib/LibFastAccess.sol';\\nimport './FastTopFacet.sol';\\n\\n\\n/**\\n* @dev The FAST Access Smart Contract is the source of truth when it comes to\\n* permissioning and ACLs within a given FAST network.\\n*/\\ncontract FastAccessFacet is AFastFacet, IHasMembers, IHasGovernors {\\n  using LibAddressSet for LibAddressSet.Data;\\n  /// Structs.\\n\\n  /**\\n   * @dev This structure isn't used anywhere in storage. Instead, it\\n   * allows various methods of the contract to return all the flags\\n   * associated with a given address in one go.\\n   */\\n  struct Flags {\\n    bool isGovernor;\\n    bool isMember;\\n  }\\n\\n  /// Constants.\\n\\n  // This represents how much Eth we provision new governors with.\\n  uint256 constant private GOVERNOR_ETH_PROVISION = 10 ether;\\n  // This represents how much Eth we provision new members with.\\n  uint256 constant private MEMBER_ETH_PROVISION = 1 ether;\\n\\n  /// Governorship related stuff.\\n\\n  /**\\n   * @dev Queries whether a given address is a governor or not.\\n   */\\n  function isGovernor(address candidate)\\n      external view override returns(bool) {\\n    return LibFastAccess.data().governorSet.contains(candidate);\\n  }\\n\\n  /**\\n   * @dev Queries the number of governors in the governorship list.\\n   */\\n  function governorCount()\\n      external override view returns(uint256) {\\n    return LibFastAccess.data().governorSet.values.length;\\n  }\\n\\n  /**\\n   * @dev Returns a page of governors.\\n   */\\n  function paginateGovernors(uint256 index, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibFastAccess.\\n      data().governorSet.values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  /**\\n   * @dev Adds a governor to the governorship list.\\n   */\\n  function addGovernor(address payable governor)\\n      external override\\n      spcMembership(msg.sender) {\\n    // Add governor to list.\\n    LibFastAccess.data().governorSet.add(governor, false);\\n    // If the address is a regular wallet...\\n    if (!LibHelpers.isContract(governor)) {\\n      // Provision the new governor with Eth if possible.\\n      FastTopFacet(payable(address(this))).payUpTo(governor, GOVERNOR_ETH_PROVISION);\\n    }\\n    // Emit!\\n    emit LibFastAccess.GovernorAdded(governor);\\n  }\\n\\n  /**\\n   * @dev Removes a governor from the governorship list.\\n   */\\n  function removeGovernor(address governor)\\n      external override\\n      spcMembership(msg.sender) {\\n    // Remove governor.\\n    LibFastAccess.data().governorSet.remove(governor, false);\\n    // Emit!\\n    emit LibFastAccess.GovernorRemoved(governor);\\n  }\\n\\n  /// Membership related stuff.\\n\\n  /**\\n   * @dev Queries whether a given address is a member or not.\\n   */\\n  function isMember(address candidate)\\n      external override view returns(bool) {\\n    return LibFastAccess.data().memberSet.contains(candidate);\\n  }\\n\\n  /**\\n   * @dev Queries the number of members in the membership list.\\n   */\\n  function memberCount()\\n      external override view returns(uint256) {\\n    return LibFastAccess.data().memberSet.values.length;\\n  }\\n\\n  /**\\n   * @dev Returns a page of members.\\n   */\\n  function paginateMembers(uint256 index, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastAccess.data().memberSet.values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  /**\\n   * @dev Adds a member to the membership list.\\n   */\\n  function addMember(address payable member)\\n      external override \\n      governance(msg.sender) exchangeMember(member) {\\n    // Add the member.\\n    LibFastAccess.data().memberSet.add(member, false);\\n    // If the address is a regular wallet...\\n    if (!LibHelpers.isContract(member)) {\\n      // Provision the new member with Eth if possible.\\n      FastTopFacet(payable(address(this))).payUpTo(member, MEMBER_ETH_PROVISION);\\n    }\\n    // Notify exchange that this member was added to this FAST.\\n    ExchangeTopFacet(LibFast.data().exchange).memberAddedToFast(member);\\n    // Emit!\\n    emit IHasMembers.MemberAdded(member);\\n  }\\n\\n  /**\\n   * @dev Removes a member from the membership list.\\n   */\\n  function removeMember(address member)\\n      external override \\n      governance(msg.sender) {\\n    // Notify token contract.\\n    FastTokenFacet(address(this)).beforeRemovingMember(member);\\n    // Remove member.\\n    LibFastAccess.data().memberSet.remove(member, false);\\n    // Notify exchange that this member was removed from this FAST.\\n    ExchangeTopFacet(LibFast.data().exchange).memberRemovedFromFast(member);\\n    // Emit!\\n    emit IHasMembers.MemberRemoved(member);\\n  }\\n\\n  /// Flags.\\n\\n  /**\\n   * @dev Retrieves flags for a given address.\\n   */\\n  function flags(address a)\\n      external view returns(Flags memory) {\\n    LibFastAccess.Data storage s = LibFastAccess.data();\\n    return\\n      Flags({\\n        isGovernor: s.governorSet.contains(a),\\n        isMember: s.memberSet.contains(a)\\n      });\\n  }\\n}\\n\",\"keccak256\":\"0x952195d7a1d8fac0f5647d1e43fb0de9ee3e1674e6d5247fb2633c5506161388\",\"license\":\"MIT\"},\"contracts/fast/FastHistoryFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibPaginate.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFastHistory.sol';\\n\\n\\ncontract FastHistoryFacet is AFastFacet {\\n  /// Minting history-keeping methods.\\n\\n  function minted(uint256 amount, string calldata ref)\\n      external diamondInternal() {\\n    // Keep track of the mint.\\n    LibFastHistory.data().supplyProofs.push(\\n      LibFastHistory.SupplyProof({\\n        op: LibFastHistory.SupplyOp.Mint,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function burnt(uint256 amount, string calldata ref)\\n      external diamondInternal() {\\n    // Keep track of the unmint.\\n    LibFastHistory.data().supplyProofs.push(\\n      LibFastHistory.SupplyProof({\\n        op: LibFastHistory.SupplyOp.Burn,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function supplyProofCount()\\n      external view returns(uint256) {\\n    return LibFastHistory.data().supplyProofs.length;\\n  }\\n\\n  function paginateSupplyProofs(uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.SupplyProof[] memory, uint256) {\\n    return LibPaginate.supplyProofs(LibFastHistory.data().supplyProofs, cursor, perPage);\\n  }\\n\\n  /// Transfer history-keeping methods.\\n\\n  function transfered(address spender, address from, address to, uint256 amount, string calldata ref)\\n      external diamondInternal() {\\n    LibFastHistory.Data storage s = LibFastHistory.data();\\n    // Keep track of the transfer proof ID for the sender and for the recipient.\\n    s.transferProofInvolvements[from].push(s.transferProofs.length);\\n    s.transferProofInvolvements[to].push(s.transferProofs.length);\\n    // Keep track of the transfer proof globally.\\n    s.transferProofs.push(\\n      LibFastHistory.TransferProof({\\n        spender: spender,\\n        from: from,\\n        to: to,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function transferProofCount()\\n      external view returns(uint256) {\\n    return LibFastHistory.data().transferProofs.length;\\n  }\\n\\n  function paginateTransferProofs(uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n    return LibPaginate.transferProofs(LibFastHistory.data().transferProofs, cursor, perPage);\\n  }\\n\\n  function transferProofByInvolveeCount(address involvee)\\n      external view returns(uint256) {\\n    return LibFastHistory.data().transferProofInvolvements[involvee].length;\\n  }\\n\\n  function paginateTransferProofIndicesByInvolvee(address involvee, uint256 cursor, uint256 perPage)\\n      external view returns(uint256[] memory, uint256) {\\n    return LibPaginate.uint256s(LibFastHistory.data().transferProofInvolvements[involvee], cursor, perPage);\\n  }\\n\\n  function paginateTransferProofsByInvolvee(address involvee, uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n    LibFastHistory.Data storage s = LibFastHistory.data();\\n    uint256[] storage collection  = s.transferProofInvolvements[involvee];\\n    uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n    LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\\n    for (uint256 i = 0; i < length; i++) {\\n      values[i] = s.transferProofs[collection[cursor + i]];\\n    }\\n    return (values, cursor + length);\\n  }\\n}\\n\",\"keccak256\":\"0x5596e26868dce38659495b3acddbaec7045698d0ecc9039f1170c5a9f1e21cb1\",\"license\":\"MIT\"},\"contracts/fast/FastTokenFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../interfaces/IERC20.sol';\\nimport '../interfaces/IERC1404.sol';\\nimport '../lib/LibDiamond.sol';\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport './FastAccessFacet.sol';\\nimport './FastHistoryFacet.sol';\\nimport './lib/AFastFacet.sol';\\n\\n\\ncontract FastTokenFacet is AFastFacet, IERC20, IERC1404 {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Constants.\\n\\n  // Restriction codes.\\n  uint8 private constant INSUFFICIENT_TRANSFER_CREDITS_CODE = 1;\\n  uint8 private constant REQUIRES_FAST_MEMBERSHIP_CODE = 2;\\n  uint8 private constant REQUIRES_EXCHANGE_MEMBERSHIP_CODE = 3;\\n  uint8 private constant REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE = 4;\\n\\n  // Events.\\n\\n  event Minted(uint256 indexed amount, string indexed ref);\\n  event Burnt(uint256 indexed amount, string indexed ref);\\n\\n  event TransferCreditsAdded(address indexed spcMember, uint256 amount);\\n  event TransferCreditsDrained(address indexed spcMember, uint256 amount);\\n\\n  event Disapproval(address indexed owner, address indexed spender);\\n\\n  // Public functions.\\n\\n  function isSemiPublic()\\n      external view returns(bool) {\\n    return LibFastToken.data().isSemiPublic;\\n  }\\n\\n  function setIsSemiPublic(bool flag)\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // Someone is trying to toggle back to private?... No can do!isSemiPublic\\n    require(!s.isSemiPublic || s.isSemiPublic == flag, LibConstants.UNSUPPORTED_OPERATION);\\n    s.isSemiPublic = flag;\\n  }\\n\\n  function hasFixedSupply()\\n      external view returns(bool) {\\n    return LibFastToken.data().hasFixedSupply;\\n  }\\n\\n  function setHasFixedSupply(bool flag)\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.data().hasFixedSupply = flag;\\n  }\\n\\n  /// Minting methods.\\n\\n  function mint(uint256 amount, string calldata ref)\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // We want to make sure that either of these two is true:\\n    // - The token doesn't have fixed supply.\\n    // - The token has fixed supply but has no tokens yet (First and only mint).\\n    require(\\n      !s.hasFixedSupply || (s.totalSupply == 0 && balanceOf(address(0)) == 0),\\n      LibConstants.REQUIRES_CONTINUOUS_SUPPLY\\n    );\\n\\n    // Prepare the minted amount on the zero address.\\n    s.balances[address(0)] += amount;\\n\\n    // Keep track of the minting operation.\\n    FastHistoryFacet(address(this)).minted(amount, ref);\\n\\n    // Emit!\\n    emit Minted(amount, ref);\\n  }\\n\\n  function burn(uint256 amount, string calldata ref)\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    require(!s.hasFixedSupply, LibConstants.REQUIRES_CONTINUOUS_SUPPLY);\\n    require(balanceOf(address(0)) >= amount, LibConstants.INSUFFICIENT_FUNDS);\\n\\n    // Remove the minted amount from the zero address.\\n    s.balances[address(0)] -= amount;\\n\\n    // Keep track of the minting operation.\\n    FastHistoryFacet(address(this)).burnt(amount, ref);\\n\\n    // Emit!\\n    emit Burnt(amount, ref);\\n  }\\n\\n  /// Tranfer Credit management.\\n\\n  function transferCredits()\\n      external view returns(uint256) {\\n    return LibFastToken.data().transferCredits;\\n  }\\n\\n  function addTransferCredits(uint256 amount)\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.data().transferCredits += amount;\\n    emit TransferCreditsAdded(msg.sender, amount);\\n  }\\n\\n  function drainTransferCredits()\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    emit TransferCreditsDrained(msg.sender, s.transferCredits);\\n    s.transferCredits = 0;\\n  }\\n\\n  /// ERC20 implementation and transfer related methods.\\n\\n  function name()\\n      external view returns(string memory) {\\n    return LibFastToken.data().name;\\n  }\\n\\n  function symbol()\\n      external view returns(string memory) {\\n    return LibFastToken.data().symbol;\\n  }\\n\\n  function decimals()\\n      external view returns(uint256) {\\n    return LibFastToken.data().decimals;\\n  }\\n\\n  function totalSupply()\\n      external override view returns(uint256) {\\n    return LibFastToken.data().totalSupply;\\n  }\\n\\n  function balanceOf(address owner)\\n      public view override returns(uint256) {\\n    return LibFastToken.data().balances[owner];\\n  }\\n\\n  function transfer(address to, uint256 amount)\\n      external override returns(bool) {\\n    _transfer(msg.sender, msg.sender, to, amount, 'Unspecified - via ERC20');\\n    return true;\\n  }\\n\\n  function transferWithRef(address to, uint256 amount, string memory ref)\\n      external {\\n    return _transfer(msg.sender, msg.sender, to, amount, ref);\\n  }\\n\\n  function allowance(address owner, address spender)\\n      public view override returns(uint256) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // If the allowance being queried is from the zero address and the spender\\n    // is a governor, we want to make sure that the spender has full rights over it.\\n    if (owner == address(0) && FastAccessFacet(address(this)).isGovernor(spender)) {\\n      return s.balances[address(0)];\\n   } else {\\n      return s.allowances[owner][spender];\\n    }\\n  }\\n\\n  function approve(address spender, uint256 amount)\\n      external override\\n      membership(msg.sender)\\n      returns(bool) {\\n    _approve(msg.sender, spender, amount);\\n    return true;\\n  }\\n\\n  function disapprove(address spender)\\n      external\\n      membership(msg.sender) {\\n    _disapprove(msg.sender, spender);\\n  }\\n\\n  function transferFrom(address from, address to, uint256 amount)\\n      external override returns(bool) {\\n    transferFromWithRef(from, to, amount, 'Unspecified - via ERC20');\\n    return true;\\n  }\\n\\n  function transferFromWithRef(address from, address to, uint256 amount, string memory ref)\\n      public {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // If the funds are coming from the zero address, we must be a governor.\\n    if (from == address(0)) {\\n      require(FastAccessFacet(address(this)).isGovernor(msg.sender), LibConstants.REQUIRES_FAST_GOVERNORSHIP);\\n    } else {\\n      require(allowance(from, msg.sender) >= amount, LibConstants.INSUFFICIENT_ALLOWANCE);\\n\\n      // Only decrease allowances if the sender of the funds isn't the zero address.\\n      uint256 newAllowance = s.allowances[from][msg.sender] -= amount;\\n      // If the allowance reached zero, we want to remove that allowance from\\n      // the various other places where we keep track of them.\\n      if (newAllowance == 0) {\\n        s.allowancesByOwner[from].remove(msg.sender, true);\\n        s.allowancesBySpender[msg.sender].remove(from, true);\\n      }\\n    }\\n\\n    _transfer(msg.sender, from, to, amount, ref);\\n  }\\n\\n  /// Allowances query operations.\\n\\n  function givenAllowanceCount(address owner)\\n      external view returns(uint256) {\\n    return LibFastToken.data().allowancesByOwner[owner].values.length;\\n  }\\n\\n  function paginateAllowancesByOwner(address owner, uint256 index, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastToken.data().allowancesByOwner[owner].values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  function receivedAllowanceCount(address spender)\\n      external view returns(uint256) {\\n    return LibFastToken.data().allowancesBySpender[spender].values.length;\\n  }\\n\\n  function paginateAllowancesBySpender(address spender, uint256 index, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastToken.data().allowancesBySpender[spender].values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  /// ERC1404 implementation.\\n\\n  function detectTransferRestriction(address from, address to, uint256 amount)\\n      external view override returns(uint8) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    if (s.transferCredits < amount) {\\n      return INSUFFICIENT_TRANSFER_CREDITS_CODE;\\n    } else if (!FastAccessFacet(address(this)).isMember(from) ||\\n               !FastAccessFacet(address(this)).isMember(to)) {\\n      return s.isSemiPublic\\n        ? REQUIRES_EXCHANGE_MEMBERSHIP_CODE\\n        : REQUIRES_FAST_MEMBERSHIP_CODE;\\n    } else if (from == to) {\\n      return REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE;\\n    }\\n    return 0;\\n  }\\n\\n  function messageForTransferRestriction(uint8 restrictionCode)\\n      external override pure returns(string memory) {\\n    if (restrictionCode == INSUFFICIENT_TRANSFER_CREDITS_CODE) {\\n      return LibConstants.INSUFFICIENT_TRANSFER_CREDITS;\\n    } else if (restrictionCode == REQUIRES_EXCHANGE_MEMBERSHIP_CODE) {\\n      return LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP;\\n    } else if (restrictionCode == REQUIRES_FAST_MEMBERSHIP_CODE) {\\n      return LibConstants.REQUIRES_FAST_MEMBERSHIP;\\n    } else if (restrictionCode == REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE) {\\n      return LibConstants.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT;\\n    }\\n    revert(LibConstants.UNKNOWN_RESTRICTION_CODE);\\n  }\\n\\n  // Private.\\n\\n  function _transfer(address spender, address from, address to, uint256 amount, string memory ref)\\n      private\\n      membershipOrZero(from) membershipOrZero(to) differentAddresses(from, to) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    require(s.balances[from] >= amount, LibConstants.INSUFFICIENT_FUNDS);\\n    require(\\n      from == address(0) ||\\n        s.transferCredits >= amount,\\n      LibConstants.INSUFFICIENT_TRANSFER_CREDITS\\n    );\\n\\n    // Keep track of the balances.\\n    s.balances[from] -= amount;\\n    s.balances[to] += amount;\\n\\n    // If the funds are going to the ZERO address, decrease total supply.\\n    if (to == address(0)) { s.totalSupply -= amount; }\\n    // If the funds are moving from the zero address, increase total supply.\\n    else if (from == address(0)) { s.totalSupply += amount; }\\n\\n    // Keep track of the transfer.\\n    FastHistoryFacet(address(this)).transfered(spender, from, to, amount, ref);\\n\\n    // Emit!\\n    emit IERC20.Transfer(from, to, amount);\\n  }\\n\\n  function _approve(address from, address spender, uint256 amount)\\n      private {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Store allowance...\\n    s.allowances[from][spender] += amount;\\n    // Keep track of given and received allowances.\\n    s.allowancesByOwner[from].add(spender, true);\\n    s.allowancesBySpender[spender].add(from, true);\\n\\n    // Emit!\\n    emit IERC20.Approval(from, spender, amount);\\n  }\\n\\n  function _disapprove(address from, address spender)\\n      private {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Remove allowance.\\n    s.allowances[from][spender] = 0;\\n    s.allowancesByOwner[from].remove(spender, false);\\n    s.allowancesBySpender[spender].remove(from, false);\\n\\n    // Emit!\\n    emit Disapproval(from, spender);\\n  }\\n\\n  /// Callbacks from other contracts.\\n\\n  // WARNING: This function contains two loops. We know that this should never\\n  // happen in solidity. However:\\n  // - In the context of our private chain, gas is cheap.\\n  // - It can only be called by a governor.\\n  function beforeRemovingMember(address member)\\n      external diamondInternal() {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // If there are token at member's address, move them back to the zero address.\\n    {\\n      uint256 balance = balanceOf(member);\\n      if (balance > 0) {\\n        _transfer(address(0), member, address(0), balance, 'Member removal');\\n      }\\n    }\\n\\n    // Remove all given allowances.\\n    {\\n      address[] storage gaData = s.allowancesByOwner[member].values;\\n      while (gaData.length > 0) { _disapprove(member, gaData[0]); }\\n    }\\n\\n    // Remove all received allowances.\\n    {\\n      address[] storage raData = s.allowancesBySpender[member].values;\\n      while (raData.length > 0) { _disapprove(raData[0], member); }\\n    }\\n  }\\n\\n  // Modifiers.\\n\\n  modifier differentAddresses(address a, address b) {\\n    require(a != b, LibConstants.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x07b3b7965ae0eca80446f0215ca0cb695d7d0989f564f9382e8e9d01390f2222\",\"license\":\"MIT\"},\"contracts/fast/FastTopFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibConstants.sol';\\nimport '../lib/LibHelpers.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFast.sol';\\n\\ncontract FastTopFacet is AFastFacet {\\n  // Events.\\n\\n  // Eth provisioning related events.\\n  event EthReceived(address indexed from, uint256 amount);\\n  event EthDrained(address indexed to, uint256 amount);\\n\\n  // Getters.\\n\\n  function spcAddress()\\n      external view returns(address) {\\n    return LibFast.data().spc;\\n  }\\n\\n  function exchangeAddress()\\n      external view returns(address) {\\n    return LibFast.data().exchange;\\n  }\\n\\n  // Provisioning functions.\\n\\n  function provisionWithEth()\\n      external payable {\\n    require(msg.value > 0, LibConstants.MISSING_ATTACHED_ETH);\\n    emit EthReceived(msg.sender, msg.value);\\n  }\\n\\n  function drainEth()\\n      external\\n      spcMembership(msg.sender) {\\n    uint256 amount = payable(address(this)).balance;\\n    payable(msg.sender).transfer(amount);\\n    emit EthDrained(msg.sender, amount);\\n  }\\n\\n  /**\\n  * @dev This function allows contracts of the FAST network to request ETH\\n  * provisioning to arbitrary addresses.\\n  */\\n  function payUpTo(address payable recipient, uint256 amount)\\n      external diamondInternal() {\\n    require(recipient != address(0), LibConstants.REQUIRES_NON_ZERO_ADDRESS);\\n    amount = LibHelpers.upTo(recipient, amount);\\n    // Transfer some eth!\\n    if (amount != 0) { recipient.transfer(amount); }\\n  }\\n}\\n\",\"keccak256\":\"0xc049fba76d7a8d7d937f7816423cac74eb0c79a12a270e95efa33fbe435cace7\",\"license\":\"MIT\"},\"contracts/fast/lib/AFastFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibHelpers.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../../interfaces/IHasMembers.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../lib/LibFast.sol';\\nimport '../lib/LibFastAccess.sol';\\nimport '../lib/LibFastToken.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract AFastFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\\n  modifier diamondInternal() {\\n    require(msg.sender == address(this), LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\\n  modifier diamondOwner() {\\n    require(msg.sender == IERC173(address(this)).owner(), LibConstants.REQUIRES_DIAMOND_OWNERSHIP);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\\n  modifier deployerContract() {\\n    require(msg.sender == LibConstants.DEPLOYER_CONTRACT, LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is **not** a contract.\\n   *  @param a The address to check.\\n   */\\n  modifier nonContract(address a) {\\n    require(!LibHelpers.isContract(a), LibConstants.REQUIRES_NON_CONTRACT_ADDR);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the Exchange.\\n   *  @param a The address to check.\\n   */\\n  modifier exchangeMember(address a) {\\n    require(IHasMembers(LibFast.data().exchange).isMember(a), LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the SPC.\\n   *  @param a The address to check.\\n   */\\n  modifier spcMembership(address a) {\\n    require(IHasMembers(LibFast.data().spc).isMember(a), LibConstants.REQUIRES_SPC_MEMBERSHIP);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a governor of the FAST.\\n   *  @param a The address to check.\\n   */\\n  modifier governance(address a) {\\n    require(LibFastAccess.data().governorSet.contains(a), LibConstants.REQUIRES_FAST_GOVERNORSHIP);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the FAST.\\n   *  @param a The address to check.\\n   */\\n  modifier membership(address a) {\\n    require(LibFastAccess.data().memberSet.contains(a), LibConstants.REQUIRES_FAST_MEMBERSHIP);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the current FAST or the Zero Address.\\n   *  @param a The address to check.\\n   */\\n  modifier membershipOrZero(address a) {\\n    require(\\n      LibFastAccess.data().memberSet.contains(a) ||\\n      (LibFastToken.data().isSemiPublic && IHasMembers(LibFast.data().exchange).isMember(a)) ||\\n        a == address(0),\\n      LibConstants.REQUIRES_FAST_MEMBERSHIP\\n    );\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x66b70f0d092b9488e84c47d35cd4f259bbfabcd27e212a9d2e1a6fdfc361f6c3\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibFast {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev The internal pointer to the SPC contract.\\n    address spc;\\n    /// @dev The internal pointer to the Exchange contract.\\n    address exchange;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x8b155db07484240635af56d629dbc7827ed126db9119c16d2d139fb6ad4c1c6f\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastAccess.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\nlibrary LibFastAccess {\\n  // These are from IHasMembers.\\n  event MemberAdded(address indexed member);\\n  event MemberRemoved(address indexed member);\\n  // These are from IHasGovernors.\\n  event GovernorAdded(address indexed governor);\\n  event GovernorRemoved(address indexed governor);\\n\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.Access'):\\n  bytes32 internal constant STORAGE_SLOT = 0x87ed8063ac9ead3b2eb7551ed3d89b29fcbf44d6733084b5c82e95d5120ece9a;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev We hold the list of the FAST governors in there.\\n    LibAddressSet.Data governorSet;\\n    // @dev The FAST members are held in there.\\n    LibAddressSet.Data memberSet;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xae5d13b3662db3727c189c24510bab551acb16946873cbaff0d485211a85d5dd\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastHistory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibFastHistory {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.History'):\\n  bytes32 internal constant STORAGE_SLOT = 0x6bc8b61a9dd5fc049ea98027492a801d74e35fdf4d80d7fecd551a16e88fdbb4;\\n\\n  // Storage structures.\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev All minting proofs are kept here.\\n    SupplyProof[] supplyProofs;\\n    /// @dev All transfer proofs are kept here.\\n    TransferProof[] transferProofs;\\n    /// @dev All transfers indices involving a given address are kept here.\\n    mapping(address => uint256[]) transferProofInvolvements;\\n  }\\n\\n  // Other structures.\\n\\n  /// @dev A minting operation could either be to mint or unmint tokens.\\n  enum SupplyOp { Mint, Burn }\\n\\n  /// @dev Minting operations are recorded for papertrail. This is the structure that keeps track of them.\\n  struct SupplyProof {\\n    SupplyOp op;\\n    uint256 amount;\\n    uint256 blockNumber;\\n    string ref;\\n  }\\n\\n  /// @dev Every transfer in is recorded. This is the structure that keeps track of them.\\n  struct TransferProof {\\n    address spender;\\n    address from;\\n    address to;\\n    uint256 amount;\\n    uint256 blockNumber;\\n    string ref;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xd6af0fc0867dd0259fa6e0797f2b46cffac8a36f0380bf266e3ccf778aeb724c\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibFastToken {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.Token'):\\n  bytes32 internal constant STORAGE_SLOT = 0xb098747b87c5c0e2a32eb9b06725e9bad4263809bcda628ceadc1a686bcb8261;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    // ERC20 related properties for this FAST Token.\\n    string name;\\n    string symbol;\\n    uint256 decimals;\\n    uint256 totalSupply;\\n    // Every time a transfer is executed, the credit decreases by the amount\\n    // of said transfer.\\n    // It becomes impossible to transact once it reaches zero, and must\\n    // be provisioned by an SPC governor.\\n    uint256 transferCredits;\\n    // Whether or not external people can hold and transfer tokens on this FAST.\\n    bool isSemiPublic;\\n    // We have to track whether this token has continuous minting or fixed supply.\\n    bool hasFixedSupply;\\n    // Our members balances are held here.\\n    mapping(address => uint256) balances;\\n    // Allowances are stored here.\\n    mapping(address => mapping(address => uint256)) allowances;\\n    mapping(address => LibAddressSet.Data) allowancesByOwner;\\n    mapping(address => LibAddressSet.Data) allowancesBySpender;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xb75ff5b945e308f7297c365aefadaf382ff31ab7ab5a03eb4dd7a8ec4065cc3e\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0x7aca95eacea757ff86be09ed6f309fde42e402530ac7beae002e3c2586439a01\",\"license\":\"MIT\"},\"contracts/interfaces/IERC1404.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\n/**\\n * @dev Interface of the ERC1404 standard as defined in the EIP.\\n */\\ninterface IERC1404 {\\n  /**\\n   * @dev Returns a transfer restriction error code if the transfer shoudln't be permitted,\\n   *      or otherwise returns zero if everything looks fine.\\n   * @param owner is the account from which the tokens should be transfered.\\n   * @param recipient is the target of the transfer.\\n   * @param amount is the amount to be transfered.\\n   * @return a uint8 error code if a problem was detected, otherwise zero.\\n   */\\n  function detectTransferRestriction(address owner, address recipient, uint256 amount)\\n    external\\n    view\\n    returns (uint8);\\n\\n  /**\\n   * @dev Maps a transfer restriction error code into a human-readable string.\\n   * @param code is the code that should be transformed into a string.\\n   * @return A string that describes the given error code.\\n   */\\n  function messageForTransferRestriction(uint8 code) external pure returns (string memory);\\n}\\n\",\"keccak256\":\"0x9ecaada095d66283dda203f77cdd17d18f82bdf58d6fbe7830fc87aed2a80c38\",\"license\":\"MIT\"},\"contracts/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\",\"keccak256\":\"0x6ab22e74708905d9c31867461fffbd2e24bc6ad094aa1aab39211d99e296ab32\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x506634b62ab640b6cfbc4f1299f93a6475b250ec29072c71ca92907c4f747dce\",\"license\":\"MIT\"},\"contracts/interfaces/IHasGovernors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IHasGovernors {\\n  event GovernorAdded(address indexed governor);\\n  event GovernorRemoved(address indexed governor);\\n\\n  function isGovernor(address a) external view returns(bool);\\n  function governorCount() external view returns(uint256);\\n  function paginateGovernors(uint256 index, uint256 perPage) external view returns(address[] memory, uint256);\\n  function addGovernor(address payable a) external;\\n  function removeGovernor(address a) external;\\n}\\n\",\"keccak256\":\"0x35836b162c19951d87848f098fab3f42b79a0b9f593640e8ad8f2f2fa5b74d25\",\"license\":\"MIT\"},\"contracts/interfaces/IHasMembers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IHasMembers {\\n  event MemberAdded(address indexed member);\\n  event MemberRemoved(address indexed member);\\n\\n  function isMember(address a) external view returns(bool);\\n  function memberCount() external view returns(uint256);\\n  function paginateMembers(uint256 index, uint256 perPage) external view returns(address[] memory, uint256);\\n  function addMember(address payable a) external;\\n  function removeMember(address a) external;\\n}\\n\",\"keccak256\":\"0xab0d7cfb46a5a70bd13783d959df2e8f593269472994ea828273fa563a4c0c39\",\"license\":\"MIT\"},\"contracts/lib/LibAddressSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibAddressSet {\\n  /// @dev Represents a list of addresses.\\n  struct Data {\\n    mapping(address => uint256) indices;\\n    address[] values;\\n  }\\n\\n  /**\\n   * @dev Adds an item into the storage set. If the address already exists in the\\n   *      set, the function reverts.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to be added.\\n   */\\n  function add(Data storage d, address key, bool noThrow)\\n      internal {\\n    bool exists = contains(d, key);\\n    if (noThrow && exists) { return; }\\n    require(!exists, 'Address already in set');\\n    d.indices[key] = d.values.length;\\n    d.values.push(key);\\n  }\\n\\n  /**\\n   * @dev Removes an item from the storage set. If the address does not exist in the\\n   *      set, the function reverts.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to be removed.\\n   */\\n  function remove(Data storage d, address key, bool noThrow)\\n      internal {\\n    bool exists = contains(d, key);\\n    if (noThrow && !exists) { return; }\\n    require(exists, 'Address does not exist in set');\\n    uint256 lastIndex = d.values.length - 1;\\n    address keyToMove = d.values[lastIndex];\\n    uint256 idxToReplace = d.indices[key];\\n    d.indices[keyToMove] = idxToReplace;\\n    d.values[idxToReplace] = keyToMove;\\n    delete d.indices[key];\\n    d.values.pop();\\n  }\\n\\n  /**\\n   * @dev Tests whether or not a given item already exists in the set.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to test.\\n   * @return a boolean.\\n   */\\n  function contains(Data storage d, address key)\\n      internal view returns(bool) {\\n    return d.values.length == 0\\n      ? false\\n      : d.values[d.indices[key]] == key;\\n  }\\n}\\n\",\"keccak256\":\"0x7daf050d0864e085c227521b1157b4ea652fe75ea7e10f685027b42d6e1caf87\",\"license\":\"MIT\"},\"contracts/lib/LibConstants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibConstants {\\n  address internal constant ZERO_ADDRESS = address(0);\\n  address internal constant DEPLOYER_CONTRACT = 0x6DF2D25d8C6FD680730ee658b530A05a99BB769a;\\n\\n  string internal constant INTERNAL_METHOD = 'Internal method';\\n  string internal constant REQUIRES_DIAMOND_OWNERSHIP = 'Requires diamond ownership';\\n  string internal constant REQUIRES_FAST_CONTRACT_CALLER = 'Caller must be a FAST contract';\\n  string internal constant REQUIRES_NO_FAST_MEMBERSHIPS = 'Member still part of at least one FAST';\\n\\n  string internal constant REQUIRES_SPC_MEMBERSHIP = 'Requires SPC membership';\\n  string internal constant REQUIRES_EXCHANGE_MEMBERSHIP = 'Requires Exchange membership';\\n  string internal constant REQUIRES_FAST_GOVERNORSHIP = 'Requires FAST governorship';\\n  string internal constant REQUIRES_FAST_MEMBERSHIP = 'Requires FAST membership';\\n\\n  string internal constant DUPLICATE_ENTRY = 'Duplicate entry';\\n  string internal constant UNSUPPORTED_OPERATION = 'Unsupported operation';\\n  string internal constant REQUIRES_NON_ZERO_ADDRESS = 'Requires non-zero address';\\n  string internal constant REQUIRES_NON_CONTRACT_ADDR = 'Address cannot be a contract';\\n\\n  string internal constant MISSING_ATTACHED_ETH = 'Missing attached ETH';\\n  string internal constant REQUIRES_CONTINUOUS_SUPPLY = 'Requires continuous supply';\\n  string internal constant INSUFFICIENT_FUNDS = 'Insufficient token balance';\\n  string internal constant INSUFFICIENT_ALLOWANCE = 'Insufficient allowance';\\n  string internal constant INSUFFICIENT_TRANSFER_CREDITS = 'Insufficient transfer credits';\\n  string internal constant REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT = 'Requires different sender and recipient';\\n  string internal constant UNKNOWN_RESTRICTION_CODE = 'Unknown restriction code';\\n}\\n\",\"keccak256\":\"0x07122b717a522632f20b4bb1d397428df14a12511eea4893ae16a77ecb6d011f\",\"license\":\"MIT\"},\"contracts/lib/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x1c1bcc2f4ce958b3569ec95530879a584e4cf837d585a5059b3b612ad4a71a47\",\"license\":\"MIT\"},\"contracts/lib/LibHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nlibrary LibHelpers {\\n  function upTo(address payable to, uint256 amount)\\n      internal view returns(uint256) {\\n    // If the recipient has more than what is ought to be paid, return.\\n    uint256 toBalance = to.balance;\\n    if (toBalance >= amount) { return 0; }\\n    // If the recipient has some Eth we should only pay the top-up.\\n    amount = amount - toBalance;\\n    // If the available eth is less than what we should pay, just cap it.\\n    uint256 available = payable(address(this)).balance;\\n    if (available < amount) { amount = available; }\\n    // Provision the new fast with Eth.\\n    return amount;\\n  }\\n\\n  function isContract(address target)\\n      internal view returns (bool) {\\n    uint32 size;\\n    assembly { size := extcodesize(target) }\\n    return (size > 0);\\n  }\\n}\\n\",\"keccak256\":\"0xa3ac21d8e6e5f25d9125d2975e7157e5c660bd481fb102c39a64810955d6eaab\",\"license\":\"MIT\"},\"contracts/lib/LibPaginate.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../fast/lib/LibFastHistory.sol';\\n\\n\\nlibrary LibPaginate {\\n  function addresses(address[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(address[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      address[] memory values = new address[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function uint256s(uint256[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(uint256[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      uint256[] memory values = new uint256[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function supplyProofs(LibFastHistory.SupplyProof[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(LibFastHistory.SupplyProof[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      LibFastHistory.SupplyProof[] memory values = new LibFastHistory.SupplyProof[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function transferProofs(LibFastHistory.TransferProof[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n}\",\"keccak256\":\"0xedbf24531aa1b21a17a7962b2053fe1bd81ddf9e8869f508f14f7fb9087631d9\",\"license\":\"MIT\"},\"contracts/spc/SpcTopFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../lib/LibHelpers.sol';\\nimport '../interfaces/IHasMembers.sol';\\nimport '../fast/FastTopFacet.sol';\\nimport '../fast/FastTokenFacet.sol';\\nimport './lib/ASpcFacet.sol';\\nimport './lib/LibSpc.sol';\\n\\n\\n/** @title The SPC Smart Contract.\\n *  @dev The SPC contract is the central place for top-level governorship. It requires that a\\n *        first member address is passed at construction time.\\n */\\ncontract SpcTopFacet is ASpcFacet, IHasMembers {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Constants.\\n\\n  // This represents how much Eth we provision new SPC members with.\\n  uint256 constant private MEMBER_ETH_PROVISION = 10 ether;\\n  // This represents how much Eth new FASTs are provisioned with.\\n  uint256 constant private FAST_ETH_PROVISION = 250 ether;\\n\\n  // Events.\\n\\n  /** @dev Emited when a new FAST is registered.\\n   *  @param fast The address of the newly registered FAST diamond.\\n   */\\n  event FastRegistered(address indexed fast);\\n\\n  /** @dev Emited when someone provisions this SPC with Eth.\\n   *  @param from The sender of the Eth.\\n   *  @param amount The quantity of Eth, expressed in Wei.\\n   */\\n  event EthReceived(address indexed from, uint256 amount);\\n  /** @dev Emited when Eth is drained from this SPC.\\n   *  @param to The caller and recipient of the drained Eth.\\n   *  @param amount The quantity of Eth that was drained, expressed in Wei.\\n   */\\n  event EthDrained(address indexed to, uint256 amount);\\n\\n  // Eth provisioning stuff.\\n\\n  /** @dev A function that alllows provisioning this SPC with Eth.\\n   *  @notice Emits a `EthReceived` event.\\n   */\\n  function provisionWithEth()\\n      external payable {\\n    require(msg.value > 0, LibConstants.MISSING_ATTACHED_ETH);\\n    emit EthReceived(msg.sender, msg.value);\\n  }\\n\\n  /** @dev A function that alllows draining this SPC from its Eth.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `EthDrained` event.\\n   */\\n  function drainEth()\\n      external\\n      membership(msg.sender) {\\n    uint256 amount = payable(address(this)).balance;\\n    payable(msg.sender).transfer(amount);\\n    emit EthDrained(msg.sender, amount);\\n  }\\n\\n  // Membership management.\\n\\n  /** @dev Queries whether a given address is a member of this SPC or not.\\n   *  @param candidate The address to test.\\n   *  @return A `boolean` flag.\\n   */\\n  function isMember(address candidate)\\n      external override view returns(bool) {\\n    return LibSpc.data().memberSet.contains(candidate);\\n  }\\n\\n  /** @dev Counts the numbers of members present in this SPC.\\n   *  @return The number of members in this SPC.\\n   */\\n  function memberCount()\\n      external override view returns(uint256) {\\n    return LibSpc.data().memberSet.values.length;\\n  }\\n\\n  /** @dev Paginates the members of this SPC based on a starting cursor and a number of records per page.\\n   *  @param cursor The index at which to start.\\n   *  @param perPage How many records should be returned at most.\\n   *  @return A `address[]` list of values at most `perPage` big.\\n   *  @return A `uint256` index to the next page.\\n   */\\n  function paginateMembers(uint256 cursor, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibSpc.data().memberSet.values, cursor, perPage);\\n  }\\n\\n  /** @dev Adds a member to this SPC member list.\\n   *  @param member The address of the member to be added.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `IHasMembers.MemberAdded` event.\\n   */\\n  function addMember(address payable member)\\n      external override\\n      membership(msg.sender) {\\n    // Add the member to our list.\\n    LibSpc.data().memberSet.add(member, false);\\n\\n    // Provision the member with some Eth.\\n    uint256 amount = LibHelpers.upTo(member, MEMBER_ETH_PROVISION);\\n    if (amount != 0) { member.transfer(amount); }\\n\\n    // Emit!\\n    emit IHasMembers.MemberAdded(member);\\n  }\\n\\n  /** @dev Removes a member from this SPC.\\n   *  @param member The address of the member to be removed.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `IHasMembers.MemberRemoved` event.\\n   */\\n  function removeMember(address member)\\n      external override\\n      membership(msg.sender) {\\n    // No suicide allowed.\\n    require(msg.sender != member, 'Cannot remove self');\\n    // Remove the member from the set.\\n    LibSpc.data().memberSet.remove(member, false);\\n    // Emit!\\n    emit IHasMembers.MemberRemoved(member);\\n  }\\n\\n  // FAST management related methods.\\n\\n  /** @dev Queries whether a given address is a known and registered FAST contract.\\n   * @param fast The address of the contract to check.\\n   * @return A boolean.\\n   */\\n  function isFastRegistered(address fast)\\n      external view returns(bool) {\\n    return LibSpc.data().fastSet.contains(fast);\\n  }\\n\\n  /** @dev Allows to retrieve the address of a FAST diamond given its symbol.\\n   *  @param symbol The symbol of the FAST diamond to get the address of.\\n   *  @return The address of the corresponding FAST diamond, or the Zero Address if not found.\\n   */\\n  function fastBySymbol(string calldata symbol)\\n      external view returns(address) {\\n    return LibSpc.data().fastSymbols[symbol];\\n  }\\n\\n  /** @dev Allows the registration of a given FAST diamond with this SPC.\\n   *  @param fast The address of the FAST diamond to be registered.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `FastRegistered` event.\\n   */\\n  function registerFast(address fast)\\n      external\\n      membership(msg.sender) {\\n    LibSpc.Data storage s = LibSpc.data();\\n    string memory symbol = FastTokenFacet(fast).symbol();\\n    require(s.fastSymbols[symbol] == address(0), LibConstants.DUPLICATE_ENTRY);\\n\\n    // Add the FAST to our list.\\n    s.fastSet.add(fast, false);\\n    // Add the fast symbol to our list.\\n    s.fastSymbols[symbol] = fast;\\n\\n    // Provision the new fast with Eth.\\n    uint256 amount = LibHelpers.upTo(payable(fast), FAST_ETH_PROVISION);\\n    // Only provision the fast if possible.\\n    if (amount > 0) {\\n      FastTopFacet(fast).provisionWithEth{ value: amount }();\\n    }\\n    // Emit!\\n    emit FastRegistered(fast);\\n  }\\n\\n  /** @dev Counts the number of FAST diamonds registered with this SPC.\\n   *  @return The number of FAST diamonds registered with this SPC.\\n   */\\n  function fastCount()\\n      external view returns(uint256) {\\n    return LibSpc.data().fastSet.values.length;\\n  }\\n\\n  /** @dev Paginates the FAST diamonds registered with this SPC based on a starting cursor and a number of records per page.\\n   *  @param cursor The index at which to start.\\n   *  @param perPage How many records should be returned at most.\\n   *  @return A `address[]` list of values at most `perPage` big.\\n   *  @return A `uint256` index to the next page.\\n   */\\n  function paginateFasts(uint256 cursor, uint256 perPage)\\n      external view\\n      returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibSpc.data().fastSet.values, cursor, perPage);\\n  }\\n}\\n\",\"keccak256\":\"0x3b549112526d2dd82ce4ab879ba940a9f7f512e026cdee91a6dc6d9534fe29cb\",\"license\":\"MIT\"},\"contracts/spc/lib/ASpcFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../lib/LibSpc.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract ASpcFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\\n  modifier diamondInternal() {\\n    require(msg.sender == address(this), LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\\n  modifier diamondOwner() {\\n    require(msg.sender == IERC173(address(this)).owner(), LibConstants.REQUIRES_DIAMOND_OWNERSHIP);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\\n  modifier deployerContract() {\\n    require(msg.sender == LibConstants.DEPLOYER_CONTRACT, LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /// @dev Ensures that the given address is a member of the current FAST.\\n  modifier membership(address a) {\\n    require(LibSpc.data().memberSet.contains(a), LibConstants.REQUIRES_SPC_MEMBERSHIP);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x61e5365b6a0491b38d1f3bd59af0b2c882681b471dc86039698c734a212757f6\",\"license\":\"MIT\"},\"contracts/spc/lib/LibSpc.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibSpc {\\n  // These are from IHasMembers.\\n  event MemberAdded(address indexed member);\\n\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Spc.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x89a652f66ca129ef71cab44916bb070742a08af428e08a99df145c8006c94285;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    // This is where we hold our members data.\\n    LibAddressSet.Data memberSet;\\n    // This is where we keep our list of deployed fast FASTs.\\n    LibAddressSet.Data fastSet;\\n    // We keep track of the FAST symbols that were already used.\\n    mapping(string => address) fastSymbols;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x95acfb97e7269758dfaac36bac10782b6a6bb17c75d151c2c4fdea0fbeaa1a67\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50611bee806100206000396000f3fe6080604052600436106100a75760003560e01c806341d7c02d1161006457806341d7c02d14610189578063654eebcb146101c65780638201d206146101ef578063a230c5241461022d578063c6549ba41461026a578063ca6d56dc146102a8576100a7565b80630b1ca49a146100ac5780630baac66f146100d5578063112b24c9146100ec57806311aee38014610117578063164f8e6a146101425780633eca424b1461017f575b600080fd5b3480156100b857600080fd5b506100d360048036038101906100ce9190611442565b6102d1565b005b3480156100e157600080fd5b506100ea61043d565b005b3480156100f857600080fd5b50610101610588565b60405161010e9190611818565b60405180910390f35b34801561012357600080fd5b5061012c6105a1565b6040516101399190611818565b60405180910390f35b34801561014e57600080fd5b5061016960048036038101906101649190611494565b6105ba565b6040516101769190611730565b60405180910390f35b61018761060e565b005b34801561019557600080fd5b506101b060048036038101906101ab9190611442565b6106da565b6040516101bd919061177b565b60405180910390f35b3480156101d257600080fd5b506101ed60048036038101906101e89190611442565b610700565b005b3480156101fb57600080fd5b506102166004803603810190610211919061151a565b610a55565b60405161022492919061174b565b60405180910390f35b34801561023957600080fd5b50610254600480360381019061024f9190611442565b610a7c565b604051610261919061177b565b60405180910390f35b34801561027657600080fd5b50610291600480360381019061028c919061151a565b610aa2565b60405161029f92919061174b565b60405180910390f35b3480156102b457600080fd5b506102cf60048036038101906102ca919061146b565b610ac9565b005b336102ef816102de610c2d565b600101610c5590919063ffffffff16565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610366576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161035d9190611796565b60405180910390fd5b508173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614156103d6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103cd906117b8565b60405180910390fd5b6103f68260006103e4610c2d565b600101610d4b9092919063ffffffff16565b8173ffffffffffffffffffffffffffffffffffffffff167f6e76fb4c77256006d9c38ec7d82b45a8c8f3c27b1d6766fffc42dfb8de68449260405160405180910390a25050565b3361045b8161044a610c2d565b600101610c5590919063ffffffff16565b6040518060400160405280601781526020017f526571756972657320535043206d656d62657273686970000000000000000000815250906104d2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104c99190611796565b60405180910390fd5b5060003073ffffffffffffffffffffffffffffffffffffffff163190503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f19350505050158015610535573d6000803e3d6000fd5b503373ffffffffffffffffffffffffffffffffffffffff167fd5a7a0257eadbfea7ac4432ca8fe62ac277d64736ab6ef67f11abf238a1e0f1a8260405161057c9190611818565b60405180910390a25050565b6000610592610c2d565b60030160010180549050905090565b60006105ab610c2d565b60010160010180549050905090565b60006105c4610c2d565b60050183836040516105d7929190611700565b908152602001604051809103902060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905092915050565b600034116040518060400160405280601481526020017f4d697373696e672061747461636865642045544800000000000000000000000081525090610689576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106809190611796565b60405180910390fd5b503373ffffffffffffffffffffffffffffffffffffffff167f85177f287940f2f05425a4029951af0e047a7f9c4eaa9a6e6917bcd869f86695346040516106d09190611818565b60405180910390a2565b60006106f9826106e8610c2d565b600301610c5590919063ffffffff16565b9050919050565b3361071e8161070d610c2d565b600101610c5590919063ffffffff16565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610795576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161078c9190611796565b60405180910390fd5b5060006107a0610c2d565b905060008373ffffffffffffffffffffffffffffffffffffffff166395d89b416040518163ffffffff1660e01b815260040160006040518083038186803b1580156107ea57600080fd5b505afa1580156107fe573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061082791906114d9565b9050600073ffffffffffffffffffffffffffffffffffffffff1682600501826040516108539190611719565b908152602001604051809103902060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146040518060400160405280600f81526020017f4475706c696361746520656e747279000000000000000000000000000000000081525090610910576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109079190611796565b60405180910390fd5b5061092a846000846003016110019092919063ffffffff16565b83826005018260405161093d9190611719565b908152602001604051809103902060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600061099e85680d8d726b7177a8000061111e565b90506000811115610a0b578473ffffffffffffffffffffffffffffffffffffffff16633eca424b826040518263ffffffff1660e01b81526004016000604051808303818588803b1580156109f157600080fd5b505af1158015610a05573d6000803e3d6000fd5b50505050505b8473ffffffffffffffffffffffffffffffffffffffff167fa393070be795669766b8f40ecaab0724def57650be5914b232c8fb18ca507f3660405160405180910390a25050505050565b60606000610a71610a64610c2d565b600301600101858561118e565b915091509250929050565b6000610a9b82610a8a610c2d565b600101610c5590919063ffffffff16565b9050919050565b60606000610abe610ab1610c2d565b600101600101858561118e565b915091509250929050565b33610ae781610ad6610c2d565b600101610c5590919063ffffffff16565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610b5e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b559190611796565b60405180910390fd5b50610b7f826000610b6d610c2d565b6001016110019092919063ffffffff16565b6000610b9383678ac7230489e8000061111e565b905060008114610be5578273ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f19350505050158015610be3573d6000803e3d6000fd5b505b8273ffffffffffffffffffffffffffffffffffffffff167fb251eb052afc73ffd02ffe85ad79990a8b3fed60d76dbc2fa2fdd7123dffd91460405160405180910390a2505050565b60007f89a652f66ca129ef71cab44916bb070742a08af428e08a99df145c8006c94285905090565b600080836001018054905014610d40578173ffffffffffffffffffffffffffffffffffffffff16836001018460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205481548110610cf9577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610d43565b60005b905092915050565b6000610d578484610c55565b9050818015610d64575080155b15610d6f5750610ffc565b80610daf576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610da6906117f8565b60405180910390fd5b600060018560010180549050610dc5919061193f565b90506000856001018281548110610e05577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060008660000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050808760000160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555081876001018281548110610efb577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508660000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000905586600101805480610fc2577f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b6001900381819060005260206000200160006101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690559055505050505b505050565b600061100d8484610c55565b90508180156110195750805b156110245750611119565b8015611065576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161105c906117d8565b60405180910390fd5b83600101805490508460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555083600101839080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505b505050565b6000808373ffffffffffffffffffffffffffffffffffffffff1631905082811061114c576000915050611188565b8083611158919061193f565b925060003073ffffffffffffffffffffffffffffffffffffffff1631905083811015611182578093505b83925050505b92915050565b60606000808486805490506111a3919061193f565b84116111af57836111c0565b8486805490506111bf919061193f565b5b905060008167ffffffffffffffff811115611204577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280602002602001820160405280156112325781602001602082028036833780820191505090505b50905060005b828110156113355787818861124d91906118e9565b81548110611284577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168282815181106112e8577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050808061132d90611a40565b915050611238565b5080828761134391906118e9565b935093505050935093915050565b600061136461135f84611858565b611833565b90508281526020810184848401111561137c57600080fd5b6113878482856119dc565b509392505050565b60008135905061139e81611b73565b92915050565b6000813590506113b381611b8a565b92915050565b60008083601f8401126113cb57600080fd5b8235905067ffffffffffffffff8111156113e457600080fd5b6020830191508360018202830111156113fc57600080fd5b9250929050565b600082601f83011261141457600080fd5b8151611424848260208601611351565b91505092915050565b60008135905061143c81611ba1565b92915050565b60006020828403121561145457600080fd5b60006114628482850161138f565b91505092915050565b60006020828403121561147d57600080fd5b600061148b848285016113a4565b91505092915050565b600080602083850312156114a757600080fd5b600083013567ffffffffffffffff8111156114c157600080fd5b6114cd858286016113b9565b92509250509250929050565b6000602082840312156114eb57600080fd5b600082015167ffffffffffffffff81111561150557600080fd5b61151184828501611403565b91505092915050565b6000806040838503121561152d57600080fd5b600061153b8582860161142d565b925050602061154c8582860161142d565b9150509250929050565b6000611562838361156e565b60208301905092915050565b61157781611973565b82525050565b61158681611973565b82525050565b600061159782611899565b6115a181856118bc565b93506115ac83611889565b8060005b838110156115dd5781516115c48882611556565b97506115cf836118af565b9250506001810190506115b0565b5085935050505092915050565b6115f381611997565b82525050565b600061160583856118de565b93506116128385846119cd565b82840190509392505050565b6000611629826118a4565b61163381856118cd565b93506116438185602086016119dc565b61164c81611ae7565b840191505092915050565b6000611662826118a4565b61166c81856118de565b935061167c8185602086016119dc565b80840191505092915050565b60006116956012836118cd565b91506116a082611af8565b602082019050919050565b60006116b86016836118cd565b91506116c382611b21565b602082019050919050565b60006116db601d836118cd565b91506116e682611b4a565b602082019050919050565b6116fa816119c3565b82525050565b600061170d8284866115f9565b91508190509392505050565b60006117258284611657565b915081905092915050565b6000602082019050611745600083018461157d565b92915050565b60006040820190508181036000830152611765818561158c565b905061177460208301846116f1565b9392505050565b600060208201905061179060008301846115ea565b92915050565b600060208201905081810360008301526117b0818461161e565b905092915050565b600060208201905081810360008301526117d181611688565b9050919050565b600060208201905081810360008301526117f1816116ab565b9050919050565b60006020820190508181036000830152611811816116ce565b9050919050565b600060208201905061182d60008301846116f1565b92915050565b600061183d61184e565b90506118498282611a0f565b919050565b6000604051905090565b600067ffffffffffffffff82111561187357611872611ab8565b5b61187c82611ae7565b9050602081019050919050565b6000819050602082019050919050565b600081519050919050565b600081519050919050565b6000602082019050919050565b600082825260208201905092915050565b600082825260208201905092915050565b600081905092915050565b60006118f4826119c3565b91506118ff836119c3565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0382111561193457611933611a89565b5b828201905092915050565b600061194a826119c3565b9150611955836119c3565b92508282101561196857611967611a89565b5b828203905092915050565b600061197e826119a3565b9050919050565b6000611990826119a3565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b82818337600083830152505050565b60005b838110156119fa5780820151818401526020810190506119df565b83811115611a09576000848401525b50505050565b611a1882611ae7565b810181811067ffffffffffffffff82111715611a3757611a36611ab8565b5b80604052505050565b6000611a4b826119c3565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415611a7e57611a7d611a89565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000601f19601f8301169050919050565b7f43616e6e6f742072656d6f76652073656c660000000000000000000000000000600082015250565b7f4164647265737320616c726561647920696e2073657400000000000000000000600082015250565b7f4164647265737320646f6573206e6f7420657869737420696e20736574000000600082015250565b611b7c81611973565b8114611b8757600080fd5b50565b611b9381611985565b8114611b9e57600080fd5b50565b611baa816119c3565b8114611bb557600080fd5b5056fea2646970667358221220cb76ad3e56645ba6c7fda77ede312043ae4cf431107f64b2e6e642a10164149b64736f6c63430008040033",
  "deployedBytecode": "0x6080604052600436106100a75760003560e01c806341d7c02d1161006457806341d7c02d14610189578063654eebcb146101c65780638201d206146101ef578063a230c5241461022d578063c6549ba41461026a578063ca6d56dc146102a8576100a7565b80630b1ca49a146100ac5780630baac66f146100d5578063112b24c9146100ec57806311aee38014610117578063164f8e6a146101425780633eca424b1461017f575b600080fd5b3480156100b857600080fd5b506100d360048036038101906100ce9190611442565b6102d1565b005b3480156100e157600080fd5b506100ea61043d565b005b3480156100f857600080fd5b50610101610588565b60405161010e9190611818565b60405180910390f35b34801561012357600080fd5b5061012c6105a1565b6040516101399190611818565b60405180910390f35b34801561014e57600080fd5b5061016960048036038101906101649190611494565b6105ba565b6040516101769190611730565b60405180910390f35b61018761060e565b005b34801561019557600080fd5b506101b060048036038101906101ab9190611442565b6106da565b6040516101bd919061177b565b60405180910390f35b3480156101d257600080fd5b506101ed60048036038101906101e89190611442565b610700565b005b3480156101fb57600080fd5b506102166004803603810190610211919061151a565b610a55565b60405161022492919061174b565b60405180910390f35b34801561023957600080fd5b50610254600480360381019061024f9190611442565b610a7c565b604051610261919061177b565b60405180910390f35b34801561027657600080fd5b50610291600480360381019061028c919061151a565b610aa2565b60405161029f92919061174b565b60405180910390f35b3480156102b457600080fd5b506102cf60048036038101906102ca919061146b565b610ac9565b005b336102ef816102de610c2d565b600101610c5590919063ffffffff16565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610366576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161035d9190611796565b60405180910390fd5b508173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614156103d6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103cd906117b8565b60405180910390fd5b6103f68260006103e4610c2d565b600101610d4b9092919063ffffffff16565b8173ffffffffffffffffffffffffffffffffffffffff167f6e76fb4c77256006d9c38ec7d82b45a8c8f3c27b1d6766fffc42dfb8de68449260405160405180910390a25050565b3361045b8161044a610c2d565b600101610c5590919063ffffffff16565b6040518060400160405280601781526020017f526571756972657320535043206d656d62657273686970000000000000000000815250906104d2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104c99190611796565b60405180910390fd5b5060003073ffffffffffffffffffffffffffffffffffffffff163190503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f19350505050158015610535573d6000803e3d6000fd5b503373ffffffffffffffffffffffffffffffffffffffff167fd5a7a0257eadbfea7ac4432ca8fe62ac277d64736ab6ef67f11abf238a1e0f1a8260405161057c9190611818565b60405180910390a25050565b6000610592610c2d565b60030160010180549050905090565b60006105ab610c2d565b60010160010180549050905090565b60006105c4610c2d565b60050183836040516105d7929190611700565b908152602001604051809103902060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905092915050565b600034116040518060400160405280601481526020017f4d697373696e672061747461636865642045544800000000000000000000000081525090610689576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106809190611796565b60405180910390fd5b503373ffffffffffffffffffffffffffffffffffffffff167f85177f287940f2f05425a4029951af0e047a7f9c4eaa9a6e6917bcd869f86695346040516106d09190611818565b60405180910390a2565b60006106f9826106e8610c2d565b600301610c5590919063ffffffff16565b9050919050565b3361071e8161070d610c2d565b600101610c5590919063ffffffff16565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610795576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161078c9190611796565b60405180910390fd5b5060006107a0610c2d565b905060008373ffffffffffffffffffffffffffffffffffffffff166395d89b416040518163ffffffff1660e01b815260040160006040518083038186803b1580156107ea57600080fd5b505afa1580156107fe573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061082791906114d9565b9050600073ffffffffffffffffffffffffffffffffffffffff1682600501826040516108539190611719565b908152602001604051809103902060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146040518060400160405280600f81526020017f4475706c696361746520656e747279000000000000000000000000000000000081525090610910576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109079190611796565b60405180910390fd5b5061092a846000846003016110019092919063ffffffff16565b83826005018260405161093d9190611719565b908152602001604051809103902060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600061099e85680d8d726b7177a8000061111e565b90506000811115610a0b578473ffffffffffffffffffffffffffffffffffffffff16633eca424b826040518263ffffffff1660e01b81526004016000604051808303818588803b1580156109f157600080fd5b505af1158015610a05573d6000803e3d6000fd5b50505050505b8473ffffffffffffffffffffffffffffffffffffffff167fa393070be795669766b8f40ecaab0724def57650be5914b232c8fb18ca507f3660405160405180910390a25050505050565b60606000610a71610a64610c2d565b600301600101858561118e565b915091509250929050565b6000610a9b82610a8a610c2d565b600101610c5590919063ffffffff16565b9050919050565b60606000610abe610ab1610c2d565b600101600101858561118e565b915091509250929050565b33610ae781610ad6610c2d565b600101610c5590919063ffffffff16565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610b5e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b559190611796565b60405180910390fd5b50610b7f826000610b6d610c2d565b6001016110019092919063ffffffff16565b6000610b9383678ac7230489e8000061111e565b905060008114610be5578273ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f19350505050158015610be3573d6000803e3d6000fd5b505b8273ffffffffffffffffffffffffffffffffffffffff167fb251eb052afc73ffd02ffe85ad79990a8b3fed60d76dbc2fa2fdd7123dffd91460405160405180910390a2505050565b60007f89a652f66ca129ef71cab44916bb070742a08af428e08a99df145c8006c94285905090565b600080836001018054905014610d40578173ffffffffffffffffffffffffffffffffffffffff16836001018460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205481548110610cf9577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610d43565b60005b905092915050565b6000610d578484610c55565b9050818015610d64575080155b15610d6f5750610ffc565b80610daf576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610da6906117f8565b60405180910390fd5b600060018560010180549050610dc5919061193f565b90506000856001018281548110610e05577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060008660000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050808760000160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555081876001018281548110610efb577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508660000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000905586600101805480610fc2577f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b6001900381819060005260206000200160006101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690559055505050505b505050565b600061100d8484610c55565b90508180156110195750805b156110245750611119565b8015611065576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161105c906117d8565b60405180910390fd5b83600101805490508460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555083600101839080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505b505050565b6000808373ffffffffffffffffffffffffffffffffffffffff1631905082811061114c576000915050611188565b8083611158919061193f565b925060003073ffffffffffffffffffffffffffffffffffffffff1631905083811015611182578093505b83925050505b92915050565b60606000808486805490506111a3919061193f565b84116111af57836111c0565b8486805490506111bf919061193f565b5b905060008167ffffffffffffffff811115611204577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280602002602001820160405280156112325781602001602082028036833780820191505090505b50905060005b828110156113355787818861124d91906118e9565b81548110611284577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168282815181106112e8577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050808061132d90611a40565b915050611238565b5080828761134391906118e9565b935093505050935093915050565b600061136461135f84611858565b611833565b90508281526020810184848401111561137c57600080fd5b6113878482856119dc565b509392505050565b60008135905061139e81611b73565b92915050565b6000813590506113b381611b8a565b92915050565b60008083601f8401126113cb57600080fd5b8235905067ffffffffffffffff8111156113e457600080fd5b6020830191508360018202830111156113fc57600080fd5b9250929050565b600082601f83011261141457600080fd5b8151611424848260208601611351565b91505092915050565b60008135905061143c81611ba1565b92915050565b60006020828403121561145457600080fd5b60006114628482850161138f565b91505092915050565b60006020828403121561147d57600080fd5b600061148b848285016113a4565b91505092915050565b600080602083850312156114a757600080fd5b600083013567ffffffffffffffff8111156114c157600080fd5b6114cd858286016113b9565b92509250509250929050565b6000602082840312156114eb57600080fd5b600082015167ffffffffffffffff81111561150557600080fd5b61151184828501611403565b91505092915050565b6000806040838503121561152d57600080fd5b600061153b8582860161142d565b925050602061154c8582860161142d565b9150509250929050565b6000611562838361156e565b60208301905092915050565b61157781611973565b82525050565b61158681611973565b82525050565b600061159782611899565b6115a181856118bc565b93506115ac83611889565b8060005b838110156115dd5781516115c48882611556565b97506115cf836118af565b9250506001810190506115b0565b5085935050505092915050565b6115f381611997565b82525050565b600061160583856118de565b93506116128385846119cd565b82840190509392505050565b6000611629826118a4565b61163381856118cd565b93506116438185602086016119dc565b61164c81611ae7565b840191505092915050565b6000611662826118a4565b61166c81856118de565b935061167c8185602086016119dc565b80840191505092915050565b60006116956012836118cd565b91506116a082611af8565b602082019050919050565b60006116b86016836118cd565b91506116c382611b21565b602082019050919050565b60006116db601d836118cd565b91506116e682611b4a565b602082019050919050565b6116fa816119c3565b82525050565b600061170d8284866115f9565b91508190509392505050565b60006117258284611657565b915081905092915050565b6000602082019050611745600083018461157d565b92915050565b60006040820190508181036000830152611765818561158c565b905061177460208301846116f1565b9392505050565b600060208201905061179060008301846115ea565b92915050565b600060208201905081810360008301526117b0818461161e565b905092915050565b600060208201905081810360008301526117d181611688565b9050919050565b600060208201905081810360008301526117f1816116ab565b9050919050565b60006020820190508181036000830152611811816116ce565b9050919050565b600060208201905061182d60008301846116f1565b92915050565b600061183d61184e565b90506118498282611a0f565b919050565b6000604051905090565b600067ffffffffffffffff82111561187357611872611ab8565b5b61187c82611ae7565b9050602081019050919050565b6000819050602082019050919050565b600081519050919050565b600081519050919050565b6000602082019050919050565b600082825260208201905092915050565b600082825260208201905092915050565b600081905092915050565b60006118f4826119c3565b91506118ff836119c3565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0382111561193457611933611a89565b5b828201905092915050565b600061194a826119c3565b9150611955836119c3565b92508282101561196857611967611a89565b5b828203905092915050565b600061197e826119a3565b9050919050565b6000611990826119a3565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b82818337600083830152505050565b60005b838110156119fa5780820151818401526020810190506119df565b83811115611a09576000848401525b50505050565b611a1882611ae7565b810181811067ffffffffffffffff82111715611a3757611a36611ab8565b5b80604052505050565b6000611a4b826119c3565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415611a7e57611a7d611a89565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000601f19601f8301169050919050565b7f43616e6e6f742072656d6f76652073656c660000000000000000000000000000600082015250565b7f4164647265737320616c726561647920696e2073657400000000000000000000600082015250565b7f4164647265737320646f6573206e6f7420657869737420696e20736574000000600082015250565b611b7c81611973565b8114611b8757600080fd5b50565b611b9381611985565b8114611b9e57600080fd5b50565b611baa816119c3565b8114611bb557600080fd5b5056fea2646970667358221220cb76ad3e56645ba6c7fda77ede312043ae4cf431107f64b2e6e642a10164149b64736f6c63430008040033",
  "devdoc": {
    "details": "The SPC contract is the central place for top-level governorship. It requires that a        first member address is passed at construction time.",
    "events": {
      "EthDrained(address,uint256)": {
        "details": "Emited when Eth is drained from this SPC.",
        "params": {
          "amount": "The quantity of Eth that was drained, expressed in Wei.",
          "to": "The caller and recipient of the drained Eth."
        }
      },
      "EthReceived(address,uint256)": {
        "details": "Emited when someone provisions this SPC with Eth.",
        "params": {
          "amount": "The quantity of Eth, expressed in Wei.",
          "from": "The sender of the Eth."
        }
      },
      "FastRegistered(address)": {
        "details": "Emited when a new FAST is registered.",
        "params": {
          "fast": "The address of the newly registered FAST diamond."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "addMember(address)": {
        "details": "Adds a member to this SPC member list.",
        "params": {
          "member": "The address of the member to be added."
        }
      },
      "drainEth()": {
        "details": "A function that alllows draining this SPC from its Eth."
      },
      "fastBySymbol(string)": {
        "details": "Allows to retrieve the address of a FAST diamond given its symbol.",
        "params": {
          "symbol": "The symbol of the FAST diamond to get the address of."
        },
        "returns": {
          "_0": "The address of the corresponding FAST diamond, or the Zero Address if not found."
        }
      },
      "fastCount()": {
        "details": "Counts the number of FAST diamonds registered with this SPC.",
        "returns": {
          "_0": "The number of FAST diamonds registered with this SPC."
        }
      },
      "isFastRegistered(address)": {
        "details": "Queries whether a given address is a known and registered FAST contract.",
        "params": {
          "fast": "The address of the contract to check."
        },
        "returns": {
          "_0": "A boolean."
        }
      },
      "isMember(address)": {
        "details": "Queries whether a given address is a member of this SPC or not.",
        "params": {
          "candidate": "The address to test."
        },
        "returns": {
          "_0": "A `boolean` flag."
        }
      },
      "memberCount()": {
        "details": "Counts the numbers of members present in this SPC.",
        "returns": {
          "_0": "The number of members in this SPC."
        }
      },
      "paginateFasts(uint256,uint256)": {
        "details": "Paginates the FAST diamonds registered with this SPC based on a starting cursor and a number of records per page.",
        "params": {
          "cursor": "The index at which to start.",
          "perPage": "How many records should be returned at most."
        },
        "returns": {
          "_0": "A `address[]` list of values at most `perPage` big.",
          "_1": "A `uint256` index to the next page."
        }
      },
      "paginateMembers(uint256,uint256)": {
        "details": "Paginates the members of this SPC based on a starting cursor and a number of records per page.",
        "params": {
          "cursor": "The index at which to start.",
          "perPage": "How many records should be returned at most."
        },
        "returns": {
          "_0": "A `address[]` list of values at most `perPage` big.",
          "_1": "A `uint256` index to the next page."
        }
      },
      "provisionWithEth()": {
        "details": "A function that alllows provisioning this SPC with Eth."
      },
      "registerFast(address)": {
        "details": "Allows the registration of a given FAST diamond with this SPC.",
        "params": {
          "fast": "The address of the FAST diamond to be registered."
        }
      },
      "removeMember(address)": {
        "details": "Removes a member from this SPC.",
        "params": {
          "member": "The address of the member to be removed."
        }
      }
    },
    "title": "The SPC Smart Contract.",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "addMember(address)": {
        "notice": "Requires that the caller is a member of this SPC.Emits a `IHasMembers.MemberAdded` event."
      },
      "drainEth()": {
        "notice": "Requires that the caller is a member of this SPC.Emits a `EthDrained` event."
      },
      "provisionWithEth()": {
        "notice": "Emits a `EthReceived` event."
      },
      "registerFast(address)": {
        "notice": "Requires that the caller is a member of this SPC.Emits a `FastRegistered` event."
      },
      "removeMember(address)": {
        "notice": "Requires that the caller is a member of this SPC.Emits a `IHasMembers.MemberRemoved` event."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}