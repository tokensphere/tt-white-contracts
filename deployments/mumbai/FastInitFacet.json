{
  "address": "0x805D00b9c14D80c23F2cb89d9BF4FE120e0A2dA7",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "string",
          "name": "ref",
          "type": "string"
        }
      ],
      "name": "Burnt",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "memberCount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "governorCount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalSupply",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "transferCredits",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "reserveBalance",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "ethBalance",
          "type": "uint256"
        }
      ],
      "name": "DetailsChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "spender",
          "type": "address"
        }
      ],
      "name": "Disapproval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "EthDrained",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "EthReceived",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "governor",
          "type": "address"
        }
      ],
      "name": "GovernorAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "governor",
          "type": "address"
        }
      ],
      "name": "GovernorRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "MemberAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "MemberRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "string",
          "name": "ref",
          "type": "string"
        }
      ],
      "name": "Minted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "spcMember",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "TransferCreditsAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "spcMember",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "TransferCreditsDrained",
      "type": "event"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "spc",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "exchange",
              "type": "address"
            },
            {
              "internalType": "address payable",
              "name": "governor",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "hasFixedSupply",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "isSemiPublic",
              "type": "bool"
            }
          ],
          "internalType": "struct FastInitFacet.InitializerParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x3daf7f841f3588b341cafd6f678a3180ceff5d2721057b2e9483f927f9e0a99b",
  "receipt": {
    "to": "0x6DF2D25d8C6FD680730ee658b530A05a99BB769a",
    "from": "0x717634cfe06FFAB2CEAA7fcf1b9019813f4B25FE",
    "contractAddress": null,
    "transactionIndex": 2,
    "gasUsed": "931336",
    "logsBloom": "0x00000000000000020000000000000000000000000000000000000000000000000000000000000000000000000100000000008000000000000000000000000000000000000000000000000040000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000020000000000000000001000000000000000000000000004000000000000000000001000000000000000000000000000000100000000000000000000000000000000400000000000000000000000000000000000000100000",
    "blockHash": "0xe80c0edae6680a4cbc082c769a6b3d4f1c04273b5b56148546f983fa7f49daea",
    "transactionHash": "0x3daf7f841f3588b341cafd6f678a3180ceff5d2721057b2e9483f927f9e0a99b",
    "logs": [
      {
        "transactionIndex": 2,
        "blockNumber": 27342462,
        "transactionHash": "0x3daf7f841f3588b341cafd6f678a3180ceff5d2721057b2e9483f927f9e0a99b",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000717634cfe06ffab2ceaa7fcf1b9019813f4b25fe",
          "0x000000000000000000000000c26880a0af2ea0c7e8130e6ec47af756465452e8"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000008bca1ed750c380000000000000000000000000000000000000000000000003a274cf14448d5a000000000000000000000000000000000000000000000124acbd1bcf1f1015fdf0000000000000000000000000000000000000000000000003a1e904f56d3c96800000000000000000000000000000000000000000000124acbda7993de766c17",
        "logIndex": 4,
        "blockHash": "0xe80c0edae6680a4cbc082c769a6b3d4f1c04273b5b56148546f983fa7f49daea"
      }
    ],
    "blockNumber": 27342462,
    "cumulativeGasUsed": "1043141",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "f4f8b835cacce8dc6ce668efb004d4af",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"ref\",\"type\":\"string\"}],\"name\":\"Burnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"memberCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"governorCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferCredits\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserveBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethBalance\",\"type\":\"uint256\"}],\"name\":\"DetailsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"Disapproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthDrained\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"}],\"name\":\"GovernorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"}],\"name\":\"GovernorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"ref\",\"type\":\"string\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spcMember\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferCreditsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spcMember\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferCreditsDrained\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"spc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"governor\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasFixedSupply\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSemiPublic\",\"type\":\"bool\"}],\"internalType\":\"struct FastInitFacet.InitializerParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Note that although this contract doesn't explicitelly inherit from IERC173, ERC165, IDiamondLoupe etc, all       methods are in fact implemented by the underlaying Diamond proxy. It is therefore safe to       perform casts directly on the current contract address into these interfaces.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/fast/FastInitFacet.sol\":\"FastInitFacet\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/exchange/ExchangeAccessFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../spc/SpcTopFacet.sol';\\nimport '../interfaces/IHasMembers.sol';\\nimport '../interfaces/IHasActiveMembers.sol';\\nimport './lib/LibExchangeAccess.sol';\\nimport './lib/AExchangeFacet.sol';\\n\\n\\n/** @title The Exchange Smart Contract.\\n *  @dev The Exchange Access facet is in charge of keeping track of exchange members.\\n */\\ncontract ExchangeAccessFacet is AExchangeFacet, IHasMembers, IHasActiveMembers {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Membership management.\\n\\n  /** @dev Queries whether a given address is a member of this Exchange or not.\\n   *  @param candidate is the address to test.\\n   *  @return A `boolean` flag.\\n   */\\n  function isMember(address candidate)\\n      external override view returns(bool) {\\n    return LibExchangeAccess.data().memberSet.contains(candidate);\\n  }\\n\\n  /** @dev Counts the numbers of members present in this Exchange.\\n   *  @return The number of members in this exchange.\\n   */\\n  function memberCount()\\n      external override view returns(uint256) {\\n    return LibExchangeAccess.data().memberSet.values.length;\\n  }\\n\\n  /** @dev Paginates the members of this Exchange based on a starting cursor and a number of records per page.\\n   *  @param cursor is the index at which to start.\\n   *  @param perPage is how many records should be returned at most.\\n   *  @return A `address[]` list of values at most `perPage` big.\\n   *  @return A `uint256` index to the next page.\\n   */\\n  function paginateMembers(uint256 cursor, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibExchangeAccess.data().memberSet.values, cursor, perPage);\\n  }\\n\\n  /** @dev Adds a member to this Exchange member list.\\n   *  @param member is the address of the member to be added.\\n   *  @notice Requires that the caller is a member of the linked SPC.\\n   *  @notice Emits a `IHasMembers.MemberAdded` event.\\n   */\\n  function addMember(address payable member)\\n      external override\\n      onlySpcMember {\\n    // Add the member to our list.\\n    LibExchangeAccess.data().memberSet.add(member, false);\\n    // Emit!\\n    emit MemberAdded(member);\\n  }\\n\\n  /** @dev Removes a member from this Exchange.\\n   *  @param member is the address of the member to be removed.\\n   *  @notice Requires that the caller is a member of the linked SPC.\\n   *  @notice Emits a `IHasMembers.MemberRemoved` event.\\n   */\\n  function removeMember(address member)\\n      external override\\n      onlySpcMember {\\n    LibExchangeAccess.Data storage s = LibExchangeAccess.data();\\n    // Ensure that member doesn't have any FAST membership.\\n    require(s.fastMemberships[member].values.length == 0, LibConstants.REQUIRES_NO_FAST_MEMBERSHIPS);\\n    // Remove member.\\n    s.memberSet.remove(member, false);\\n    // Emit!\\n    emit MemberRemoved(member);\\n  }\\n\\n  /** @dev Allows to query FAST memberships for a given member address.\\n   *  @param member Is the address to check.\\n   *  @param cursor The index at which to start.\\n   *  @param perPage How many records should be returned at most.\\n   */\\n  function fastMemberships(address member, uint256 cursor, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibExchangeAccess.data().fastMemberships[member].values, cursor, perPage);\\n  }\\n\\n  /** @dev Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.\\n   *  @param member The member for which a new FAST membership has been added.\\n   */\\n  function memberAddedToFast(address member) \\n      external {\\n    // Verify that the given address is in fact a registered FAST contract.\\n    require(\\n      SpcTopFacet(LibExchange.data().spc).isFastRegistered(msg.sender),\\n      LibConstants.REQUIRES_FAST_CONTRACT_CALLER\\n    );\\n    // Keep track of the member's FAST membership.\\n    LibAddressSet.Data storage memberFasts = LibExchangeAccess.data().fastMemberships[member];\\n    memberFasts.add(msg.sender, false);\\n  }\\n\\n  /** @dev Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.\\n   *  @param member The member for which a FAST membership has been removed.\\n   */\\n  function memberRemovedFromFast(address member)\\n      external {\\n    require(\\n      SpcTopFacet(LibExchange.data().spc).isFastRegistered(msg.sender),\\n      LibConstants.REQUIRES_FAST_CONTRACT_CALLER\\n    );\\n    // Remove the tracked membership.\\n    LibAddressSet.Data storage memberFasts = LibExchangeAccess.data().fastMemberships[member];\\n    memberFasts.remove(msg.sender, false);\\n  }\\n\\n  /** @dev Given a member returns it's activation status.\\n   *  @param member The member to check activation status on.\\n   */\\n  function isMemberActive(address member) external override view returns(bool) {\\n    return !LibExchangeAccess.data().deactivatedMemberSet.contains(member);\\n  }\\n\\n  /** @dev Activates a member at the Exchange level.\\n   *  @param member The member to remove from the deactivation member set.\\n   */\\n  function activateMember(address member)\\n    external\\n    override\\n    onlySpcMember\\n    onlyMember(member) {\\n    // Guard against attempting to activate an already active member.\\n    require(\\n      !this.isMemberActive(member),\\n      LibConstants.REQUIRES_EXCHANGE_DEACTIVATED_MEMBER\\n    );\\n\\n    // Remove the member from the deactivated members list.\\n    LibExchangeAccess.data().deactivatedMemberSet.remove(member, false);\\n\\n    // Emit!\\n    emit MemberActivated(member);\\n  }\\n\\n  /** @dev Deactivates a member at the Exchange level.\\n   *  @param member The member to add to the deactivation member set.\\n   */\\n  function deactivateMember(address payable member)\\n    external\\n    override\\n    onlySpcMember\\n    onlyMember(member) {\\n    // Guard against attempting to deactivate an already deactivated member.\\n    require(\\n      this.isMemberActive(member),\\n      LibConstants.REQUIRES_EXCHANGE_ACTIVE_MEMBER\\n    );\\n\\n    // Add the member to the deactivated members list.\\n    LibExchangeAccess.data().deactivatedMemberSet.add(member, false);\\n\\n    // Emit!\\n    emit MemberDeactivated(member);\\n  }\\n}\\n\",\"keccak256\":\"0x27770d3b210cecb8d345f5b1aa9d3b7f7eedc7a59f0dfbaae0e154a93dc0639d\",\"license\":\"MIT\"},\"contracts/exchange/ExchangeTopFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../spc/SpcTopFacet.sol';\\nimport './lib/LibExchange.sol';\\nimport '../interfaces/IHasMembers.sol';\\nimport './lib/AExchangeFacet.sol';\\n\\n\\n/** @title The Exchange Smart Contract.\\n *  @dev The Exchange Top facet is in charge of keeping track of common parameters and provides\\n *        generic functionality.\\n */\\ncontract ExchangeTopFacet is AExchangeFacet {\\n  // Getters.\\n\\n  function spcAddress()\\n    external view returns(address) {\\n      return LibExchange.data().spc;\\n  }\\n}\\n\",\"keccak256\":\"0x710c477b928f904ad473cbb2350bdac69c5d481c526deef9b23ab8876bee3f01\",\"license\":\"MIT\"},\"contracts/exchange/lib/AExchangeFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../lib/LibExchange.sol';\\nimport '../lib/LibExchangeAccess.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../../interfaces/IHasMembers.sol';\\nimport './IExchangeEvents.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any Exchange facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract AExchangeFacet is IExchangeEvents {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\\n  modifier onlyDeployer() {\\n    require(\\n      msg.sender == LibConstants.DEPLOYER_CONTRACT,\\n      LibConstants.INTERNAL_METHOD\\n    );\\n    _;\\n  }\\n\\n  /** @dev Requires that the message sender is a member of the linked SPC.\\n   */\\n  modifier onlySpcMember() {\\n    require(\\n      IHasMembers(LibExchange.data().spc).isMember(msg.sender),\\n      LibConstants.REQUIRES_SPC_MEMBERSHIP\\n    );\\n    _;\\n  }\\n\\n  /** @dev Requires that the given address is a member of the exchange.\\n   *  @param candidate is the address to be checked.\\n   */\\n  modifier onlyMember(address candidate) {\\n    require(\\n      LibExchangeAccess.data().memberSet.contains(candidate),\\n      LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP\\n    );\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0xd1f058a3dc27f3454dfc87e60402e2f84ef910d7d8a06638005ac20c21c0fbd3\",\"license\":\"MIT\"},\"contracts/exchange/lib/IExchangeEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IExchangeEvents {\\n  // IHasMembers.\\n\\n  event MemberAdded(address indexed member);\\n  event MemberRemoved(address indexed member);\\n\\n  // IHasActiveMembers.\\n  event MemberActivated(address indexed member);\\n  event MemberDeactivated(address indexed member);\\n}\\n\",\"keccak256\":\"0x0c17764ae9b192ad9d31fac741fe1239e718f8db0ebd9478b5361a0276dac832\",\"license\":\"MIT\"},\"contracts/exchange/lib/LibExchange.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibExchange {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Exchange.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x58cca9481e011ced58c1d520ef5aad456e5805265d66de8df7c52f680c417394;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev The internal pointer to the SPC contract.\\n    address spc;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x3a8c32be0f6d238ec402d9afada3bbe00c69875e98fb9968b0f206be0ff23062\",\"license\":\"MIT\"},\"contracts/exchange/lib/LibExchangeAccess.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibExchangeAccess {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Exchange.storage.Access'):\\n  bytes32 internal constant STORAGE_SLOT = 0x238f5ead2481aef1ec60acdfe5b3de34c076d0a86bb41e30c913f5f3885d7c47;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev This is where we hold our members data.\\n    LibAddressSet.Data memberSet;\\n    /// @dev This is where we keep track of our member FAST memberships.\\n    mapping(address => LibAddressSet.Data) fastMemberships;\\n    /// @dev This is where we keep track of our deactivated memberships.\\n    LibAddressSet.Data deactivatedMemberSet;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xbfdf94df126ba4a15f865ee9b280c956b36d5c920ba8b8807a5daaf1bf22b82c\",\"license\":\"MIT\"},\"contracts/fast/FastAccessFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../interfaces/IHasMembers.sol';\\nimport '../interfaces/IHasGovernors.sol';\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../exchange/ExchangeAccessFacet.sol';\\nimport './FastTokenFacet.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFast.sol';\\nimport './lib/LibFastAccess.sol';\\nimport './FastTopFacet.sol';\\nimport './FastFrontendFacet.sol';\\n\\n\\n/**\\n* @dev The FAST Access Smart Contract is the source of truth when it comes to\\n* permissioning and ACLs within a given FAST network.\\n*/\\ncontract FastAccessFacet is AFastFacet, IHasMembers, IHasGovernors {\\n  using LibAddressSet for LibAddressSet.Data;\\n  // Structs.\\n\\n  /**\\n   * @dev This structure isn't used anywhere in storage. Instead, it\\n   * allows various methods of the contract to return all the flags\\n   * associated with a given address in one go.\\n   */\\n  struct Flags {\\n    bool isGovernor;\\n    bool isMember;\\n  }\\n\\n  // Constants.\\n\\n  // This represents how much Eth we provision new governors with.\\n  uint256 constant private GOVERNOR_ETH_PROVISION = 10 ether;\\n  // This represents how much Eth we provision new members with.\\n  uint256 constant private MEMBER_ETH_PROVISION = 1 ether;\\n\\n  // Governorship related stuff.\\n\\n  /**\\n   * @dev Queries whether a given address is a governor or not.\\n   */\\n  function isGovernor(address candidate)\\n      external view override returns(bool) {\\n    return LibFastAccess.data().governorSet.contains(candidate);\\n  }\\n\\n  /**\\n   * @dev Queries the number of governors in the governor list.\\n   */\\n  function governorCount()\\n      external override view returns(uint256) {\\n    return LibFastAccess.data().governorSet.values.length;\\n  }\\n\\n  /**\\n   * @dev Returns a page of governors.\\n   */\\n  function paginateGovernors(uint256 index, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibFastAccess.\\n      data().governorSet.values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  /**\\n   * @dev Adds a governor to the governor list.\\n   */\\n  function addGovernor(address payable governor)\\n      external override\\n      onlySpcMember\\n      onlyExchangeMember(governor) {\\n    // Add governor to list.\\n    LibFastAccess.data().governorSet.add(governor, false);\\n    // If the address is a regular wallet...\\n    if (!LibHelpers.isContract(governor)) {\\n      // Provision the new governor with Eth if possible.\\n      FastTopFacet(payable(address(this))).payUpTo(governor, GOVERNOR_ETH_PROVISION);\\n    }\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit GovernorAdded(governor);\\n  }\\n\\n  /**\\n   * @dev Removes a governor from the governor list.\\n   */\\n  function removeGovernor(address governor)\\n      external override\\n      onlySpcMember {\\n    // Remove governor.\\n    LibFastAccess.data().governorSet.remove(governor, false);\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit GovernorRemoved(governor);\\n  }\\n\\n  /// Membership related stuff.\\n\\n  /**\\n   * @dev Queries whether a given address is a member or not.\\n   */\\n  function isMember(address candidate)\\n      external override view returns(bool) {\\n    return LibFastAccess.data().memberSet.contains(candidate);\\n  }\\n\\n  /**\\n   * @dev Queries the number of members in the membership list.\\n   */\\n  function memberCount()\\n      external override view returns(uint256) {\\n    return LibFastAccess.data().memberSet.values.length;\\n  }\\n\\n  /**\\n   * @dev Returns a page of members.\\n   */\\n  function paginateMembers(uint256 index, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastAccess.data().memberSet.values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  /**\\n   * @dev Adds a member to the membership list.\\n   */\\n  function addMember(address payable member)\\n      external override \\n      onlyGovernor(msg.sender) onlyExchangeMember(member) {\\n    // Add the member.\\n    LibFastAccess.data().memberSet.add(member, false);\\n    // If the address is a regular wallet...\\n    if (!LibHelpers.isContract(member)) {\\n      // Provision the new member with Eth if possible.\\n      FastTopFacet(payable(address(this))).payUpTo(member, MEMBER_ETH_PROVISION);\\n    }\\n    // Notify exchange that this member was added to this FAST.\\n    ExchangeAccessFacet(LibFast.data().exchange).memberAddedToFast(member);\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit MemberAdded(member);\\n  }\\n\\n  /**\\n   * @dev Removes a member from the membership list.\\n   */\\n  function removeMember(address member)\\n      external override \\n      onlyGovernor(msg.sender) {\\n    // Remove member.\\n    LibFastAccess.data().memberSet.remove(member, false);\\n    // Notify token facet that this member was removed.\\n    FastTokenFacet(address(this)).beforeRemovingMember(member);\\n    // Notify exchange that this member was removed from this FAST.\\n    ExchangeAccessFacet(LibFast.data().exchange).memberRemovedFromFast(member);\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit MemberRemoved(member);\\n  }\\n\\n  /// Flags.\\n\\n  /**\\n   * @dev Retrieves flags for a given address.\\n   */\\n  function flags(address a)\\n      external view returns(Flags memory) {\\n    LibFastAccess.Data storage s = LibFastAccess.data();\\n    return\\n      Flags({\\n        isGovernor: s.governorSet.contains(a),\\n        isMember: s.memberSet.contains(a)\\n      });\\n  }\\n}\\n\",\"keccak256\":\"0x4f658a768a1f1caf334349e53c3c4cc92d96da6446a117035c3e90af52b5c4af\",\"license\":\"MIT\"},\"contracts/fast/FastFrontendFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFastAccess.sol';\\nimport './lib/LibFastToken.sol';\\n\\n\\ncontract FastFrontendFacet is AFastFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Data structures.\\n\\n  struct Details {\\n    address addr;\\n    string name;\\n    string symbol;\\n    uint256 decimals;\\n    uint256 totalSupply;\\n    uint256 transferCredits;\\n    bool isSemiPublic;\\n    bool hasFixedSupply;\\n    uint256 reserveBalance;\\n    uint256 ethBalance;\\n    uint256 memberCount;\\n    uint256 governorCount;\\n  }\\n\\n  struct MemberDetails {\\n    address addr;\\n    uint256 balance;\\n    uint256 ethBalance;\\n    bool isGovernor;\\n  }\\n\\n  // Emitters.\\n\\n  function emitDetailsChanged()\\n      external onlyDiamondFacet {\\n    LibFastAccess.Data storage accessData = LibFastAccess.data();\\n    LibFastToken.Data storage tokenData = LibFastToken.data();\\n    emit DetailsChanged({\\n      memberCount: accessData.memberSet.values.length,\\n      governorCount: accessData.governorSet.values.length,\\n      totalSupply: tokenData.totalSupply,\\n      transferCredits: tokenData.transferCredits,\\n      reserveBalance: tokenData.balances[LibConstants.ZERO_ADDRESS],\\n      ethBalance: payable(address(this)).balance\\n    });\\n  }\\n\\n  // Public functions.\\n\\n  function details()\\n      public view returns(Details memory) {\\n    LibFast.Data storage topStorage = LibFast.data();\\n    LibFastAccess.Data storage accessStorage = LibFastAccess.data();\\n    LibFastToken.Data storage tokenStorage = LibFastToken.data();\\n    return Details({\\n      addr: address(this),\\n      name: tokenStorage.name,\\n      symbol: tokenStorage.symbol,\\n      decimals: tokenStorage.decimals,\\n      totalSupply: tokenStorage.totalSupply,\\n      transferCredits: tokenStorage.transferCredits,\\n      isSemiPublic: topStorage.isSemiPublic,\\n      hasFixedSupply: topStorage.hasFixedSupply,\\n      reserveBalance: tokenStorage.balances[LibConstants.ZERO_ADDRESS],\\n      ethBalance: payable(address(this)).balance,\\n      memberCount: accessStorage.memberSet.values.length,\\n      governorCount: accessStorage.governorSet.values.length\\n    });\\n  }\\n\\n  function detailedMember(address member)\\n      public view returns(MemberDetails memory) {\\n    LibFastToken.Data storage tokenStorage = LibFastToken.data();\\n    LibFastAccess.Data storage accessStorage = LibFastAccess.data();\\n    return MemberDetails({\\n      addr: member,\\n      balance: tokenStorage.balances[member],\\n      ethBalance: member.balance,\\n      isGovernor: accessStorage.governorSet.contains(member)\\n    });\\n  }\\n\\n  function paginateDetailedMembers(uint256 index, uint256 perPage)\\n      external view returns(MemberDetails[] memory, uint256) {\\n    LibFastAccess.Data storage accessStorage = LibFastAccess.data();\\n    (address[] memory members, uint256 nextCursor) =\\n      LibPaginate.addresses(accessStorage.memberSet.values, index, perPage);\\n    MemberDetails[] memory values = new MemberDetails[](members.length);\\n    for (uint256 i = 0; i < members.length; ++i) {\\n      values[i] = detailedMember(members[i]);\\n    }\\n    return (values, nextCursor);\\n  }\\n}\\n\",\"keccak256\":\"0xc1227904923f6b4630faac8f765e3123882154f9631f6a886a17ceac37d7b11f\",\"license\":\"MIT\"},\"contracts/fast/FastHistoryFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibPaginate.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFastHistory.sol';\\n\\n\\ncontract FastHistoryFacet is AFastFacet {\\n  /// Minting history-keeping methods.\\n\\n  function minted(uint256 amount, string calldata ref)\\n      external onlyDiamondFacet() {\\n    // Keep track of the mint.\\n    LibFastHistory.data().supplyProofs.push(\\n      LibFastHistory.SupplyProof({\\n        op: LibFastHistory.SupplyOp.Mint,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function burnt(uint256 amount, string calldata ref)\\n      external onlyDiamondFacet() {\\n    // Keep track of the unmint.\\n    LibFastHistory.data().supplyProofs.push(\\n      LibFastHistory.SupplyProof({\\n        op: LibFastHistory.SupplyOp.Burn,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function supplyProofCount()\\n      external view returns(uint256) {\\n    return LibFastHistory.data().supplyProofs.length;\\n  }\\n\\n  function paginateSupplyProofs(uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.SupplyProof[] memory, uint256) {\\n    return LibPaginate.supplyProofs(LibFastHistory.data().supplyProofs, cursor, perPage);\\n  }\\n\\n  /// Transfer history-keeping methods.\\n\\n  function transfered(address spender, address from, address to, uint256 amount, string calldata ref)\\n      external onlyDiamondFacet() {\\n    LibFastHistory.Data storage s = LibFastHistory.data();\\n    // Keep track of the transfer proof ID for the sender and for the recipient.\\n    s.transferProofInvolvements[from].push(s.transferProofs.length);\\n    s.transferProofInvolvements[to].push(s.transferProofs.length);\\n    // Keep track of the transfer proof globally.\\n    s.transferProofs.push(\\n      LibFastHistory.TransferProof({\\n        spender: spender,\\n        from: from,\\n        to: to,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function transferProofCount()\\n      external view returns(uint256) {\\n    return LibFastHistory.data().transferProofs.length;\\n  }\\n\\n  function paginateTransferProofs(uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n    return LibPaginate.transferProofs(LibFastHistory.data().transferProofs, cursor, perPage);\\n  }\\n\\n  function transferProofByInvolveeCount(address involvee)\\n      external view returns(uint256) {\\n    return LibFastHistory.data().transferProofInvolvements[involvee].length;\\n  }\\n\\n  function paginateTransferProofIndicesByInvolvee(address involvee, uint256 cursor, uint256 perPage)\\n      external view returns(uint256[] memory, uint256) {\\n    return LibPaginate.uint256s(LibFastHistory.data().transferProofInvolvements[involvee], cursor, perPage);\\n  }\\n\\n  function paginateTransferProofsByInvolvee(address involvee, uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n    LibFastHistory.Data storage s = LibFastHistory.data();\\n    uint256[] storage collection  = s.transferProofInvolvements[involvee];\\n    uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n    LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\\n    for (uint256 i = 0; i < length; i++) {\\n      values[i] = s.transferProofs[collection[cursor + i]];\\n    }\\n    return (values, cursor + length);\\n  }\\n}\\n\",\"keccak256\":\"0xaafd047e60319fd6ac2f61d133b97e61ae656237d858d95d6fc680c3114e9ab5\",\"license\":\"MIT\"},\"contracts/fast/FastInitFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../interfaces/IERC20.sol';        // Token.\\nimport '../interfaces/IERC165.sol';       // Interface Support.\\nimport '../interfaces/IERC173.sol';       // Ownership.\\nimport '../interfaces/IERC1404.sol';      // Transfer Restriction.\\nimport '../interfaces/IDiamondCut.sol';   // Facet management.\\nimport '../interfaces/IDiamondLoupe.sol'; // Facet introspection.\\nimport '../interfaces/IHasGovernors.sol'; // Governorship management.\\nimport '../interfaces/IHasMembers.sol';   // Membership management.\\nimport '../lib/LibDiamond.sol';\\nimport '../lib/LibAddressSet.sol';\\nimport '../exchange/ExchangeTopFacet.sol';\\nimport './lib/AFastFacet.sol';\\n\\n\\n/**\\n* @dev Note that although this contract doesn't explicitelly inherit from IERC173, ERC165, IDiamondLoupe etc, all\\n*       methods are in fact implemented by the underlaying Diamond proxy. It is therefore safe to\\n*       perform casts directly on the current contract address into these interfaces.\\n*/ \\ncontract FastInitFacet is AFastFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Initializers.\\n\\n  struct InitializerParams {\\n    // Top-level stuff.\\n    address spc;\\n    address exchange;\\n    // Access stuff.\\n    address payable governor;\\n    // Token stuff.\\n    string name;\\n    string symbol;\\n    uint256 decimals;\\n    bool hasFixedSupply;\\n    bool isSemiPublic;\\n  }\\n\\n  function initialize(InitializerParams calldata params)\\n      external\\n      onlyDeployer {\\n    // Make sure we haven't initialized yet.\\n    require(LibFast.data().version < LibFast.STORAGE_VERSION, 'Already initialized');\\n\\n    // Register interfaces.\\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n    ds.supportedInterfaces[type(IERC20).interfaceId] = true;\\n    ds.supportedInterfaces[type(IERC165).interfaceId] = true;\\n    ds.supportedInterfaces[type(IERC173).interfaceId] = true;\\n    ds.supportedInterfaces[type(IERC1404).interfaceId] = true;\\n    ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\\n    ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\\n    ds.supportedInterfaces[type(IHasGovernors).interfaceId] = true;\\n    ds.supportedInterfaces[type(IHasMembers).interfaceId] = true;\\n\\n    // ------------------------------------- //\\n\\n    // Initialize top-level storage.\\n    LibFast.Data storage topData = LibFast.data();\\n    topData.version = LibFast.STORAGE_VERSION;\\n    topData.spc = params.spc;\\n    topData.exchange = params.exchange;\\n    topData.hasFixedSupply = params.hasFixedSupply;\\n    topData.isSemiPublic = params.isSemiPublic;\\n\\n    // ------------------------------------- //\\n\\n    // Initialize access storage.\\n    LibFastAccess.Data storage accessData = LibFastAccess.data();\\n    accessData.version = LibFastAccess.STORAGE_VERSION;\\n    // Add the governor and emit.\\n    accessData.governorSet.add(params.governor, false);\\n    emit GovernorAdded(params.governor);\\n\\n    // ------------------------------------- //\\n\\n    // Initialize token storage.\\n    LibFastToken.Data storage tokenData = LibFastToken.data();\\n    tokenData.version = LibFastToken.STORAGE_VERSION;\\n    // Set up ERC20 related stuff.\\n    (tokenData.name, tokenData.symbol, tokenData.decimals) =\\n      (params.name,   params.symbol,   params.decimals);\\n    tokenData.totalSupply = 0;\\n    // Initialize other internal stuff.\\n    tokenData.transferCredits = 0;\\n  }\\n}\\n\",\"keccak256\":\"0x710072321f29fc849177dfeb830f736865ed7170d06c999ccc666a488cb6e64a\",\"license\":\"MIT\"},\"contracts/fast/FastTokenFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../interfaces/IERC20.sol';\\nimport '../interfaces/IERC1404.sol';\\nimport '../interfaces/IHasMembers.sol';\\nimport '../interfaces/IHasGovernors.sol';\\nimport '../lib/LibDiamond.sol';\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFastToken.sol';\\nimport './lib/IFast.sol';\\nimport './FastTopFacet.sol';\\nimport './FastAccessFacet.sol';\\nimport './FastHistoryFacet.sol';\\nimport './FastFrontendFacet.sol';\\n\\n\\ncontract FastTokenFacet is AFastFacet, IERC20, IERC1404 {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Minting methods.\\n\\n  function mint(uint256 amount, string calldata ref)\\n      external\\n      onlySpcMember {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // We want to make sure that either of these two is true:\\n    // - The token doesn't have fixed supply.\\n    // - The token has fixed supply but has no tokens yet (First and only mint).\\n    require(\\n      !FastTopFacet(address(this)).hasFixedSupply() || (s.totalSupply == 0 && this.balanceOf(address(0)) == 0),\\n      LibConstants.REQUIRES_CONTINUOUS_SUPPLY\\n    );\\n\\n    // Prepare the minted amount on the zero address.\\n    s.balances[address(0)] += amount;\\n\\n    // Keep track of the minting operation.\\n    FastHistoryFacet(address(this)).minted(amount, ref);\\n\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit Minted(amount, ref);\\n  }\\n\\n  function burn(uint256 amount, string calldata ref)\\n      external\\n      onlySpcMember {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    require(!FastTopFacet(address(this)).hasFixedSupply(), LibConstants.REQUIRES_CONTINUOUS_SUPPLY);\\n    require(balanceOf(address(0)) >= amount, LibConstants.INSUFFICIENT_FUNDS);\\n\\n    // Remove the minted amount from the zero address.\\n    s.balances[address(0)] -= amount;\\n\\n    // Keep track of the minting operation.\\n    FastHistoryFacet(address(this)).burnt(amount, ref);\\n\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit Burnt(amount, ref);\\n  }\\n\\n  // Tranfer Credit management.\\n\\n  function transferCredits()\\n      external view returns(uint256) {\\n    return LibFastToken.data().transferCredits;\\n  }\\n\\n  function addTransferCredits(uint256 amount)\\n      external\\n      onlySpcMember {\\n    LibFastToken.data().transferCredits += amount;\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n    emit TransferCreditsAdded(msg.sender, amount);\\n  }\\n\\n  function drainTransferCredits()\\n      external\\n      onlySpcMember {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // Emit!\\n    emit TransferCreditsDrained(msg.sender, s.transferCredits);\\n    // Drain credits.\\n    s.transferCredits = 0;\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n  }\\n\\n  // ERC20 implementation and transfer related methods.\\n\\n  function name()\\n      external view returns(string memory) {\\n    return LibFastToken.data().name;\\n  }\\n\\n  function symbol()\\n      external view returns(string memory) {\\n    return LibFastToken.data().symbol;\\n  }\\n\\n  function decimals()\\n      external view returns(uint256) {\\n    return LibFastToken.data().decimals;\\n  }\\n\\n  function totalSupply()\\n      external override view returns(uint256) {\\n    return LibFastToken.data().totalSupply;\\n  }\\n\\n  function balanceOf(address owner)\\n      public view override returns(uint256) {\\n    return LibFastToken.data().balances[owner];\\n  }\\n\\n  function transfer(address to, uint256 amount)\\n      external override returns(bool) {\\n    // Make sure the call is performed externally so that we can mock.\\n    this.performTransfer(\\n      TransferArgs({\\n        spender: msg.sender,\\n        from: msg.sender,\\n        to: to,\\n        amount: amount,\\n        ref: LibFastToken.DEFAULT_TRANSFER_REFERENCE\\n      })\\n    );\\n    return true;\\n  }\\n\\n  function transferWithRef(address to, uint256 amount, string calldata ref)\\n      external {\\n    // Make sure the call is performed externally so that we can mock.\\n    this.performTransfer(\\n      TransferArgs({\\n        spender: msg.sender,\\n        from: msg.sender,\\n        to: to,\\n        amount: amount,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function allowance(address owner, address spender)\\n      public view override returns(uint256) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // If the allowance being queried is from the zero address and the spender\\n    // is a governor, we want to make sure that the spender has full rights over it.\\n    if (owner == address(0)) {\\n      require(FastAccessFacet(address(this)).isGovernor(spender), LibConstants.REQUIRES_FAST_GOVERNORSHIP);\\n      return s.balances[owner];\\n    }\\n    return s.allowances[owner][spender];\\n  }\\n\\n  function approve(address spender, uint256 amount)\\n      external override returns(bool) {\\n    // Make sure the call is performed externally so that we can mock.\\n    this.performApproval(msg.sender, spender, amount);\\n    return true;\\n  }\\n\\n  function disapprove(address spender)\\n      external\\n      onlyMember(msg.sender) {\\n    // Make sure the call is performed externally so that we can mock.\\n    this.performDisapproval(msg.sender, spender);\\n  }\\n\\n  function transferFrom(address from, address to, uint256 amount)\\n      external override returns(bool) {\\n    transferFromWithRef(from, to, amount, LibFastToken.DEFAULT_TRANSFER_REFERENCE);\\n    return true;\\n  }\\n\\n  function transferFromWithRef(address from, address to, uint256 amount, string memory ref)\\n      public {\\n    // Make sure the call is performed externally so that we can mock.\\n    this.performTransfer(\\n      TransferArgs({\\n        spender: msg.sender,\\n        from: from,\\n        to: to,\\n        amount: amount,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  // Allowances query operations.\\n\\n  function givenAllowanceCount(address owner)\\n      external view returns(uint256) {\\n    return LibFastToken.data().allowancesByOwner[owner].values.length;\\n  }\\n\\n  function paginateAllowancesByOwner(address owner, uint256 index, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastToken.data().allowancesByOwner[owner].values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  function receivedAllowanceCount(address spender)\\n      external view returns(uint256) {\\n    return LibFastToken.data().allowancesBySpender[spender].values.length;\\n  }\\n\\n  function paginateAllowancesBySpender(address spender, uint256 index, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastToken.data().allowancesBySpender[spender].values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  // ERC1404 implementation.\\n\\n  function detectTransferRestriction(address from, address to, uint256 amount)\\n      external view override returns(uint8) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    if (s.transferCredits < amount) {\\n      return LibFastToken.INSUFFICIENT_TRANSFER_CREDITS_CODE;\\n    } else if (!FastAccessFacet(address(this)).isMember(from) ||\\n               !FastAccessFacet(address(this)).isMember(to)) {\\n      return FastTopFacet(address(this)).isSemiPublic()\\n        ? LibFastToken.REQUIRES_EXCHANGE_MEMBERSHIP_CODE\\n        : LibFastToken.REQUIRES_FAST_MEMBERSHIP_CODE;\\n    } else if (from == to) {\\n      return LibFastToken.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE;\\n    }\\n    return 0;\\n  }\\n\\n  function messageForTransferRestriction(uint8 restrictionCode)\\n      external override pure returns(string memory) {\\n    if (restrictionCode == LibFastToken.INSUFFICIENT_TRANSFER_CREDITS_CODE) {\\n      return LibConstants.INSUFFICIENT_TRANSFER_CREDITS;\\n    } else if (restrictionCode == LibFastToken.REQUIRES_EXCHANGE_MEMBERSHIP_CODE) {\\n      return LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP;\\n    } else if (restrictionCode == LibFastToken.REQUIRES_FAST_MEMBERSHIP_CODE) {\\n      return LibConstants.REQUIRES_FAST_MEMBERSHIP;\\n    } else if (restrictionCode == LibFastToken.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE) {\\n      return LibConstants.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT;\\n    }\\n    revert(LibConstants.UNKNOWN_RESTRICTION_CODE);\\n  }\\n\\n  // These functions would be internal / private if we weren't using the diamond pattern.\\n  // Instead, they're `onlyDiamondFacet` - eg can only be called by facets of the current\\n  // FAST.\\n\\n  struct TransferArgs {\\n    address spender;\\n    address from;\\n    address to;\\n    uint256 amount;\\n    string ref;\\n  }\\n\\n  function performTransfer(TransferArgs calldata p)\\n      external onlyDiamondFacet\\n      differentAddresses(p.from, p.to)\\n      onlyTokenHolder(p.from)\\n      onlyExchangeActiveMember(p.from)\\n      onlyTokenHolder(p.to) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Make sure that there's enough funds.\\n    require(\\n      s.balances[p.from] >= p.amount,\\n      LibConstants.INSUFFICIENT_FUNDS\\n    );\\n    require(\\n      p.amount > 0,\\n      LibConstants.UNSUPPORTED_OPERATION\\n    );\\n\\n    // If this is an allowance transfer...\\n    if (p.spender != p.from) {\\n      // Make sure that the spender has enough allowance.\\n      require(\\n        FastTokenFacet(address(this)).allowance(p.from, p.spender) >= p.amount,\\n        LibConstants.INSUFFICIENT_ALLOWANCE\\n      );\\n\\n      // If the from account isn't the zero address...\\n      if (p.from != address(0)) {\\n        // Decrease allowance.\\n        uint256 newAllowance = s.allowances[p.from][p.spender] -= p.amount;\\n        // If the allowance reached zero, we want to remove that allowance from\\n        // the various other places where we keep track of it.\\n        if (newAllowance == 0) {\\n          s.allowancesByOwner[p.from].remove(p.spender, true);\\n          s.allowancesBySpender[p.spender].remove(p.from, true);\\n        }\\n      }\\n    }\\n\\n    // Keep track of the balances - `from` spends, `to` receives.\\n    s.balances[p.from] -= p.amount;\\n    s.balances[p.to] += p.amount;\\n\\n    // If the funds are not moving from the zero address, decrease transfer credits.\\n    if (p.from != address(0)) {\\n      // Make sure enough credits exist.\\n      require(\\n        s.transferCredits >= p.amount,\\n        LibConstants.INSUFFICIENT_TRANSFER_CREDITS\\n      );\\n      s.transferCredits -= p.amount;\\n    }\\n\\n    // If the funds are going to the ZERO address, decrease total supply.\\n    if (p.to == address(0)) {\\n      s.totalSupply -= p.amount;\\n      // If funds at address zero changed, we can emit a top-level details change event.\\n      FastFrontendFacet(address(this)).emitDetailsChanged();\\n    }\\n    // If the funds are moving from the zero address, increase total supply.\\n    else if (p.from == address(0)) {\\n      s.totalSupply += p.amount;\\n      // If funds at address zero changed, we can emit a top-level details change event.\\n      FastFrontendFacet(address(this)).emitDetailsChanged();\\n    }\\n\\n    // Keep track of the transfer in the history facet.\\n    FastHistoryFacet(address(this)).transfered(p.spender, p.from, p.to, p.amount, p.ref);\\n\\n    // Emit!\\n    emit Transfer(p.from, p.to, p.amount);\\n  }\\n\\n  function performApproval(address from, address spender, uint256 amount)\\n      external\\n      onlyDiamondFacet\\n      onlyTokenHolder(from) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Store allowance...\\n    s.allowances[from][spender] += amount;\\n    // Keep track of given and received allowances.\\n    s.allowancesByOwner[from].add(spender, true);\\n    s.allowancesBySpender[spender].add(from, true);\\n\\n    // Emit!\\n    emit Approval(from, spender, amount);\\n  }\\n\\n  function performDisapproval(address from, address spender)\\n      external\\n      onlyDiamondFacet {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Remove allowance.\\n    s.allowances[from][spender] = 0;\\n    s.allowancesByOwner[from].remove(spender, false);\\n    s.allowancesBySpender[spender].remove(from, false);\\n\\n    // Emit!\\n    emit Disapproval(from, spender);\\n  }\\n\\n  // WARNING: This function contains two loops. We know that this should never\\n  // happen in solidity. However:\\n  // - In the context of our private chain, gas is cheap.\\n  // - It can only be called by a governor.\\n  function beforeRemovingMember(address member)\\n      external onlyDiamondFacet() {\\n    require(balanceOf(member) == 0, 'Balance is positive');\\n\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Remove all given allowances.\\n    address[] storage gaData = s.allowancesByOwner[member].values;\\n    while (gaData.length > 0) {\\n      // Make sure the call is performed externally so that we can mock.\\n      this.performDisapproval(member, gaData[0]);\\n    }\\n\\n    // Remove all received allowances.\\n    address[] storage raData = s.allowancesBySpender[member].values;\\n    while (raData.length > 0) {\\n      // Make sure the call is performed externally so that we can mock.\\n      this.performDisapproval(raData[0], member);\\n    }\\n  }\\n\\n  // Modifiers.\\n\\n  /** @dev Ensures that the given address is a member of the current FAST or the Zero Address.\\n   *  @param candidate The address to check.\\n   */\\n  modifier onlyTokenHolder(address candidate) {\\n    // Only perform checks if the address is non-zero.\\n    if (candidate != address(0)) {\\n    // FAST is semi-public - the only requirement to hold tokens is to be an exchange member.\\n      if (IFast(address(this)).isSemiPublic()) {\\n        require(\\n          IHasMembers(LibFast.data().exchange).isMember(candidate),\\n          LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP\\n        );\\n      }\\n      // FAST is private, the requirement to hold tokens is to be a member of that FAST.\\n      else {\\n        require(\\n          IHasMembers(address(this)).isMember(candidate),\\n          LibConstants.REQUIRES_FAST_MEMBERSHIP\\n        );\\n      }\\n    }\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x135502ebffda0d70b80c113ea020edd542dadfc7e890d5b292dc91499a5be2e9\",\"license\":\"MIT\"},\"contracts/fast/FastTopFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibConstants.sol';\\nimport '../lib/LibHelpers.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFast.sol';\\nimport './lib/IFastEvents.sol';\\nimport './FastFrontendFacet.sol';\\n\\ncontract FastTopFacet is AFastFacet {\\n  // Getters and setters for global flags.\\n\\n  function spcAddress()\\n      external view returns(address) {\\n    return LibFast.data().spc;\\n  }\\n\\n  function exchangeAddress()\\n      external view returns(address) {\\n    return LibFast.data().exchange;\\n  }\\n\\n  function isSemiPublic()\\n      external view returns(bool) {\\n    return LibFast.data().isSemiPublic;\\n  }\\n\\n  function hasFixedSupply()\\n      external view returns(bool) {\\n    return LibFast.data().hasFixedSupply;\\n  }\\n\\n  // Setters for global flags.\\n\\n  /// @dev Allows to switch from a private scheme to a semi-public scheme, but not the other way around.\\n  function setIsSemiPublic(bool flag)\\n      external\\n      onlySpcMember {\\n    LibFast.Data storage s = LibFast.data();\\n    // Someone is trying to toggle back to private?... No can do!isSemiPublic\\n    require(!this.isSemiPublic() || this.isSemiPublic() == flag, LibConstants.UNSUPPORTED_OPERATION);\\n    s.isSemiPublic = flag;\\n    // Emit!\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n  }\\n\\n  // Provisioning functions.\\n\\n  function provisionWithEth()\\n      external payable {\\n    require(msg.value > 0, LibConstants.MISSING_ATTACHED_ETH);\\n    emit EthReceived(msg.sender, msg.value);\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n  }\\n\\n  function drainEth()\\n      onlySpcMember nonContract(msg.sender)\\n      external {\\n    uint256 amount = payable(address(this)).balance;\\n    payable(msg.sender).transfer(amount);\\n    emit EthDrained(msg.sender, amount);\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n  }\\n\\n  /**\\n  * @dev This function allows contracts of the FAST network to request ETH\\n  * provisioning to arbitrary addresses.\\n  */\\n  function payUpTo(address payable recipient, uint256 amount)\\n      nonContract(recipient)\\n      external onlyDiamondFacet {\\n    require(\\n      recipient != address(0),\\n      LibConstants.REQUIRES_NON_ZERO_ADDRESS\\n    );\\n    amount = LibHelpers.upTo(recipient, amount);\\n    // Transfer some eth!\\n    if (amount != 0) { recipient.transfer(amount); }\\n    FastFrontendFacet(address(this)).emitDetailsChanged();\\n  }\\n}\\n\",\"keccak256\":\"0x88af3c18a8c24a15a197f5f08014ba59bb931f410847358beb8ce8ff1baf2085\",\"license\":\"MIT\"},\"contracts/fast/lib/AFastFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibHelpers.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../../interfaces/IHasMembers.sol';\\nimport '../../interfaces/IHasGovernors.sol';\\nimport '../../interfaces/IHasActiveMembers.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../lib/LibFast.sol';\\nimport './IFastEvents.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract AFastFacet is IFastEvents {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\\n  modifier onlyDiamondFacet() {\\n    require(\\n      msg.sender == address(this),\\n      LibConstants.INTERNAL_METHOD\\n    );\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\\n  modifier onlyDiamondOwner() {\\n    require(\\n      msg.sender == IERC173(address(this)).owner(),\\n      LibConstants.REQUIRES_DIAMOND_OWNERSHIP\\n    );\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\\n  modifier onlyDeployer() {\\n    require(\\n      msg.sender == LibConstants.DEPLOYER_CONTRACT,\\n      LibConstants.INTERNAL_METHOD\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is **not** a contract.\\n   *  @param candidate The address to check.\\n   */\\n  modifier nonContract(address candidate) {\\n    require(\\n      !LibHelpers.isContract(candidate),\\n      LibConstants.REQUIRES_NON_CONTRACT_ADDR\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the Exchange.\\n   *  @param candidate The address to check.\\n   */\\n  modifier onlyExchangeMember(address candidate) {\\n    require(\\n      IHasMembers(LibFast.data().exchange).isMember(candidate),\\n      LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures a candidate is active.\\n   *  @param candidate The address to check activation status on.\\n   */\\n  modifier onlyExchangeActiveMember(address candidate) {\\n    require(\\n      IHasActiveMembers(LibFast.data().exchange).isMemberActive(candidate),\\n      LibConstants.REQUIRES_EXCHANGE_ACTIVE_MEMBER\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures that the message sender is a member of the SPC.\\n   */\\n  modifier onlySpcMember() {\\n    require(\\n      IHasMembers(LibFast.data().spc).isMember(msg.sender),\\n      LibConstants.REQUIRES_SPC_MEMBERSHIP\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a governor of the FAST.\\n   *  @param candidate The address to check.\\n   */\\n  modifier onlyGovernor(address candidate) {\\n    require(\\n      IHasGovernors(address(this)).isGovernor(candidate),\\n      LibConstants.REQUIRES_FAST_GOVERNORSHIP\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the FAST.\\n   *  @param candidate The address to check.\\n   */\\n  modifier onlyMember(address candidate) {\\n    require(\\n      IHasMembers(address(this)).isMember(candidate),\\n      LibConstants.REQUIRES_FAST_MEMBERSHIP\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures address a is different from address b.\\n   *  @param a Address a\\n   *  @param b Address b\\n   */\\n  modifier differentAddresses(address a, address b) {\\n    require(a != b, LibConstants.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x4c2776adecc2aea74aec923b1e416820e9e224f91f378b6bde4f95a914d531b2\",\"license\":\"MIT\"},\"contracts/fast/lib/IFast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IFast {\\n  function isSemiPublic() external view returns(bool);\\n  function hasFixedSupply() external view returns(bool);\\n}\\n\",\"keccak256\":\"0xea7b5645ce61b4f3c399bb1696603c57833e1f0b2fcce935f6420f55d602ba64\",\"license\":\"MIT\"},\"contracts/fast/lib/IFastEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IFastEvents {\\n  // ETH provisioning events.\\n\\n  /** @dev Emited when someone provisions this SPC with Eth.\\n   *  @param from The sender of the Eth.\\n   *  @param amount The quantity of Eth, expressed in Wei.\\n   */\\n  event EthReceived(address indexed from, uint256 amount);\\n  /** @dev Emited when Eth is drained from this SPC.\\n   *  @param to The caller and recipient of the drained Eth.\\n   *  @param amount The quantity of Eth that was drained, expressed in Wei.\\n   */\\n  event EthDrained(address indexed to, uint256 amount);\\n\\n  // IHasMembers.\\n\\n  event MemberAdded(address indexed member);\\n  event MemberRemoved(address indexed member);\\n\\n  // IHasGovernors.\\n\\n  event GovernorAdded(address indexed governor);\\n  event GovernorRemoved(address indexed governor);\\n\\n  // Token related events.\\n\\n  // Issuance related events.\\n  event Minted(uint256 indexed amount, string indexed ref);\\n  event Burnt(uint256 indexed amount, string indexed ref);\\n\\n  // Transfer credits related events.\\n  event TransferCreditsAdded(address indexed spcMember, uint256 amount);\\n  event TransferCreditsDrained(address indexed spcMember, uint256 amount);\\n\\n  // ERC20 stuff.\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n  event Disapproval(address indexed owner, address indexed spender);\\n\\n  // General events.\\n\\n  // This is an event that is fired whenever any of some of the FAST parameters\\n  // change, so that the frontend can react to it and refresh the general header\\n  // for that fast as well as the baseball cards in the FASTs list.\\n  event DetailsChanged(\\n    uint256 memberCount,\\n    uint256 governorCount,\\n    uint256 totalSupply,\\n    uint256 transferCredits,\\n    uint256 reserveBalance,\\n    uint256 ethBalance\\n  );\\n}\\n\",\"keccak256\":\"0xee03f5d995981475006529690d658b6e74d1eb154071080568000d3ac746f26b\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibFast {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705;\\n\\n  // Data structures.\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev The internal pointer to the SPC contract.\\n    address spc;\\n    /// @dev The internal pointer to the Exchange contract.\\n    address exchange;\\n    /// @dev We have to track whether the token facet provides continuous minting or fixed supply.\\n    bool hasFixedSupply;\\n    /// @dev Whether or not this FAST requires to be a member to hold tokens.\\n    bool isSemiPublic;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xc32df23d24f8ec8c918f1caeb8ca984bfe2ac1b7c370f24ad2a70a52e9d4e999\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastAccess.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\nlibrary LibFastAccess {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.Access'):\\n  bytes32 internal constant STORAGE_SLOT = 0x87ed8063ac9ead3b2eb7551ed3d89b29fcbf44d6733084b5c82e95d5120ece9a;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev We hold the list of the FAST governors in there.\\n    LibAddressSet.Data governorSet;\\n    // @dev The FAST members are held in there.\\n    LibAddressSet.Data memberSet;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x9744c77467b854899d5b5f9beaf4665f461adc8110432d174601a97f00e594ad\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastHistory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibFastHistory {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.History'):\\n  bytes32 internal constant STORAGE_SLOT = 0x6bc8b61a9dd5fc049ea98027492a801d74e35fdf4d80d7fecd551a16e88fdbb4;\\n\\n  // Storage structures.\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev All minting proofs are kept here.\\n    SupplyProof[] supplyProofs;\\n    /// @dev All transfer proofs are kept here.\\n    TransferProof[] transferProofs;\\n    /// @dev All transfers indices involving a given address are kept here.\\n    mapping(address => uint256[]) transferProofInvolvements;\\n  }\\n\\n  // Other structures.\\n\\n  /// @dev A minting operation could either be to mint or unmint tokens.\\n  enum SupplyOp { Mint, Burn }\\n\\n  /// @dev Minting operations are recorded for papertrail. This is the structure that keeps track of them.\\n  struct SupplyProof {\\n    SupplyOp op;\\n    uint256 amount;\\n    uint256 blockNumber;\\n    string ref;\\n  }\\n\\n  /// @dev Every transfer in is recorded. This is the structure that keeps track of them.\\n  struct TransferProof {\\n    address spender;\\n    address from;\\n    address to;\\n    uint256 amount;\\n    uint256 blockNumber;\\n    string ref;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xd6af0fc0867dd0259fa6e0797f2b46cffac8a36f0380bf266e3ccf778aeb724c\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibFastToken {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.Token'):\\n  bytes32 internal constant STORAGE_SLOT = 0xb098747b87c5c0e2a32eb9b06725e9bad4263809bcda628ceadc1a686bcb8261;\\n\\n  // Constants.\\n\\n  // ERC1404 Restriction codes.\\n  uint8 internal constant INSUFFICIENT_TRANSFER_CREDITS_CODE = 1;\\n  uint8 internal constant REQUIRES_FAST_MEMBERSHIP_CODE = 2;\\n  uint8 internal constant REQUIRES_EXCHANGE_MEMBERSHIP_CODE = 3;\\n  uint8 internal constant REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE = 4;\\n\\n  string internal constant DEFAULT_TRANSFER_REFERENCE = 'Unspecified - via ERC20';\\n\\n  // Data structures.\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    // ERC20 related properties for this FAST Token.\\n    string name;\\n    string symbol;\\n    uint256 decimals;\\n    uint256 totalSupply;\\n    // Every time a transfer is executed, the credit decreases by the amount\\n    // of said transfer.\\n    // It becomes impossible to transact once it reaches zero, and must\\n    // be provisioned by an SPC governor.\\n    uint256 transferCredits;\\n    // Our members balances are held here.\\n    mapping(address => uint256) balances;\\n    // Allowances are stored here.\\n    mapping(address => mapping(address => uint256)) allowances;\\n    mapping(address => LibAddressSet.Data) allowancesByOwner;\\n    mapping(address => LibAddressSet.Data) allowancesBySpender;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x7255ca8c82f392258f4178b5c80b66c83796e9f25460f9ca690f5c5e250e03db\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0x7aca95eacea757ff86be09ed6f309fde42e402530ac7beae002e3c2586439a01\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\",\"keccak256\":\"0x10884024af2c0f7deca0fac4ddf84e76da5dba35b6e02fabeac8ea54c1a5c6f7\",\"license\":\"MIT\"},\"contracts/interfaces/IERC1404.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\n/**\\n * @dev Interface of the ERC1404 standard as defined in the EIP.\\n */\\ninterface IERC1404 {\\n  /**\\n   * @dev Returns a transfer restriction error code if the transfer shoudln't be permitted,\\n   *      or otherwise returns zero if everything looks fine.\\n   * @param owner is the account from which the tokens should be transfered.\\n   * @param recipient is the target of the transfer.\\n   * @param amount is the amount to be transfered.\\n   * @return a uint8 error code if a problem was detected, otherwise zero.\\n   */\\n  function detectTransferRestriction(address owner, address recipient, uint256 amount)\\n    external\\n    view\\n    returns (uint8);\\n\\n  /**\\n   * @dev Maps a transfer restriction error code into a human-readable string.\\n   * @param code is the code that should be transformed into a string.\\n   * @return A string that describes the given error code.\\n   */\\n  function messageForTransferRestriction(uint8 code) external pure returns (string memory);\\n}\\n\",\"keccak256\":\"0x9ecaada095d66283dda203f77cdd17d18f82bdf58d6fbe7830fc87aed2a80c38\",\"license\":\"MIT\"},\"contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xb736f4923109f238e3bf2d8c71b636a24ca4d56c1206e003348584e4aa4ed263\",\"license\":\"MIT\"},\"contracts/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\",\"keccak256\":\"0x6ab22e74708905d9c31867461fffbd2e24bc6ad094aa1aab39211d99e296ab32\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x207580afc51139c2cac95644bf77d5fbb152b7abb03397e8d3c7992d0e8ad883\",\"license\":\"MIT\"},\"contracts/interfaces/IHasActiveMembers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IHasActiveMembers {\\n  function isMemberActive(address member) external view returns(bool);\\n  function deactivateMember(address payable member) external;\\n  function activateMember(address member) external;\\n}\\n\",\"keccak256\":\"0x59859780a1d3a37c35d1dd2516434b170d49d044ef20918aa565703ab8f4a09a\",\"license\":\"MIT\"},\"contracts/interfaces/IHasGovernors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IHasGovernors {\\n  function isGovernor(address governor) external view returns(bool);\\n  function governorCount() external view returns(uint256);\\n  function paginateGovernors(uint256 index, uint256 perPage) external view returns(address[] memory, uint256);\\n  function addGovernor(address payable governor) external;\\n  function removeGovernor(address governor) external;\\n}\\n\",\"keccak256\":\"0x87c9cb1f7f829c1197834d12eb05763217b0b56be530f1ab6fe0ded4500b5dd0\",\"license\":\"MIT\"},\"contracts/interfaces/IHasMembers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IHasMembers {\\n  function isMember(address member) external view returns(bool);\\n  function memberCount() external view returns(uint256);\\n  function paginateMembers(uint256 index, uint256 perPage) external view returns(address[] memory, uint256);\\n  function addMember(address payable member) external;\\n  function removeMember(address member) external;\\n}\\n\",\"keccak256\":\"0x41cfdd80b0ab31a1e0a00f65cae19690aab7917b2c61faa7f7f478771e9a28ae\",\"license\":\"MIT\"},\"contracts/lib/LibAddressSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibAddressSet {\\n  /// @dev Represents a list of addresses.\\n  struct Data {\\n    mapping(address => uint256) indices;\\n    address[] values;\\n  }\\n\\n  /**\\n   * @dev Adds an item into the storage set. If the address already exists in the\\n   *      set, the function reverts.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to be added.\\n   */\\n  function add(Data storage d, address key, bool noThrow)\\n      internal {\\n    bool exists = contains(d, key);\\n    if (noThrow && exists) { return; }\\n    require(!exists, 'Address already in set');\\n    d.indices[key] = d.values.length;\\n    d.values.push(key);\\n  }\\n\\n  /**\\n   * @dev Removes an item from the storage set. If the address does not exist in the\\n   *      set, the function reverts.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to be removed.\\n   */\\n  function remove(Data storage d, address key, bool noThrow)\\n      internal {\\n    bool exists = contains(d, key);\\n    if (noThrow && !exists) { return; }\\n    require(exists, 'Address does not exist in set');\\n    uint256 lastIndex = d.values.length - 1;\\n    address keyToMove = d.values[lastIndex];\\n    uint256 idxToReplace = d.indices[key];\\n    d.indices[keyToMove] = idxToReplace;\\n    d.values[idxToReplace] = keyToMove;\\n    delete d.indices[key];\\n    d.values.pop();\\n  }\\n\\n  /**\\n   * @dev Tests whether or not a given item already exists in the set.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to test.\\n   * @return a boolean.\\n   */\\n  function contains(Data storage d, address key)\\n      internal view returns(bool) {\\n    return d.values.length == 0\\n      ? false\\n      : d.values[d.indices[key]] == key;\\n  }\\n}\\n\",\"keccak256\":\"0x7daf050d0864e085c227521b1157b4ea652fe75ea7e10f685027b42d6e1caf87\",\"license\":\"MIT\"},\"contracts/lib/LibConstants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibConstants {\\n  address internal constant ZERO_ADDRESS = address(0);\\n  address internal constant DEPLOYER_CONTRACT = 0x6DF2D25d8C6FD680730ee658b530A05a99BB769a;\\n\\n  string internal constant ALREADY_INITIALIZED = 'Already initialized';\\n  string internal constant INTERNAL_METHOD = 'Internal method';\\n  string internal constant REQUIRES_DIAMOND_OWNERSHIP = 'Requires diamond ownership';\\n  string internal constant REQUIRES_FAST_CONTRACT_CALLER = 'Caller must be a FAST contract';\\n\\n  string internal constant REQUIRES_SPC_MEMBERSHIP = 'Requires SPC membership';\\n  string internal constant REQUIRES_EXCHANGE_MEMBERSHIP = 'Requires Exchange membership';\\n  string internal constant REQUIRES_EXCHANGE_ACTIVE_MEMBER = 'Requires active Exchange member';\\n  string internal constant REQUIRES_EXCHANGE_DEACTIVATED_MEMBER = 'Requires a deactivated Exchange member';\\n\\n  string internal constant REQUIRES_FAST_GOVERNORSHIP = 'Requires FAST governorship';\\n  string internal constant REQUIRES_FAST_MEMBERSHIP = 'Requires FAST membership';\\n  string internal constant REQUIRES_NO_FAST_MEMBERSHIPS = 'Member still part of at least one FAST';\\n\\n  string internal constant DUPLICATE_ENTRY = 'Duplicate entry';\\n  string internal constant UNSUPPORTED_OPERATION = 'Unsupported operation';\\n  string internal constant REQUIRES_NON_ZERO_ADDRESS = 'Requires non-zero address';\\n  string internal constant REQUIRES_NON_CONTRACT_ADDR = 'Address cannot be a contract';\\n\\n  string internal constant MISSING_ATTACHED_ETH = 'Missing attached ETH';\\n\\n  string internal constant REQUIRES_CONTINUOUS_SUPPLY = 'Requires continuous supply';\\n  string internal constant INSUFFICIENT_FUNDS = 'Insufficient token balance';\\n  string internal constant INSUFFICIENT_ALLOWANCE = 'Insufficient allowance';\\n  string internal constant INSUFFICIENT_TRANSFER_CREDITS = 'Insufficient transfer credits';\\n  string internal constant REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT = 'Requires different sender and recipient';\\n  string internal constant UNKNOWN_RESTRICTION_CODE = 'Unknown restriction code';\\n}\\n\",\"keccak256\":\"0xb3fd352142cec908fdb78eadd41eb77db8bb1680b38599bc40197b51c013c951\",\"license\":\"MIT\"},\"contracts/lib/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x1c1bcc2f4ce958b3569ec95530879a584e4cf837d585a5059b3b612ad4a71a47\",\"license\":\"MIT\"},\"contracts/lib/LibHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nlibrary LibHelpers {\\n  function upTo(address payable to, uint256 amount)\\n      internal view returns(uint256) {\\n    // If the recipient has more than what is ought to be paid, return.\\n    uint256 toBalance = to.balance;\\n    if (toBalance >= amount) { return 0; }\\n    // If the recipient has some Eth we should only pay the top-up.\\n    amount = amount - toBalance;\\n    // If the available eth is less than what we should pay, just cap it.\\n    uint256 available = payable(address(this)).balance;\\n    if (available < amount) { amount = available; }\\n    // Provision the new fast with Eth.\\n    return amount;\\n  }\\n\\n  function isContract(address target)\\n      internal view returns (bool) {\\n    uint32 size;\\n    assembly { size := extcodesize(target) }\\n    return (size > 0);\\n  }\\n}\\n\",\"keccak256\":\"0xa3ac21d8e6e5f25d9125d2975e7157e5c660bd481fb102c39a64810955d6eaab\",\"license\":\"MIT\"},\"contracts/lib/LibPaginate.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../fast/lib/LibFastHistory.sol';\\n\\n\\nlibrary LibPaginate {\\n  function addresses(address[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(address[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      address[] memory values = new address[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function uint256s(uint256[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(uint256[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      uint256[] memory values = new uint256[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function supplyProofs(LibFastHistory.SupplyProof[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(LibFastHistory.SupplyProof[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      LibFastHistory.SupplyProof[] memory values = new LibFastHistory.SupplyProof[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function transferProofs(LibFastHistory.TransferProof[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n}\",\"keccak256\":\"0xedbf24531aa1b21a17a7962b2053fe1bd81ddf9e8869f508f14f7fb9087631d9\",\"license\":\"MIT\"},\"contracts/spc/SpcTopFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../lib/LibHelpers.sol';\\nimport '../fast/FastTopFacet.sol';\\nimport '../fast/FastTokenFacet.sol';\\nimport './lib/ASpcFacet.sol';\\nimport './lib/LibSpc.sol';\\n\\n\\ncontract SpcTopFacet is ASpcFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n  // Constants.\\n\\n  // This represents how much Eth we provision new SPC members with.\\n  uint256 constant private MEMBER_ETH_PROVISION = 10 ether;\\n  // This represents how much Eth new FASTs are provisioned with.\\n  uint256 constant private FAST_ETH_PROVISION = 250 ether;\\n\\n  // Eth provisioning stuff.\\n\\n  /** @dev A function that alllows provisioning this SPC with Eth.\\n   *  @notice Emits a `EthReceived` event.\\n   */\\n  function provisionWithEth()\\n      external payable {\\n    require(msg.value > 0, LibConstants.MISSING_ATTACHED_ETH);\\n    emit EthReceived(msg.sender, msg.value);\\n  }\\n\\n  /** @dev A function that alllows draining this SPC from its Eth.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `EthDrained` event.\\n   */\\n  function drainEth()\\n      onlyMember(msg.sender) nonContract(msg.sender)\\n      external {\\n    uint256 amount = payable(address(this)).balance;\\n    payable(msg.sender).transfer(amount);\\n    emit EthDrained(msg.sender, amount);\\n  }\\n\\n  // FAST management related methods.\\n\\n  /** @dev Queries whether a given address is a known and registered FAST contract.\\n   * @param fast The address of the contract to check.\\n   * @return A boolean.\\n   */\\n  function isFastRegistered(address fast)\\n      external view returns(bool) {\\n    return LibSpc.data().fastSet.contains(fast);\\n  }\\n\\n  /** @dev Allows to retrieve the address of a FAST diamond given its symbol.\\n   *  @param symbol The symbol of the FAST diamond to get the address of.\\n   *  @return The address of the corresponding FAST diamond, or the Zero Address if not found.\\n   */\\n  function fastBySymbol(string calldata symbol)\\n      external view returns(address) {\\n    return LibSpc.data().fastSymbols[symbol];\\n  }\\n\\n  /** @dev Allows the registration of a given FAST diamond with this SPC.\\n   *  @param fast The address of the FAST diamond to be registered.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `FastRegistered` event.\\n   */\\n  function registerFast(address fast)\\n      external\\n      onlyMember(msg.sender) {\\n    LibSpc.Data storage s = LibSpc.data();\\n    string memory symbol = FastTokenFacet(fast).symbol();\\n    require(s.fastSymbols[symbol] == address(0), LibConstants.DUPLICATE_ENTRY);\\n\\n    // Add the FAST to our list.\\n    s.fastSet.add(fast, false);\\n    // Add the fast symbol to our list.\\n    s.fastSymbols[symbol] = fast;\\n\\n    // Provision the new fast with Eth.\\n    uint256 amount = LibHelpers.upTo(payable(fast), FAST_ETH_PROVISION);\\n    // Only provision the fast if possible.\\n    if (amount > 0) {\\n      FastTopFacet(fast).provisionWithEth{ value: amount }();\\n    }\\n    // Emit!\\n    emit FastRegistered(fast);\\n  }\\n\\n  /** @dev Counts the number of FAST diamonds registered with this SPC.\\n   *  @return The number of FAST diamonds registered with this SPC.\\n   */\\n  function fastCount()\\n      external view returns(uint256) {\\n    return LibSpc.data().fastSet.values.length;\\n  }\\n\\n  /** @dev Paginates the FAST diamonds registered with this SPC based on a starting cursor and a number of records per page.\\n   *  @param cursor The index at which to start.\\n   *  @param perPage How many records should be returned at most.\\n   *  @return A `address[]` list of values at most `perPage` big.\\n   *  @return A `uint256` index to the next page.\\n   */\\n  function paginateFasts(uint256 cursor, uint256 perPage)\\n      external view\\n      returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibSpc.data().fastSet.values, cursor, perPage);\\n  }\\n}\\n\",\"keccak256\":\"0xe28d5ccc9649d2caf46ff63b458cad8b39ca4b985c9d4c7cac3274d2b35211fb\",\"license\":\"MIT\"},\"contracts/spc/lib/ASpcFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibHelpers.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../lib/LibSpcAccess.sol';\\nimport './ISpcEvents.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract ASpcFacet is ISpcEvents {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\\n  modifier onlyDiamondFacet() {\\n    require(\\n      msg.sender == address(this),\\n      LibConstants.INTERNAL_METHOD\\n    );\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\\n  modifier onlyDiamondOwner() {\\n    require(\\n      msg.sender == IERC173(address(this)).owner(),\\n      LibConstants.REQUIRES_DIAMOND_OWNERSHIP\\n    );\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is **not** a contract.\\n   *  @param candidate The address to check.\\n   */\\n  modifier nonContract(address candidate) {\\n    require(\\n      !LibHelpers.isContract(candidate),\\n      LibConstants.REQUIRES_NON_CONTRACT_ADDR\\n    );\\n    _;\\n  }\\n\\n  /// @dev Ensures that the given address is a member of the current FAST.\\n  modifier onlyMember(address candidate) {\\n    require(\\n      LibSpcAccess.data().memberSet.contains(candidate),\\n      LibConstants.REQUIRES_SPC_MEMBERSHIP\\n    );\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x597f077c6e26ad90904b1a1d11f5d1d2bc8525b568e98ba492171292b0f5e79d\",\"license\":\"MIT\"},\"contracts/spc/lib/ISpcEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\n// WARNING: These events must be maintained 1:1 with LibSpcEvents!\\n// They also should never be emitted directly, they only help us defining\\n// typescript types!\\ninterface ISpcEvents {\\n  // ETH provisioning events.\\n\\n  /** @dev Emited when someone provisions this SPC with Eth.\\n   *  @param from The sender of the Eth.\\n   *  @param amount The quantity of Eth, expressed in Wei.\\n   */\\n  event EthReceived(address indexed from, uint256 amount);\\n  /** @dev Emited when Eth is drained from this SPC.\\n   *  @param to The caller and recipient of the drained Eth.\\n   *  @param amount The quantity of Eth that was drained, expressed in Wei.\\n   */\\n  event EthDrained(address indexed to, uint256 amount);\\n\\n  // Fast registration events.\\n\\n  /** @dev Emited when a new FAST is registered.\\n   *  @param fast The address of the newly registered FAST diamond.\\n   */\\n  event FastRegistered(address indexed fast);\\n\\n  // IHasMembers.\\n\\n  event MemberAdded(address indexed member);\\n  event MemberRemoved(address indexed member);\\n}\\n\",\"keccak256\":\"0x27e66d85fba410948f2430af4ea6625c4e9ddb67d1e51db29a52fada896d9f82\",\"license\":\"MIT\"},\"contracts/spc/lib/LibSpc.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibSpc {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Spc.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x89a652f66ca129ef71cab44916bb070742a08af428e08a99df145c8006c94285;\\n\\n  // Data structures.\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    // This is where we keep our list of deployed fast FASTs.\\n    LibAddressSet.Data fastSet;\\n    // We keep track of the FAST symbols that were already used.\\n    mapping(string => address) fastSymbols;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x2f1607e60e30bf54c0837ccd996c6266836284ff6f40d1618b93f735d5d86157\",\"license\":\"MIT\"},\"contracts/spc/lib/LibSpcAccess.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibSpcAccess {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Spc.storage.Access'):\\n  bytes32 internal constant STORAGE_SLOT = 0xe275f58a6a7f532ee3fa7fff24450c253df494fca407d91f5c35e83236f64d7c;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    // This is where we hold our members data.\\n    LibAddressSet.Data memberSet;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x29d45304060a54f75b7dfbaada867418c97bac21dd484ac6c777b33f3628eb35\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610ff3806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80631dda7d8f14610030575b600080fd5b61004a60048036038101906100459190610c9c565b61004c565b005b736df2d25d8c6fd680730ee658b530a05a99bb769a73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146040518060400160405280600f81526020017f496e7465726e616c206d6574686f64000000000000000000000000000000000081525090610106576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016100fd9190610d5c565b60405180910390fd5b50600161ffff1661011561086b565b60000160009054906101000a900461ffff1661ffff161061016b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161016290610d9e565b60405180910390fd5b6000610175610893565b905060018160030160007f36372b07000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f01ffc9a7000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f7f5828d0000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007fab84a5c8000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f1f931c1c000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f48e2b093000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f84378070000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007fb4bb4f46000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060006105e161086b565b905060018160000160006101000a81548161ffff021916908361ffff1602179055508260000160208101906106169190610c21565b8160000160026101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555082602001602081019061066b9190610c21565b8160010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508260c00160208101906106c09190610c73565b8160010160146101000a81548160ff0219169083151502179055508260e00160208101906106ee9190610c73565b8160010160156101000a81548160ff02191690831515021790555060006107136108c0565b905060018160000160006101000a81548161ffff021916908361ffff16021790555061076084604001602081019061074b9190610c4a565b6000836001016108e89092919063ffffffff16565b8360400160208101906107739190610c4a565b73ffffffffffffffffffffffffffffffffffffffff167fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b560405160405180910390a260006107bf610a05565b905060018160000160006101000a81548161ffff021916908361ffff1602179055508480606001906107f19190610dbe565b8680608001906108019190610dbe565b8860a0013585600101600087600201600089600301600086919050558686909192909192509190610833929190610b23565b50868690919290919250919061084a929190610b23565b50505050505060008160040181905550600081600501819055505050505050565b60007f80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705905090565b6000807fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90508091505090565b60007f87ed8063ac9ead3b2eb7551ed3d89b29fcbf44d6733084b5c82e95d5120ece9a905090565b60006108f48484610a2d565b90508180156109005750805b1561090b5750610a00565b801561094c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161094390610d7e565b60405180910390fd5b83600101805490508460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555083600101839080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505b505050565b60007fb098747b87c5c0e2a32eb9b06725e9bad4263809bcda628ceadc1a686bcb8261905090565b600080836001018054905014610b18578173ffffffffffffffffffffffffffffffffffffffff16836001018460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205481548110610ad1577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610b1b565b60005b905092915050565b828054610b2f90610eb4565b90600052602060002090601f016020900481019282610b515760008555610b98565b82601f10610b6a57803560ff1916838001178555610b98565b82800160010185558215610b98579182015b82811115610b97578235825591602001919060010190610b7c565b5b509050610ba59190610ba9565b5090565b5b80821115610bc2576000816000905550600101610baa565b5090565b600081359050610bd581610f78565b92915050565b600081359050610bea81610f8f565b92915050565b600081359050610bff81610fa6565b92915050565b60006101008284031215610c1857600080fd5b81905092915050565b600060208284031215610c3357600080fd5b6000610c4184828501610bc6565b91505092915050565b600060208284031215610c5c57600080fd5b6000610c6a84828501610bdb565b91505092915050565b600060208284031215610c8557600080fd5b6000610c9384828501610bf0565b91505092915050565b600060208284031215610cae57600080fd5b600082013567ffffffffffffffff811115610cc857600080fd5b610cd484828501610c05565b91505092915050565b6000610ce882610e15565b610cf28185610e20565b9350610d02818560208601610e81565b610d0b81610f15565b840191505092915050565b6000610d23601683610e20565b9150610d2e82610f26565b602082019050919050565b6000610d46601383610e20565b9150610d5182610f4f565b602082019050919050565b60006020820190508181036000830152610d768184610cdd565b905092915050565b60006020820190508181036000830152610d9781610d16565b9050919050565b60006020820190508181036000830152610db781610d39565b9050919050565b60008083356001602003843603038112610dd757600080fd5b80840192508235915067ffffffffffffffff821115610df557600080fd5b602083019250600182023603831315610e0d57600080fd5b509250929050565b600081519050919050565b600082825260208201905092915050565b6000610e3c82610e61565b9050919050565b6000610e4e82610e61565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60005b83811015610e9f578082015181840152602081019050610e84565b83811115610eae576000848401525b50505050565b60006002820490506001821680610ecc57607f821691505b60208210811415610ee057610edf610ee6565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000601f19601f8301169050919050565b7f4164647265737320616c726561647920696e2073657400000000000000000000600082015250565b7f416c726561647920696e697469616c697a656400000000000000000000000000600082015250565b610f8181610e31565b8114610f8c57600080fd5b50565b610f9881610e43565b8114610fa357600080fd5b50565b610faf81610e55565b8114610fba57600080fd5b5056fea26469706673582212207b567036f19a89201a5210de05c8bfcbeadcc1e6f471bfae2d07a808a91c566664736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80631dda7d8f14610030575b600080fd5b61004a60048036038101906100459190610c9c565b61004c565b005b736df2d25d8c6fd680730ee658b530a05a99bb769a73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146040518060400160405280600f81526020017f496e7465726e616c206d6574686f64000000000000000000000000000000000081525090610106576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016100fd9190610d5c565b60405180910390fd5b50600161ffff1661011561086b565b60000160009054906101000a900461ffff1661ffff161061016b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161016290610d9e565b60405180910390fd5b6000610175610893565b905060018160030160007f36372b07000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f01ffc9a7000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f7f5828d0000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007fab84a5c8000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f1f931c1c000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f48e2b093000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007f84378070000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060018160030160007fb4bb4f46000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff02191690831515021790555060006105e161086b565b905060018160000160006101000a81548161ffff021916908361ffff1602179055508260000160208101906106169190610c21565b8160000160026101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555082602001602081019061066b9190610c21565b8160010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508260c00160208101906106c09190610c73565b8160010160146101000a81548160ff0219169083151502179055508260e00160208101906106ee9190610c73565b8160010160156101000a81548160ff02191690831515021790555060006107136108c0565b905060018160000160006101000a81548161ffff021916908361ffff16021790555061076084604001602081019061074b9190610c4a565b6000836001016108e89092919063ffffffff16565b8360400160208101906107739190610c4a565b73ffffffffffffffffffffffffffffffffffffffff167fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b560405160405180910390a260006107bf610a05565b905060018160000160006101000a81548161ffff021916908361ffff1602179055508480606001906107f19190610dbe565b8680608001906108019190610dbe565b8860a0013585600101600087600201600089600301600086919050558686909192909192509190610833929190610b23565b50868690919290919250919061084a929190610b23565b50505050505060008160040181905550600081600501819055505050505050565b60007f80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705905090565b6000807fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90508091505090565b60007f87ed8063ac9ead3b2eb7551ed3d89b29fcbf44d6733084b5c82e95d5120ece9a905090565b60006108f48484610a2d565b90508180156109005750805b1561090b5750610a00565b801561094c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161094390610d7e565b60405180910390fd5b83600101805490508460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555083600101839080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505b505050565b60007fb098747b87c5c0e2a32eb9b06725e9bad4263809bcda628ceadc1a686bcb8261905090565b600080836001018054905014610b18578173ffffffffffffffffffffffffffffffffffffffff16836001018460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205481548110610ad1577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610b1b565b60005b905092915050565b828054610b2f90610eb4565b90600052602060002090601f016020900481019282610b515760008555610b98565b82601f10610b6a57803560ff1916838001178555610b98565b82800160010185558215610b98579182015b82811115610b97578235825591602001919060010190610b7c565b5b509050610ba59190610ba9565b5090565b5b80821115610bc2576000816000905550600101610baa565b5090565b600081359050610bd581610f78565b92915050565b600081359050610bea81610f8f565b92915050565b600081359050610bff81610fa6565b92915050565b60006101008284031215610c1857600080fd5b81905092915050565b600060208284031215610c3357600080fd5b6000610c4184828501610bc6565b91505092915050565b600060208284031215610c5c57600080fd5b6000610c6a84828501610bdb565b91505092915050565b600060208284031215610c8557600080fd5b6000610c9384828501610bf0565b91505092915050565b600060208284031215610cae57600080fd5b600082013567ffffffffffffffff811115610cc857600080fd5b610cd484828501610c05565b91505092915050565b6000610ce882610e15565b610cf28185610e20565b9350610d02818560208601610e81565b610d0b81610f15565b840191505092915050565b6000610d23601683610e20565b9150610d2e82610f26565b602082019050919050565b6000610d46601383610e20565b9150610d5182610f4f565b602082019050919050565b60006020820190508181036000830152610d768184610cdd565b905092915050565b60006020820190508181036000830152610d9781610d16565b9050919050565b60006020820190508181036000830152610db781610d39565b9050919050565b60008083356001602003843603038112610dd757600080fd5b80840192508235915067ffffffffffffffff821115610df557600080fd5b602083019250600182023603831315610e0d57600080fd5b509250929050565b600081519050919050565b600082825260208201905092915050565b6000610e3c82610e61565b9050919050565b6000610e4e82610e61565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60005b83811015610e9f578082015181840152602081019050610e84565b83811115610eae576000848401525b50505050565b60006002820490506001821680610ecc57607f821691505b60208210811415610ee057610edf610ee6565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000601f19601f8301169050919050565b7f4164647265737320616c726561647920696e2073657400000000000000000000600082015250565b7f416c726561647920696e697469616c697a656400000000000000000000000000600082015250565b610f8181610e31565b8114610f8c57600080fd5b50565b610f9881610e43565b8114610fa357600080fd5b50565b610faf81610e55565b8114610fba57600080fd5b5056fea26469706673582212207b567036f19a89201a5210de05c8bfcbeadcc1e6f471bfae2d07a808a91c566664736f6c63430008040033",
  "devdoc": {
    "details": "Note that although this contract doesn't explicitelly inherit from IERC173, ERC165, IDiamondLoupe etc, all       methods are in fact implemented by the underlaying Diamond proxy. It is therefore safe to       perform casts directly on the current contract address into these interfaces.",
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}