{
  "language": "Solidity",
  "sources": {
    "contracts/fast/FastAccessFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../interfaces/IHasMembers.sol';\nimport '../interfaces/IHasGovernors.sol';\nimport '../lib/LibAddressSet.sol';\nimport '../lib/LibPaginate.sol';\nimport '../marketplace/MarketplaceAccessFacet.sol';\nimport '../issuer/IssuerAccessFacet.sol';\nimport './FastTokenFacet.sol';\nimport './lib/AFastFacet.sol';\nimport './lib/LibFast.sol';\nimport './lib/LibFastAccess.sol';\nimport './FastTopFacet.sol';\nimport './FastFrontendFacet.sol';\n\n\n/**\n * @notice The FAST Access facet is the source of truth when it comes to\n * permissioning and ACLs within a given FAST.\n */\ncontract FastAccessFacet is AFastFacet, IHasMembers, IHasGovernors {\n  using LibAddressSet for LibAddressSet.Data;\n  // Structs.\n\n  /**\n   * @notice This structure isn't used anywhere in storage. Instead, it\n   * allows various methods of the contract to return all the flags\n   * associated with a given address in one go.\n   */\n  struct Flags {\n    /// @notice Whether or not the item in scope is considered a governor of this FAST.\n    bool isGovernor;\n    /// @notice Whether or not the item in scope is considered a member of this FAST.\n    bool isMember;\n  }\n\n  // Governorship related stuff.\n\n  /// @notice See `IHasGovernors`.\n  function isGovernor(address candidate)\n      external view override returns(bool) {\n    return LibFastAccess.data().governorSet.contains(candidate);\n  }\n\n   /// @notice See `IHasGovernors`.\n  function governorCount()\n      external override view returns(uint256) {\n    return LibFastAccess.data().governorSet.values.length;\n  }\n\n   /// @notice See `IHasGovernors`.\n  function paginateGovernors(uint256 index, uint256 perPage)\n      external override view returns(address[] memory, uint256) {\n    return LibPaginate.addresses(LibFastAccess.\n      data().governorSet.values,\n      index,\n      perPage\n    );\n  }\n\n   /// @notice See `IHasGovernors`.\n  function addGovernor(address payable governor)\n      external override\n      onlyIssuerMember\n      onlyMarketplaceMember(governor) {\n    // Add governor to list.\n    LibFastAccess.data().governorSet.add(governor, false);\n    // Notify issuer that this governor was added to this FAST.\n    IssuerAccessFacet(LibFast.data().issuer).governorAddedToFast(governor);\n    // Emit!\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n    emit GovernorAdded(governor);\n  }\n\n   /// @notice See `IHasGovernors`.\n  function removeGovernor(address governor)\n      external override\n      onlyIssuerMember {\n    // Remove governor.\n    LibFastAccess.data().governorSet.remove(governor, false);\n    // Notify issuer that this governor was removed from this FAST.\n    IssuerAccessFacet(LibFast.data().issuer).governorRemovedFromFast(governor);\n    // Emit!\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n    emit GovernorRemoved(governor);\n  }\n\n  /// Membership related stuff.\n\n   /// @notice See `IHasMembers`.\n  function isMember(address candidate)\n      external override view returns(bool) {\n    return LibFastAccess.data().memberSet.contains(candidate);\n  }\n\n   /// @notice See `IHasMembers`.\n  function memberCount()\n      external override view returns(uint256) {\n    return LibFastAccess.data().memberSet.values.length;\n  }\n\n   /// @notice See `IHasMembers`.\n  function paginateMembers(uint256 index, uint256 perPage)\n      external override view returns(address[] memory, uint256) {\n    return LibPaginate.addresses(\n      LibFastAccess.data().memberSet.values,\n      index,\n      perPage\n    );\n  }\n\n   /// @notice See `IHasMembers`.\n  function addMember(address payable member)\n      external override \n      onlyGovernor(msg.sender) onlyMarketplaceMember(member) {\n    // Add the member.\n    LibFastAccess.data().memberSet.add(member, false);\n    // Notify marketplace that this member was added to this FAST.\n    MarketplaceAccessFacet(LibFast.data().marketplace).memberAddedToFast(member);\n    // Emit!\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n    emit MemberAdded(member);\n  }\n\n   /// @notice See `IHasMembers`.\n  function removeMember(address member)\n      external override \n      onlyGovernor(msg.sender) {\n    // Remove member.\n    LibFastAccess.data().memberSet.remove(member, false);\n    // Notify token facet that this member was removed.\n    FastTokenFacet(address(this)).beforeRemovingMember(member);\n    // Notify marketplace that this member was removed from this FAST.\n    MarketplaceAccessFacet(LibFast.data().marketplace).memberRemovedFromFast(member);\n    // Emit!\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n    emit MemberRemoved(member);\n  }\n\n  /// Flags.\n\n  /**\n   * @notice Retrieves flags for a given address.\n   * @param a is the address to retrieve flags for.\n   * @return A `Flags` struct.\n   */\n  function flags(address a)\n      external view returns(Flags memory) {\n    LibFastAccess.Data storage s = LibFastAccess.data();\n    return\n      Flags({\n        isGovernor: s.governorSet.contains(a),\n        isMember: s.memberSet.contains(a)\n      });\n  }\n}\n"
    },
    "contracts/fast/FastFrontendFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../lib/LibAddressSet.sol';\nimport '../lib/LibPaginate.sol';\nimport './lib/AFastFacet.sol';\nimport './lib/LibFastAccess.sol';\nimport './lib/LibFastToken.sol';\n\n\n/**\n * @notice A facet dedicated to view / UI only methods. This facet should never hold any method that\n * is not either `pure` or `view`, except to emit events.\n */\ncontract FastFrontendFacet is AFastFacet {\n  using LibAddressSet for LibAddressSet.Data;\n\n  // Data structures.\n\n  /**\n   * @notice This struct groups the common attributes of a FAST.\n   * @dev This struct shouldn't be used in internal storage.\n   */\n  struct Details {\n    /// @notice The `address` of the FAST.\n    address addr;\n    /// @notice The `name` of the FAST (ERC20).\n    string name;\n    /// @notice The `symbol` of the FAST (ERC20).\n    string symbol;\n    /// @notice The `decimals` of the FAST (ERC20).\n    uint8 decimals;\n    /// @notice The `totalSupply` of the FAST (ERC20).\n    uint256 totalSupply;\n    /// @notice Whether the FAST is semi public or not.\n    bool isSemiPublic;\n    /// @notice Whether the FAST has a fixed supply or continious.\n    bool hasFixedSupply;\n    /// @notice Whether the transfers are enabled or not for this FAST.\n    bool transfersDisabled;\n    /// @notice The reserve balance.\n    uint256 reserveBalance;\n    /// @notice The Ether balance.\n    uint256 ethBalance;\n    /// @notice The number of members the FAST has.\n    uint256 memberCount;\n    /// @notice The number of governors for the FAST.\n    uint256 governorCount;\n  }\n\n  /**\n   * @notice Member level details.\n   * @dev This struct shouldn't be used in internal storage.\n   */\n  struct MemberDetails {\n    /// @notice The Member's address.\n    address addr;\n    /// @notice The Member's balance.\n    uint256 balance;\n    uint256 ethBalance;\n    /// @notice Whether the Member is also a Governor.\n    bool isGovernor;\n  }\n\n  /**\n   * @notice Governor level details.\n   * @dev Note that **this struct shouldn't be used in internal storage**.\n   */\n  struct GovernorDetails {\n    /// @notice The Governor's address.\n    address addr;\n    uint256 ethBalance;\n    /// @notice Whether the Governor is also a Member.\n    bool isMember;\n  }\n\n  // Emitters.\n\n  /**\n   * @notice Called by diamond facets, signals that FAST details may have changed.\n   * \n   * Business logic:\n   * - Modifiers:\n   *   - Requires the caller to be another facet of the diamond.\n   * Emits `DetailsChanged`, see `IFastEvents.DetailsChanged`\n   */\n  function emitDetailsChanged()\n      external onlyDiamondFacet {\n    LibFastAccess.Data storage accessData = LibFastAccess.data();\n    LibFastToken.Data storage tokenData = LibFastToken.data();\n    emit DetailsChanged({\n      transfersDisabled: LibFast.data().transfersDisabled,\n      memberCount: accessData.memberSet.values.length,\n      governorCount: accessData.governorSet.values.length,\n      totalSupply: tokenData.totalSupply,\n      reserveBalance: tokenData.balances[LibConstants.ZERO_ADDRESS],\n      ethBalance: payable(address(this)).balance\n    });\n  }\n\n  // Public functions.\n\n  /**\n   * @notice Gets the details of a FAST.\n   * @return The details for the current FAST, see `Details`.\n   */\n  function details()\n      public view returns(Details memory) {\n    LibFast.Data storage topStorage = LibFast.data();\n    LibFastAccess.Data storage accessStorage = LibFastAccess.data();\n    LibFastToken.Data storage tokenStorage = LibFastToken.data();\n    return Details({\n      addr: address(this),\n      name: tokenStorage.name,\n      symbol: tokenStorage.symbol,\n      decimals: tokenStorage.decimals,\n      totalSupply: tokenStorage.totalSupply,\n      isSemiPublic: topStorage.isSemiPublic,\n      hasFixedSupply: topStorage.hasFixedSupply,\n      transfersDisabled: topStorage.transfersDisabled,\n      reserveBalance: tokenStorage.balances[LibConstants.ZERO_ADDRESS],\n      ethBalance: payable(address(this)).balance,\n      memberCount: accessStorage.memberSet.values.length,\n      governorCount: accessStorage.governorSet.values.length\n    });\n  }\n\n  /**\n   * @notice Gets detailed member details.\n   * @return A FAST member's details, see `MemberDetails`.\n   */\n  function detailedMember(address member)\n      public view returns(MemberDetails memory) {\n    return MemberDetails({\n      addr: member,\n      balance: LibFastToken.data().balances[member],\n      ethBalance: member.balance,\n      isGovernor: LibFastAccess.data().governorSet.contains(member)\n    });\n  }\n\n  /**\n   * @notice Gets detailed governor details.\n   * @return GovernorDetails See: `GovernorDetails`.\n   */\n  function detailedGovernor(address governor)\n      public view returns(GovernorDetails memory) {\n    return GovernorDetails({\n      addr: governor,\n      ethBalance: governor.balance,\n      isMember: LibFastAccess.data().memberSet.contains(governor)\n    });\n  }\n\n  function paginateDetailedMembers(uint256 index, uint256 perPage)\n      external view returns(MemberDetails[] memory, uint256) {\n    (address[] memory members, uint256 nextCursor) =\n      LibPaginate.addresses(LibFastAccess.data().memberSet.values, index, perPage);\n    MemberDetails[] memory values = new MemberDetails[](members.length);\n    uint256 length = members.length;\n    for (uint256 i = 0; i < length;) {\n      values[i] = detailedMember(members[i]);\n      unchecked { ++i; }\n    }\n    return (values, nextCursor);\n  }\n\n  function paginateDetailedGovernors(uint256 index, uint256 perPage)\n      external view returns(GovernorDetails[] memory, uint256) {\n    (address[] memory governors, uint256 nextCursor) =\n      LibPaginate.addresses(LibFastAccess.data().governorSet.values, index, perPage);\n    GovernorDetails[] memory values = new GovernorDetails[](governors.length);\n    uint256 length =  governors.length;\n    for (uint256 i = 0; i < length;) {\n      values[i] = detailedGovernor(governors[i]);\n      unchecked { ++i; }\n    }\n    return (values, nextCursor);\n  }\n}\n"
    },
    "contracts/fast/FastHistoryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../lib/LibPaginate.sol';\nimport './lib/AFastFacet.sol';\nimport './lib/LibFastHistory.sol';\n\n\n/**\n * @notice Although past events could be scrapped from the chain, we want to\n * the frontend to be capable of listing past transfers and minting / burning events.\n * This facet is in charge of performing archival of these things.\n */\ncontract FastHistoryFacet is AFastFacet {\n  /// Minting history-keeping methods.\n\n  /**\n   * @notice This method is a callback for other facets to signal whenever new tokens are minted.\n   * \n   * Business logic:\n   * - Requires that the caller must be another facet.\n   * - Adds a supply proof item of type `LibFastHistory.SupplyOp.Mint` on top of the stack.\n   */\n  function minted(uint256 amount, string calldata ref)\n      external onlyDiamondFacet() {\n    // Keep track of the mint.\n    LibFastHistory.data().supplyProofs.push(\n      LibFastHistory.SupplyProof({\n        op: LibFastHistory.SupplyOp.Mint,\n        amount: amount,\n        blockNumber: block.number,\n        ref: ref\n      })\n    );\n  }\n\n  /**\n   * @notice This method is a callback for other facets to signal whenever new tokens are burnt.\n   * \n   * Business logic:\n   * - Requires that the caller must be another facet.\n   * - Adds a supply proof item of type `LibFastHistory.SupplyOp.Burn` on top of the stack.\n   */\n  function burnt(uint256 amount, string calldata ref)\n      external onlyDiamondFacet() {\n    // Keep track of the unmint.\n    LibFastHistory.data().supplyProofs.push(\n      LibFastHistory.SupplyProof({\n        op: LibFastHistory.SupplyOp.Burn,\n        amount: amount,\n        blockNumber: block.number,\n        ref: ref\n      })\n    );\n  }\n\n  /**\n   * @notice Returns the number of supply proofs (minting and burning together) ever created.\n   * @return A `uint256`.\n   */\n  function supplyProofCount()\n      external view returns(uint256) {\n    return LibFastHistory.data().supplyProofs.length;\n  }\n\n  /**\n   * @notice Returns a page of supply proofs (minting and burning together).\n   * @param cursor is the zero-based index where to start fetching records.\n   * @param perPage is the number of items to return.\n   * @return A `(LibFastHistory.SupplyProof[], uint256)` tuple containing a page of data and the cursor to the next page.\n   */\n  function paginateSupplyProofs(uint256 cursor, uint256 perPage)\n      external view returns(LibFastHistory.SupplyProof[] memory, uint256) {\n    return LibPaginate.supplyProofs(LibFastHistory.data().supplyProofs, cursor, perPage);\n  }\n\n  /// Transfer history-keeping methods.\n\n  /**\n   * @notice This method is a callback for other facets to signal whenever a transfer has completed successfuly.\n   * \n   * Business logic:\n   * - Requires that the caller must be another facet.\n   * - Keeps track of the operation in various tracking structures, so that it can be queried later by `sender` and `recipient`.\n   * - Pushes a transfer proof to the main transfer proof tracking stack.\n   */\n  function transfered(address spender, address from, address to, uint256 amount, string calldata ref)\n      external onlyDiamondFacet() {\n    LibFastHistory.Data storage s = LibFastHistory.data();\n    // Keep track of the transfer proof ID for the sender and for the recipient.\n    s.transferProofInvolvements[from].push(s.transferProofs.length);\n    s.transferProofInvolvements[to].push(s.transferProofs.length);\n    // Keep track of the transfer proof globally.\n    s.transferProofs.push(\n      LibFastHistory.TransferProof({\n        spender: spender,\n        from: from,\n        to: to,\n        amount: amount,\n        blockNumber: block.number,\n        ref: ref\n      })\n    );\n  }\n\n  /**\n   * @notice Returns the number of transfer proofs ever created.\n   * @return A `uint256`.\n   */\n  function transferProofCount()\n      external view returns(uint256) {\n    return LibFastHistory.data().transferProofs.length;\n  }\n\n  /**\n   * @notice Returns a page of transfer proofs.\n   * @param cursor is the zero-based index where to start fetching records.\n   * @param perPage is the number of items to return.\n   * @return A `(LibFastHistory.TransferProof[], uint256)` tuple containing a page of data and the cursor to the next page.\n   */\n  function paginateTransferProofs(uint256 cursor, uint256 perPage)\n      external view returns(LibFastHistory.TransferProof[] memory, uint256) {\n    return LibPaginate.transferProofs(LibFastHistory.data().transferProofs, cursor, perPage);\n  }\n\n  /**\n   * @notice Counts all past inbound and outbound transfers involving a given address.\n   * @param involvee is the address for which to get the transfer proofs.\n   */\n  function transferProofByInvolveeCount(address involvee)\n      external view returns(uint256) {\n    return LibFastHistory.data().transferProofInvolvements[involvee].length;\n  }\n\n  /**\n   * @notice Returns pages of indices of past inbound and outbound transfer proofs by involvee.\n   * @dev This function is reading from an indexing data structure. Each index points to a record\n   * in the main transfer proof storage, and can then be found in `transferProofs` at returned indices.\n   * @param involvee is the address for which to retrieve a page of data.\n   * @param cursor is where to start.\n   * @param perPage is how many records at most should be returned.\n  */\n  function paginateTransferProofIndicesByInvolvee(address involvee, uint256 cursor, uint256 perPage)\n      external view returns(uint256[] memory, uint256) {\n    return LibPaginate.uint256s(LibFastHistory.data().transferProofInvolvements[involvee], cursor, perPage);\n  }\n\n  /**\n   * @notice Returns a page of inbound and outbound transfer proofs based on an involvee.#\n   * @param involvee is the address for which to fetch the data.\n   * @param cursor is where to start.\n   * @param perPage is how many items at most to return.\n   * @return A `(LibFastHistory.TransferProof[], uint256)` tuple containing the results and the cursor to the next page.\n   */\n  function paginateTransferProofsByInvolvee(address involvee, uint256 cursor, uint256 perPage)\n      external view returns(LibFastHistory.TransferProof[] memory, uint256) {\n    LibFastHistory.Data storage s = LibFastHistory.data();\n    uint256[] storage collection  = s.transferProofInvolvements[involvee];\n    uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\n    LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\n    for (uint256 i = 0; i < length;) {\n      values[i] = s.transferProofs[collection[cursor + i]];\n      unchecked { ++i; }\n    }\n    return (values, cursor + length);\n  }\n}\n"
    },
    "contracts/fast/FastInitFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../interfaces/IERC20.sol';        // Token.\nimport '../interfaces/IERC165.sol';       // Interface Support.\nimport '../interfaces/IERC173.sol';       // Ownership.\nimport '../interfaces/IDiamondCut.sol';   // Facet management.\nimport '../interfaces/IDiamondLoupe.sol'; // Facet introspection.\nimport '../interfaces/IHasGovernors.sol'; // Governorship management.\nimport '../interfaces/IHasMembers.sol';   // Membership management.\nimport '../interfaces/ICustomErrors.sol';\nimport '../lib/LibDiamond.sol';\nimport '../lib/LibAddressSet.sol';\nimport '../marketplace/MarketplaceTopFacet.sol';\nimport './lib/AFastFacet.sol';\n\n\n/**\n * @notice NotAlthough this contract doesn't explicitelly inherit from IERC173, ERC165, IDiamondLoupe etc, all\n * methods are in fact implemented by the underlaying Diamond proxy. It is therefore safe to\n * perform casts directly on the current contract address into these interfaces.\n */ \ncontract FastInitFacet is AFastFacet {\n  using LibAddressSet for LibAddressSet.Data;\n\n  // Initializers.\n\n  struct InitializerParams {\n    // Top-level stuff.\n    address issuer;\n    address marketplace;\n    // Access stuff.\n    address payable governor;\n    // Token stuff.\n    string name;\n    string symbol;\n    uint8 decimals;\n    bool hasFixedSupply;\n    bool isSemiPublic;\n  }\n\n  function initialize(InitializerParams calldata params)\n      external\n      onlyDeployer {\n    // Make sure we haven't initialized yet.\n    if (LibFast.data().version >= LibFast.STORAGE_VERSION) {\n      revert ICustomErrors.AlreadyInitialized();\n    }\n\n    // Make sure that the passed governor is an active member of the marketplace.\n    if (!IHasActiveMembers(params.marketplace).isActiveMember(params.governor)) {\n      revert ICustomErrors.RequiresMarketplaceActiveMembership(params.governor);\n    }\n \n    // Register interfaces.\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    ds.supportedInterfaces[type(IERC20).interfaceId] = true;\n    ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n    ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n    ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n    ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n    ds.supportedInterfaces[type(IHasGovernors).interfaceId] = true;\n    ds.supportedInterfaces[type(IHasMembers).interfaceId] = true;\n\n    // ------------------------------------- //\n\n    // Initialize top-level storage.\n    LibFast.Data storage topData = LibFast.data();\n    topData.version = LibFast.STORAGE_VERSION;\n    topData.issuer = params.issuer;\n    topData.marketplace = params.marketplace;\n    topData.hasFixedSupply = params.hasFixedSupply;\n    topData.isSemiPublic = params.isSemiPublic;\n    // For expliciteness / data slot cleanup.\n    topData.transfersDisabled = false;\n\n    // ------------------------------------- //\n\n    // Initialize access storage.\n    LibFastAccess.Data storage accessData = LibFastAccess.data();\n    accessData.version = LibFastAccess.STORAGE_VERSION;\n    // Add the governor and emit.\n    accessData.governorSet.add(params.governor, true);\n    emit GovernorAdded(params.governor);\n\n    // ------------------------------------- //\n\n    // Initialize history storage.\n    LibFastHistory.Data storage historyData = LibFastHistory.data();\n    historyData.version = LibFastHistory.STORAGE_VERSION;\n\n    // ------------------------------------- //\n\n    // Initialize token storage.\n    LibFastToken.Data storage tokenData = LibFastToken.data();\n    tokenData.version = LibFastToken.STORAGE_VERSION;\n    // Set up ERC20 related stuff.\n    tokenData.name = params.name;\n    tokenData.symbol = params.symbol;\n    tokenData.decimals = params.decimals;\n    // For expliciteness / data slot cleanup.\n    tokenData.totalSupply = 0;\n  }\n}\n"
    },
    "contracts/fast/FastTokenFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../interfaces/IERC20.sol';\nimport '../interfaces/ICustomErrors.sol';\nimport '../interfaces/IHasMembers.sol';\nimport '../interfaces/IHasGovernors.sol';\nimport '../lib/LibDiamond.sol';\nimport '../lib/LibAddressSet.sol';\nimport '../lib/LibPaginate.sol';\nimport './lib/AFastFacet.sol';\nimport './lib/LibFastToken.sol';\nimport './lib/IFast.sol';\nimport '../marketplace/MarketplaceTokenHoldersFacet.sol';\nimport './FastTopFacet.sol';\nimport './FastAccessFacet.sol';\nimport './FastHistoryFacet.sol';\nimport './FastFrontendFacet.sol';\n\n\ncontract FastTokenFacet is AFastFacet, IERC20 {\n  using LibAddressSet for LibAddressSet.Data;\n\n  // Minting methods.\n\n  /**\n   * @notice Mints an amount of FAST tokens.\n   *  A reference can be passed to identify why this happened for example.\n   *\n   * Business logic:\n   * - Modifiers:\n   *   - Requires the caller to be a member of the Issuer contract.\n   * - Requires that either the token has continuous supply, or that no tokens have been minted yet.\n   * - Increases the reserve balance by `amount`.\n   * - Calls `FastHistoryFacet.minted`.\n   * - Calls `FastFrontendFacet.emitDetailsChanged`.\n   * - Emits a `Minted(amount, ref)` event.\n   * @param amount The number of FAST tokens to mint.\n   * @param ref A reference for this minting operation.\n   */\n  function mint(uint256 amount, string calldata ref)\n      external\n      onlyIssuerMember {\n    LibFastToken.Data storage s = LibFastToken.data();\n    // We want to make sure that either of these two is true:\n    // - The token doesn't have fixed supply.\n    // - The token has fixed supply but has no tokens yet (First and only mint).\n    if (FastTopFacet(address(this)).hasFixedSupply() && (s.totalSupply != 0 || this.balanceOf(address(0)) != 0))\n      revert ICustomErrors.RequiresContinuousSupply();\n\n    // Prepare the minted amount on the zero address.\n    s.balances[address(0)] += amount;\n\n    // Keep track of the minting operation.\n    FastHistoryFacet(address(this)).minted(amount, ref);\n\n    // Emit!\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n    emit Minted(amount, ref, msg.sender);\n  }\n\n  /**\n   * @notice Burns an amount of FAST tokens.\n   *  A reference can be passed to identify why this happened for example.\n   *\n   * Business logic.\n   * - Modifiers:\n   *   - Requires the caller to be a member of the Issuer contract.\n   * - Requires that the token has continuous supply.\n   * - Requires that there are enough funds in the reserve to cover for `amount` being burnt.\n   * - Decreases the reserve balance by `amount`.\n   * - Calls `FastHistoryFacet.burnt(amount, ref)`.\n   * - Calls `FastFrontendFacet.emitDetailsChanged`.\n   * - Emits a `Burnt(amount, ref)`.\n   * @param amount The number of FAST tokens to mint.\n   * @param ref A reference for this minting operation.\n   */\n  function burn(uint256 amount, string calldata ref)\n      external\n      onlyIssuerMember {\n    LibFastToken.Data storage s = LibFastToken.data();\n\n    if (FastTopFacet(address(this)).hasFixedSupply())\n      revert ICustomErrors.RequiresContinuousSupply();\n\n    // Remove the minted amount from the zero address.\n    s.balances[address(0)] -= amount;\n\n    // Keep track of the minting operation.\n    FastHistoryFacet(address(this)).burnt(amount, ref);\n\n    // Emit!\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n    emit Burnt(amount, ref, msg.sender);\n  }\n\n  /**\n   * @notice Allows an Issuer member to move an arbitrary account's holdings back to the reserve,\n   * as per regulatory requirements.\n   *\n   * Business logic:\n   * - Modifiers:\n   *   - Requires that the caller is a member of the Issuer contract.\n   * - If the amount held by `holder` is not zero\n   *   - The balance of `holder` should be set to zero.\n   *   - The reserve's balance should be increased by how much was on the holder's account.\n   *   - Total supply should be decreased by that amount too.\n   * - The `holder`'s address should not be tracked as a token holder in this FAST anymore.\n   * - The `holder`'s address should not be tracked as a token holder in the Marketplace anymore.\n   * - A `Transfer(holder, reserve, amount)` event should be emited.\n   * - If the amount previously held by `holder` was not zero,\n   *   - Since the reserve balance and total supply have changed, the `FastFrontendFacet.emitDetailsChanged()` function should be called.\n   * @param holder is the address for which to move the tokens from.\n   */\n  function retrieveDeadTokens(address holder)\n      external\n      onlyIssuerMember {\n    // Cache how many tokens the holder has.\n    uint256 amount = balanceOf(holder);\n    // Note: The amount **can** be zero in this function.\n\n    // Grab a pointer to the token storage.\n    LibFastToken.Data storage s = LibFastToken.data();\n\n    // These should only run if the amount is zero, as they result in a no-op.\n    if (amount > 0) {\n      // Set the holder balance to zero.\n      s.balances[holder] = 0;\n      // Increment the reserve's balance.\n      s.balances[address(0)] += amount;\n      // The tokens aren't in circulation anymore - decrease total supply.\n      s.totalSupply -= amount;\n    }\n\n    // Since the holder's account is now empty, make sure to keep track of it both\n    // in this FAST and in the marketplace.\n    s.tokenHolders.remove(holder, true);\n    MarketplaceTokenHoldersFacet(LibFast.data().marketplace).fastBalanceChanged(holder, 0);\n\n    // Keep track of this transfer in history facet.\n    FastHistoryFacet(address(this)).transfered(msg.sender, holder, address(0), amount, LibConstants.DEAD_TOKENS_RETRIEVAL);\n\n    // This operation can be seen as a regular transfer between holder and reserve. Emit.\n    emit FastTransfer(msg.sender, holder, address(0), amount, LibConstants.DEAD_TOKENS_RETRIEVAL);\n    emit Transfer(holder, address(0), amount);\n\n    // If amount wasn't zero, total supply and reserve balance have changed - emit.\n    if (amount > 0)\n      FastFrontendFacet(address(this)).emitDetailsChanged();\n  }\n\n  // ERC20 implementation and transfer related methods.\n\n  /**\n   * @notice The name of this FAST (ERC20 standard).\n   * @return string Name of the FAST.\n   */\n  function name()\n      external view returns(string memory) {\n    return LibFastToken.data().name;\n  }\n\n  /**\n   * @notice The symbol of this FAST (ERC20 standard).\n   * @return string Symbol of the FAST.\n   */\n  function symbol()\n      external view returns(string memory) {\n    return LibFastToken.data().symbol;\n  }\n\n  /**\n   * @notice The `decimals` of this FAST (ERC20 standard).\n   * @return uint256 Number of decimals the FAST has.\n   */\n  function decimals()\n      external view returns(uint256) {\n    return LibFastToken.data().decimals;\n  }\n\n  /**\n   * @notice The total supply of the FAST (ERC20 standard).\n   * @return uint256 Total supply of the FAST.\n   */\n  function totalSupply()\n      external override view returns(uint256) {\n    return LibFastToken.data().totalSupply;\n  }\n\n  /**\n   * @notice The balance of the passed owner (ERC20 standard).\n   * @param owner The owners address to get the balance of.\n   * @return uint256 The current balance of this owner's account.\n   */\n  function balanceOf(address owner)\n      public view override returns(uint256) {\n    return LibFastToken.data().balances[owner];\n  }\n\n  /**\n   * @notice See `performTransfer`, the spender will be equal to the `owner`, and the `ref` will be defauted. */\n  function transfer(address to, uint256 amount)\n      external override returns(bool) {\n    // Make sure the call is performed externally so that we can mock.\n    this.performTransfer(\n      TransferArgs({\n        spender: msg.sender,\n        from: msg.sender,\n        to: to,\n        amount: amount,\n        ref: LibFastToken.DEFAULT_TRANSFER_REFERENCE\n      })\n    );\n    return true;\n  }\n\n  /**\n   * @notice See `performTransfer`, the spender will be equal to the `owner`. */\n  function transferWithRef(address to, uint256 amount, string calldata ref)\n      external returns(bool) {\n    // Make sure the call is performed externally so that we can mock.\n    this.performTransfer(\n      TransferArgs({\n        spender: msg.sender,\n        from: msg.sender,\n        to: to,\n        amount: amount,\n        ref: ref\n      })\n    );\n    return true;\n  }\n\n  function allowance(address owner, address spender)\n      public view override returns(uint256) {\n    LibFastToken.Data storage s = LibFastToken.data();\n    // If the allowance being queried is owned by the reserve, and `spender` is\n    // an Issuer member, `spender` owns the full balance of `owner`. If they are\n    // not an Issuer member then their allowance is zero. Otherwise, the regular given\n    // allowance for `spender` over `owner` applies.\n    if (owner == address(0))\n      return IHasMembers(LibFast.data().issuer).isMember(spender)\n        ? s.balances[owner]\n        : 0;\n    else\n      return s.allowances[owner][spender];\n  }\n\n  /**\n   * @notice This method directly calls `performApproval`, setting its `from` paramter to the sender of\n   * the transaction.\n   * @param spender is the address to allow spending from the caller's wallet.\n   * @param amount is how much to **increase** the allowance.\n   */\n  function approve(address spender, uint256 amount)\n      external override returns(bool) {\n    // Make sure the call is performed externally so that we can mock.\n    this.performApproval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice This method directly calls `performDisapproval`, setting its `from` parameter to the sender of\n   * the transaction.\n   * @param spender is the address to disallow spending from the caller's wallet.\n   * @param amount is how much to **decrease** the allowance.\n   */\n  function disapprove(address spender, uint256 amount)\n      external\n      onlyMember(msg.sender)\n      returns(bool) {\n    // Make sure the call is performed externally so that we can mock.\n    this.performDisapproval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /// @notice See `performTransfer`, the `ref` will be defaulted.\n  function transferFrom(address from, address to, uint256 amount)\n      external override returns(bool) {\n    transferFromWithRef(from, to, amount, LibFastToken.DEFAULT_TRANSFER_REFERENCE);\n    return true;\n  }\n\n  /// @notice See `performTransfer`.\n  function transferFromWithRef(address from, address to, uint256 amount, string memory ref)\n      public returns(bool) {\n    // Make sure the call is performed externally so that we can mock.\n    this.performTransfer(\n      TransferArgs({\n        spender: msg.sender,\n        from: from,\n        to: to,\n        amount: amount,\n        ref: ref\n      })\n    );\n    return true;\n  }\n\n  // Allowances query operations.\n\n  function givenAllowanceCount(address owner)\n      external view returns(uint256) {\n    return LibFastToken.data().allowancesByOwner[owner].values.length;\n  }\n\n  function paginateAllowancesByOwner(address owner, uint256 index, uint256 perPage)\n      external view returns(address[] memory, uint256) {\n    return LibPaginate.addresses(\n      LibFastToken.data().allowancesByOwner[owner].values,\n      index,\n      perPage\n    );\n  }\n\n  function receivedAllowanceCount(address spender)\n      external view returns(uint256) {\n    return LibFastToken.data().allowancesBySpender[spender].values.length;\n  }\n\n  function paginateAllowancesBySpender(address spender, uint256 index, uint256 perPage)\n      external view returns(address[] memory, uint256) {\n    return LibPaginate.addresses(\n      LibFastToken.data().allowancesBySpender[spender].values,\n      index,\n      perPage\n    );\n  }\n\n  // These functions would be internal / private if we weren't using the diamond pattern.\n  // Instead, they're `onlyDiamondFacet` - eg can only be called by facets of the current\n  // FAST.\n\n  struct TransferArgs {\n    address spender;\n    address from;\n    address to;\n    uint256 amount;\n    string ref;\n  }\n\n  /**\n   * @notice This is the internal method that gets called whenever a transfer is initiated. Both `transfer`,\n   * `transferWithRef`, and their variants internally call this function.\n   *\n   * Business logic:\n   * - Modifiers:\n   *   - Only facets of the current diamond should be able to call this.\n   * - Requires that transfers are enabled for this FAST.\n   * - Requires that `from` and `to` are different addresses.\n   * - Requires that `from` membership is active in the marketplace.\n   * - If `from` is not the reserve, requires that `from` is a valid token holder.\n   * - If `from` is the reserve, requires that the message sender is an issuer member.\n   * - Requires that `to` is a valid token holder.\n   * - Requires that the amount is a positive value.\n   * - If the transfer is an allowance - e.g. the `spender` is not the same as the `from` address,\n   *   - The allowance given by the `from` address to the `spender` covers for the `amount`.\n   *     - If we are **not** transfering **from** the reserve,\n   *       - Decreases the allowance given by `from` to `spender`.\n   *         - If the new allowance reaches zero,\n   *           - Stop tracking the allowance in the allowance lookup tables for both spending and receiving directions.\n   * - Decreases the balance of the `owner` address.\n   * - Increases the balance of the `to` address by `amount`.\n   * - If we are **not** transfering **from** the reserve,\n   *   - Requires that there are enough transfer credits to cover for `amount`.\n   *   - Decreases the transfer credits by `amount`.\n   * - If the `to` address is the reserve,\n   *   - Decreases the total supply by `amount`.\n   *   - Calls `FastFrontendFacet.emitDetailsChanged`.\n   * - Else, if the `from` address is the reserve,\n   *   - Increases the total supply by `amount`.\n   *   - Calls `FastFrontendFacet.emitDetailsChanged`.\n   * - Calls `FastHistoryFacet.transfered`.\n   * - Emits a `Transfer(from, to, amount)` event.\n   */\n  function performTransfer(TransferArgs calldata p)\n      external onlyDiamondFacet {\n    // TODO: Make this function return instead of raising errors.\n\n    // Grab a pointer to our top-level storage.\n    LibFast.Data storage topData = LibFast.data();\n\n    // Requires that transfers are enabled for this FAST.\n    if (FastTopFacet(address(this)).transfersDisabled())\n      revert ICustomErrors.RequiresTransfersEnabled();\n    // Requires that `from` and `to` are different addresses.\n    else if (p.from == p.to)\n      revert ICustomErrors.RequiresDifferentSenderAndRecipient(p.from);\n    // Requires that allowance transfers from the reserve are performed by issuer members only.\n    else if (p.from == address(0) && !IHasMembers(topData.issuer).isMember(p.spender))\n      revert ICustomErrors.RequiresIssuerMembership(p.spender);\n\n    // Requires that the `from` address can hold tokens.\n    else if (!canHoldTokens(p.from))\n      revert ICustomErrors.RequiresValidTokenHolder(p.from);\n    // Requires that the `from` address marketplace membership is active if not the reserve.\n    else if (p.from != address(0) && !IHasActiveMembers(LibFast.data().marketplace).isActiveMember(p.from))\n      revert ICustomErrors.RequiresMarketplaceActiveMembership(p.from);\n\n    // Requires that the `to` address can hold tokens.\n    else if (!canHoldTokens(p.to))\n      revert ICustomErrors.RequiresValidTokenHolder(p.to);\n\n    // For any non-zero amount, update balances and allowances, notify other contracts, etc.\n    if (p.amount != 0) {\n      // Grab a pointer to our token storage.\n      LibFastToken.Data storage tokenData = LibFastToken.data();\n\n      // If this is an allowance transfer and if the `from` account is not the reserve...\n      if (p.spender != p.from && p.from != address(0)) {\n        // Decrease allowance.\n        uint256 newAllowance = tokenData.allowances[p.from][p.spender] -= p.amount;\n        // If the allowance reached zero, we want to remove that allowance from\n        // the various other places where we keep track of it.\n        if (newAllowance == 0) {\n          tokenData.allowancesByOwner[p.from].remove(p.spender, true);\n          tokenData.allowancesBySpender[p.spender].remove(p.from, true);\n        }\n      }\n\n      // Keep track of the balances - `from` spends (decrease), `to` receives (increase).\n      uint256 fromBalance = (tokenData.balances[p.from] -= p.amount);\n      uint256 toBalance = (tokenData.balances[p.to] += p.amount);\n\n      // Keep track of who has what FAST.\n      MarketplaceTokenHoldersFacet(topData.marketplace).fastBalanceChanged(p.from, fromBalance);\n      MarketplaceTokenHoldersFacet(topData.marketplace).fastBalanceChanged(p.to, toBalance);\n\n      // Keep track of who holds this token.\n      balanceChanged(p.from, fromBalance);\n      balanceChanged(p.to, toBalance);\n\n      // If the funds are going to the reserve...\n      if (p.to == address(0)) {\n        // Decrease total supply.\n        tokenData.totalSupply -= p.amount;\n        // Emit a top-level details change event.\n        FastFrontendFacet(address(this)).emitDetailsChanged();\n      }\n      // If the funds are moving from the zero address...\n      else if (p.from == address(0)) {\n        // Increase total supply.\n        tokenData.totalSupply += p.amount;\n        // Emit a top-level details change event.\n        FastFrontendFacet(address(this)).emitDetailsChanged();\n      }\n    }\n\n    // Keep track of the transfer in the history facet.\n    FastHistoryFacet(address(this)).transfered(p.spender, p.from, p.to, p.amount, p.ref);\n\n    // Emit!\n    emit FastTransfer(p.spender, p.from, p.to, p.amount, p.ref);\n    emit Transfer(p.from, p.to, p.amount);\n  }\n\n  /**\n   * @notice Increases the allowance given by `from` to `spender` by `amount`.\n   * Note that this function should run and emit even if the amount passed is zero.\n   * Business logic:\n   * - Modifiers:\n   *   - Only facets of the current diamond should be able to call this.\n   *   - Requires that `onlyTokenHolder` passes for the `from` address.\n   * - Requires that the `amount` is positive number.\n   * - Increases the allowance given by `from` to `spender` by `amount`.\n   * - Update the allowance lookup tables in both directions.\n   * - Emits an `Approval(from, spender, amount)`.\n   * @param from is the wallet from which to give the allowance.\n   * @param spender is the receiver of the allowance.\n   * @param amount is how much to **increase** the current allowance by.\n   * \n   * Note: This function runs when amount is zero, and will emit.\n   */\n  function performApproval(address from, address spender, uint256 amount)\n      external\n      onlyDiamondFacet {\n    // Allowance cannot be given over the reserve.\n    if (from == address(0))\n      revert ICustomErrors.UnsupportedOperation();\n    // Require that the `from` address can hold tokens.\n    else if (!canHoldTokens(from))\n      revert ICustomErrors.RequiresValidTokenHolder(from);\n    \n    if (amount > 0) {\n      LibFastToken.Data storage s = LibFastToken.data();\n      // Note that we are not exactly following ERC20 here - we don't want to **set** the allowance to `amount`\n      // to mitigate a possible attack.\n      // See https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#heading=h.gmr6zdg47087.\n      s.allowances[from][spender] += amount;\n    // Keep track of given and received allowances.\n      s.allowancesByOwner[from].add(spender, true);\n      s.allowancesBySpender[spender].add(from, true);\n    }\n\n    // Emit!\n    emit Approval(from, spender, amount);\n  }\n\n  /**\n   * @notice Decreases allowance given by `from` to `spender` by `amount`.\n   *\n   * Business logic:\n   * - Modifiers:\n   *   - Only facets of the current diamond should be able to call this.\n   * - The allowance given by `from` to `spender` is decreased by `amount`.\n   * - Whether the allowance reached zero, stop tracking it by owner and by spender.\n   * - Emit a `Disapproval(from, spender, amount)` event.\n   * \n   * Note: This function runs when amount is zero, and will emit.\n   */\n  function performDisapproval(address from, address spender, uint256 amount)\n      external\n      onlyDiamondFacet {\n    if (amount != 0) {\n      LibFastToken.Data storage s = LibFastToken.data();\n\n      // Remove allowance.\n      s.allowances[from][spender] -= amount;\n\n      // Whenever the allowance reaches zero, stop tracking it by owner and spender.\n      if (s.allowances[from][spender] == 0) {\n        s.allowancesByOwner[from].remove(spender, true);\n        s.allowancesBySpender[spender].remove(from, true);\n      }\n    }\n\n    // Emit!\n    emit Disapproval(from, spender, amount);\n  }\n\n  // WARNING: This method contains two loops. We know that this should never\n  // happen in solidity. However:\n  // - In the context of our private chain, gas is cheap.\n  // - It can only be called by a governor.\n  function beforeRemovingMember(address member)\n      external onlyDiamondFacet() {\n    if (balanceOf(member) != 0)\n      revert ICustomErrors.RequiresPositiveBalance(member);\n\n    LibFastToken.Data storage s = LibFastToken.data();\n\n    // Remove all given allowances.\n    {\n      address[] storage gaData = s.allowancesByOwner[member].values;\n      while (gaData.length > 0) {\n        // Make sure the call is performed externally so that we can mock.\n        address spender = gaData[0];\n        this.performDisapproval(member, spender, s.allowances[member][spender]);\n      }\n    }\n\n    // Remove all received allowances.\n    {\n      address[] storage raData = s.allowancesBySpender[member].values;\n      while (raData.length > 0) {\n        // Make sure the call is performed externally so that we can mock.\n        address owner = raData[0];\n        this.performDisapproval(owner, member, s.allowances[owner][member]);\n      }\n    }\n  }\n\n  function holders()\n      external view\n      returns(address[] memory) {\n    LibFastToken.Data storage s = LibFastToken.data();\n    return s.tokenHolders.values;\n  }\n\n  function balanceChanged(address holder, uint256 balance)\n      private {\n    // Return early if this is the zero address.\n    if (holder == address(0))\n      return;\n\n    LibFastToken.Data storage s = LibFastToken.data();\n\n    // If this is a positive balance and it doesn't already exist in the set, add address.\n    if (balance > 0 && !s.tokenHolders.contains(holder))\n      s.tokenHolders.add(holder, false);\n    // If the balance is 0 and it exists in the set, remove it.\n    else if (balance == 0 && s.tokenHolders.contains(holder))\n      s.tokenHolders.remove(holder, false);\n  }\n\n  // Private and helper methods.\n\n  /**\n   * @notice Ensures that the given address is a member of the current FAST or the Zero Address.\n   *\n   * Business logic:\n   *   - If the candidate is the reserve, it is a valid token holder.\n   *   - If the FAST is semi-public,\n   *     - We require that candidate is a member of the Marketplace contract and is active in it.\n   *   - Otherwise,\n   *     - Require that the candidate is a member of the FAST.\n   * @param candidate The address to check.\n   * @return A boolean set to `true` if `candidate` can hold tokens, `false` otherwise.\n   */\n  function canHoldTokens(address candidate)\n      private view returns(bool) {\n    // Zero address can hold tokens, in any cases.\n    if (candidate == address(0))\n      return true;\n    // If the FAST is semi public, any member of the marketplace can hold tokens.\n    else if (IFast(address(this)).isSemiPublic()) {\n      return IHasMembers(LibFast.data().marketplace).isMember(candidate);\n    }\n    // FAST is private, only members of the fast can hold tokens.\n    else {\n      return IHasMembers(address(this)).isMember(candidate);\n    }\n  }\n}\n"
    },
    "contracts/fast/FastTopFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../lib/LibConstants.sol';\nimport '../lib/LibHelpers.sol';\nimport './lib/AFastFacet.sol';\nimport './lib/LibFast.sol';\nimport './lib/IFastEvents.sol';\nimport './FastFrontendFacet.sol';\n\n\ncontract FastTopFacet is AFastFacet {\n  // Getters and setters for global flags.\n\n  /**\n   * @notice Get the Issuer address.\n   * @return Address of Issuer.\n   */\n  function issuerAddress()\n      external view returns(address) {\n    return LibFast.data().issuer;\n  }\n\n  /**\n   * @notice Get the Marketplace address.\n   * @return address Address of Marketplace.\n   */\n  function marketplaceAddress()\n      external view returns(address) {\n    return LibFast.data().marketplace;\n  }\n\n  /**\n   * @notice Is this FAST a semi public FAST?\n   * @return bool Yes/no semi public.\n   */\n  function isSemiPublic()\n      external view returns(bool) {\n    return LibFast.data().isSemiPublic;\n  }\n\n  /**\n   * @notice Is this FAST a fixed supply FAST?\n   * @return bool Yes/no fixed supply.\n   */\n  function hasFixedSupply()\n      external view returns(bool) {\n    return LibFast.data().hasFixedSupply;\n  }\n\n  /**\n   * @notice Are transfers enabled across this FAST?\n   * @return `true` if transfers are disabled, `false` if transfers are enabled.\n   */\n  function transfersDisabled()\n      external view returns(bool) {\n    return LibFast.data().transfersDisabled;\n  }\n\n  // Setters for global flags.\n\n  /**\n   * @notice Allows to switch from a private scheme to a semi-public scheme,\n   *  but not the other way around.\n   * @param flag Set the semi public flag to true/false.\n   */\n  function setIsSemiPublic(bool flag)\n      external\n      onlyIssuerMember {\n    // Someone is trying to toggle back to private?... No can do!\n    if (this.isSemiPublic()) {\n      revert ICustomErrors.UnsupportedOperation();\n    }\n    LibFast.data().isSemiPublic = flag;\n    // Emit!\n    FastFrontendFacet(address(this)).emitDetailsChanged();\n  }\n\n  /**\n   * @notice Allows an issuer member to enable or disable all transfers within this FAST.\n   * @param flag Set the transfer capability to active or not.\n   */\n  function setTransfersDisabled(bool flag)\n      external\n      onlyIssuerMember {\n    LibFast.Data storage d = LibFast.data();\n    // Only make changes and emit if the new flag is different than the old one.\n    if (d.transfersDisabled != flag) {\n      // Set flag.\n      d.transfersDisabled = flag;\n      // Emit!\n      FastFrontendFacet(address(this)).emitDetailsChanged();\n    }\n  }\n}\n"
    },
    "contracts/fast/lib/AFastFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../../lib/LibConstants.sol';\nimport '../../lib/LibHelpers.sol';\nimport '../../lib/LibAddressSet.sol';\nimport '../../interfaces/ICustomErrors.sol';\nimport '../../interfaces/IHasMembers.sol';\nimport '../../interfaces/IHasGovernors.sol';\nimport '../../interfaces/IHasActiveMembers.sol';\nimport '../../interfaces/IERC173.sol';\nimport '../lib/LibFast.sol';\nimport './IFastEvents.sol';\n\n\n/**\n * @title Abstract FAST helper contract.\n * @notice This abstract contract encapsulates modifiers allowing inheriting facets to guard against\n * certain permissions.\n */\nabstract contract AFastFacet is IFastEvents {\n  using LibAddressSet for LibAddressSet.Data;\n\n  /// Modifiers.\n\n  /// @notice Ensures that a method can only be called by another facet of the same diamond.\n  modifier onlyDiamondFacet() {\n    if (msg.sender != address(this))\n      revert ICustomErrors.InternalMethod();\n    _;\n  }\n\n  /// @notice Ensures that a method can only be called by the owner of this diamond.\n  modifier onlyDiamondOwner() {\n    if (msg.sender != IERC173(address(this)).owner())\n      revert ICustomErrors.RequiresDiamondOwnership(msg.sender);\n    _;\n  }\n\n  /// @notice Ensures that a method can only be called by the singleton deployer contract factory.\n  modifier onlyDeployer() {\n    if (msg.sender != LibConstants.DEPLOYER_CONTRACT)\n      revert ICustomErrors.InternalMethod();\n    _;\n  }\n\n  /**\n   * @notice Ensures that the given address is a member of the Marketplace.\n   * @param candidate The address to check.\n   */\n  modifier onlyMarketplaceMember(address candidate) {\n    if (!IHasMembers(LibFast.data().marketplace).isMember(candidate))\n      revert ICustomErrors.RequiresMarketplaceMembership(candidate);\n    _;\n  }\n\n  /**\n   * @notice Ensures a candidate is an active member of the Marketplace.\n   * @param candidate The address to check.\n   */\n  modifier onlyMarketplaceActiveMember(address candidate) {\n    if (!IHasActiveMembers(LibFast.data().marketplace).isActiveMember(candidate))\n      revert ICustomErrors.RequiresMarketplaceActiveMembership(candidate);\n    _;\n  }\n\n  /**\n   * @notice Ensures that the message sender is a member of the Issuer.\n   */\n  modifier onlyIssuerMember() {\n    if (!IHasMembers(LibFast.data().issuer).isMember(msg.sender))\n      revert ICustomErrors.RequiresIssuerMembership(msg.sender);\n    _;\n  }\n\n  /**\n   * @notice Ensures that the given address is a governor of the FAST.\n   * @param candidate The address to check.\n   */\n  modifier onlyGovernor(address candidate) {\n    if (!IHasGovernors(address(this)).isGovernor(candidate))\n      revert ICustomErrors.RequiresFastGovernorship(candidate);\n    _;\n  }\n\n  /**\n   * @notice Ensures that the given address is a member of the FAST.\n   * @param candidate The address to check.\n   */\n  modifier onlyMember(address candidate) {\n    if (!IHasMembers(address(this)).isMember(candidate))\n      revert ICustomErrors.RequiresFastMembership(candidate);\n    _;\n  }\n\n  /**\n   * @notice Ensures address `a` and `b` are different.\n   * @param a Address a\n   * @param b Address b\n   */\n  modifier differentAddresses(address a, address b) {\n    if (a == b)\n      revert ICustomErrors.RequiresDifferentSenderAndRecipient(a);\n    _;\n  }\n}\n"
    },
    "contracts/fast/lib/IFast.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\n/// @title The top-level all FAST diamonds must comply to.\ninterface IFast {\n  /**\n   * @notice Queries whether the FAST is semi-public or closed.\n   * @return A `bool` being `true` if the FAST is semi-public.\n   */\n  function isSemiPublic() external view returns(bool);\n\n  /**\n   * @notice Queries whether the FAST has fixed or continuous supply.\n   * @return A `bool` being `true` if the FAST has fixed supply.\n   */\n  function hasFixedSupply() external view returns(bool);\n}\n"
    },
    "contracts/fast/lib/IFastEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\n/**\n * @title FAST events inventory.\n * @notice An interface allowing to use events within the Diamond pattern without name colisions.\n * @dev The idea is that as several facets can emit the same events, we don't want to have to re-declare\n * the same event several time. This interface is a per-diamond central place for such event declaration.\n */\ninterface IFastEvents {\n  // IHasMembers.\n\n  /**\n   * @notice Emited when a member is added to the implementing contract.\n   * @param member is the address of the added member.\n   */\n  event MemberAdded(address indexed member);\n  /**\n   * @notice Emited when a member is removed to the implementing contract.\n   * @param member is the address of the removed member.\n   */\n  event MemberRemoved(address indexed member);\n\n  // IHasGovernors.\n\n  /**\n   * @notice Emited when a governor is added to the implementing contract.\n   * @param governor is the address of the added governor.\n   */\n  event GovernorAdded(address indexed governor);\n  /**\n   * @notice Emited when a governor is removed to the implementing contract.\n   * @param governor is the address of the removed member.\n   */\n  event GovernorRemoved(address indexed governor);\n\n  // Issuance related events.\n  \n  /**\n   * @notice Emited whenever an issuance happens in a FAST.\n   * @param amount is the amount of tokens that have been minted.\n   * @param ref is the reference associated with the minting operation.\n   * @param who is the account from which the minting operation originated.\n   */\n  event Minted(uint256 indexed amount, string indexed ref, address indexed who);\n  /**\n   * @notice Emited whenever an burning happens in a FAST.\n   * @param amount is the amount of tokens that have been burnt.\n   * @param ref is the reference associated with the burning operation.\n   * @param who is the account from which the burning operation originated.\n   */\n  event Burnt(uint256 indexed amount, string indexed ref, address indexed who);\n\n  // Transfer and ERC20 stuff.\n\n  /// @notice See `ERC20.Transfer`.\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  /// @notice See `ERC20.Approval`.\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  /// @notice See `ERC20.Disapproval`.\n  event Disapproval(address indexed owner, address indexed spender, uint256 value);\n  /**\n   * @notice As we augmented the ERC20 standard with a few concepts, we emit our custom events\n   * in addition to the ERC20 ones.\n   * @param spender is the account who performed the transfer.\n   * @param from is the account from which the tokens will be debited from.\n   * @param to is the account to which the tokens will be credited to.\n   * @param value is the amount of tokens transfered.\n   * @param ref is the optional reference associated with the transfer.\n   */\n  event FastTransfer(address indexed spender, address indexed from, address indexed to, uint256 value, string ref);\n\n  // General events.\n\n  /**\n   * @notice This is an event that is fired whenever any of some of the FAST parameters\n   * change, so that the frontend can react to it and refresh the general header\n   * for that fast as well as the baseball cards in the FASTs list.\n   * @param transfersDisabled marks whether or not transfers are disabled by an issuer member at FAST level.\n   * @param memberCount is the number of members in the FAST.\n   * @param governorCount is the number of governors in the FAST.\n   * @param totalSupply is the amount of tokens in circulation in the FAST.\n   * @param reserveBalance is the balance of the zero-address (aka reserve) for the FAST.\n   * @param ethBalance is the amount of Eth locked in the FAST.\n   */\n  event DetailsChanged(\n    bool transfersDisabled,\n    uint256 memberCount,\n    uint256 governorCount,\n    uint256 totalSupply,\n    uint256 reserveBalance,\n    uint256 ethBalance\n  );\n}\n"
    },
    "contracts/fast/lib/LibFast.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\n/**\n * @notice Top-level shared functionality for FAST diamonds.\n * @dev Note that if you feel like a method should be created inside this library, you might want to really consider\n * whether or not it is the right place for it. Any facet using a method from internal libraries see their bytecode\n * size increase, kind of defeating the benefits of using facets in the first place. So please keep it reasonable. \n */\nlibrary LibFast {\n  /// @notice The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  /// @notice This is keccak256('Fast.storage'):\n  bytes32 internal constant STORAGE_SLOT = 0x80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705;\n\n  // Data structures.\n\n  /**\n   * @notice The top-level data structure required for operating any given FAST diamond.\n   * @dev The `version` field is used to ensure that storage is at a known version during upgrades.\n   */\n  struct Data {\n    /// @notice The latest intializer version that was called.\n    uint16 version;\n    /// @notice The internal pointer to the Issuer contract.\n    address issuer;\n    /// @notice The internal pointer to the Marketplace contract.\n    address marketplace;\n    /// @notice We have to track whether the token facet provides continuous minting or fixed supply.\n    bool hasFixedSupply;\n    /// @notice Whether or not this FAST requires to be a member to hold tokens.\n    bool isSemiPublic;\n    /// @notice A flag which when toggled to `true` disables all transfers across this FAST.\n    bool transfersDisabled;\n  }\n\n  /**\n   * @notice Returns the top-level storage for the calling FAST.\n   * @return s a struct pointer for top-level FAST data storage.\n   */\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/fast/lib/LibFastAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../../lib/LibAddressSet.sol';\n\n/**\n * @notice This library centralises shared functionality between FAST diamonds facets that have to do with ACLs.\n * @dev Note that if you feel like a method should be created inside this library, you might want to really consider\n * whether or not it is the right place for it. Any facet using a method from internal libraries see their bytecode\n * size increase, kind of defeating the benefits of using facets in the first place. So please keep it reasonable. \n */\nlibrary LibFastAccess {\n  /// @notice The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  /// @notice This is keccak256('Fast.storage.Access'):\n  bytes32 internal constant STORAGE_SLOT = 0x87ed8063ac9ead3b2eb7551ed3d89b29fcbf44d6733084b5c82e95d5120ece9a;\n\n  /**\n   * @notice The access data structure required for operating any given FAST diamond.\n   * @dev The `version` field is used to ensure that storage is at a known version during upgrades.\n   */\n  struct Data {\n    /// @notice The latest intializer version that was called.\n    uint16 version;\n    /// @notice We hold the list of the FAST governors in there.\n    LibAddressSet.Data governorSet;\n    /// @notice The FAST members are held in there.\n    LibAddressSet.Data memberSet;\n  }\n\n  /**\n   * @notice Returns the access storage for the calling FAST.\n   * @return s a struct pointer for access FAST data storage.\n   */\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/fast/lib/LibFastHistory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\n/**\n * @notice This library centralises shared functionality between FAST diamonds facets that have to do with transfer\n * history tracking.\n * @dev Note that if you feel like a method should be created inside this library, you might want to really consider\n * whether or not it is the right place for it. Any facet using a method from internal libraries see their bytecode\n * size increase, kind of defeating the benefits of using facets in the first place. So please keep it reasonable. \n */\nlibrary LibFastHistory {\n  /// @notice The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  /// @notice This is keccak256('Fast.storage.History'):\n  bytes32 internal constant STORAGE_SLOT = 0x6bc8b61a9dd5fc049ea98027492a801d74e35fdf4d80d7fecd551a16e88fdbb4;\n\n  // Storage structures.\n\n  /**\n   * @notice The history data structure required for operating any given FAST diamond.\n   * @dev The `version` field is used to ensure that storage is at a known version during upgrades.\n   */\n  struct Data {\n    /// @notice The latest intializer version that was called.\n    uint16 version;\n    /// @notice All minting proofs are kept here.\n    SupplyProof[] supplyProofs;\n    /// @notice All transfer proofs are kept here.\n    TransferProof[] transferProofs;\n    /// @notice All transfers indices involving a given address are kept here.\n    mapping(address => uint256[]) transferProofInvolvements;\n  }\n\n  // Other structures.\n\n  /// @notice A minting operation could either be to mint or burn tokens.\n  enum SupplyOp { Mint, Burn }\n\n  /// @notice Minting operations are recorded for papertrail. This is the structure that keeps track of them.\n  struct SupplyProof {\n    /// @notice How...\n    SupplyOp op;\n    /// @notice How much...\n    uint256 amount;\n    /// @notice When...\n    uint256 blockNumber;\n    /// @notice Why...\n    string ref;\n  }\n\n  /// @notice Every transfer in is recorded. This is the structure that keeps track of them.\n  struct TransferProof {\n    /// @notice Who spent...\n    address spender;\n    /// @notice Who performed the transfer...\n    address from;\n    /// @notice Who received...\n    address to;\n    /// @notice How much...\n    uint256 amount;\n    /// @notice When...\n    uint256 blockNumber;\n    /// @notice Why...\n    string ref;\n  }\n\n  /**\n   * @notice Returns the history storage for the calling FAST.\n   * @return s a struct pointer for history FAST data storage.\n   */\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/fast/lib/LibFastToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../../lib/LibAddressSet.sol';\n\n\n/**\n * @notice This library centralises shared functionality between FAST diamonds facets that have to do with token related logic.\n * @dev Note that if you feel like a method should be created inside this library, you might want to really consider\n * whether or not it is the right place for it. Any facet using a method from internal libraries see their bytecode\n * size increase, kind of defeating the benefits of using facets in the first place. So please keep it reasonable. \n */\nlibrary LibFastToken {\n  /// @notice The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  /// @notice This is keccak256('Fast.storage.Token'):\n  bytes32 internal constant STORAGE_SLOT = 0xb098747b87c5c0e2a32eb9b06725e9bad4263809bcda628ceadc1a686bcb8261;\n\n  // Constants.\n\n  string internal constant DEFAULT_TRANSFER_REFERENCE = 'Unspecified - via ERC20';\n\n  // Data structures.\n\n  /**\n   * @notice The token data structure required for operating any given FAST diamond.\n   * @dev The `version` field is used to ensure that storage is at a known version during upgrades.\n   */\n  struct Data {\n    /// @notice The latest intializer version that was called.\n    uint16 version;\n    // ERC20 related properties for this FAST Token.\n    /// @notice The name of the FAST.\n    string name;\n    /// @notice The symbol for this FAST.\n    string symbol;\n    /// @notice The decimal points used by this FAST.\n    uint8 decimals;\n    /// @notice The amount of tokens in circulation.\n    uint256 totalSupply;\n    /// @notice Legacy variable.\n    uint256 LEGACY_transferCredits;\n    /// @notice Our members balances are held here.\n    mapping(address => uint256) balances;\n    // Allowances are stored here.\n    /// @notice Allowance amounts are stored in here, via mapping of `owner.spender.amount`\n    mapping(address => mapping(address => uint256)) allowances;\n    /// @notice A reverse lookup table allowing to retrieve allowances given by owner.\n    mapping(address => LibAddressSet.Data) allowancesByOwner;\n    /// @notice A reverse lookup table allowing to retrieve allowances given by spender.\n    mapping(address => LibAddressSet.Data) allowancesBySpender;\n    // Token holders\n    LibAddressSet.Data tokenHolders;\n  }\n\n  /**\n   * @notice Returns the token storage for the calling FAST.\n   * @return s a struct pointer for token FAST data storage.\n   */\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/interfaces/ICustomErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\ninterface ICustomErrors {\n  error AlreadyInitialized();\n  error InternalMethod();\n  error RequiresDiamondOwnership(address who);\n  error RequiresFastContractCaller();\n\n  error RequiresTransfersEnabled();\n  error RequiresIssuerMembership(address who);\n  error RequiresMarketplaceMembership(address who);\n  error RequiresMarketplaceActiveMembership(address who);\n  error RequiresMarketplaceDeactivatedMember(address who);\n\n  error RequiresValidTokenHolder(address who);\n  error RequiresFastGovernorship(address who);\n  error RequiresFastMembership(address who);\n  error RequiresNoFastMemberships(address who);\n\n  error DuplicateEntry();\n  error UnsupportedOperation();\n  error CannotSelfRemove(address who);\n\n  error RequiresContinuousSupply();\n  error RequiresPositiveBalance(address holder);\n  error RequiresDifferentSenderAndRecipient(address a);\n}\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n/// @title A facet providing diamond cut mechanisms.\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    /// a method with `delegatecall`.\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    /// _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n/// @title A loupe facet is a small magnifying glass used to look at diamonds. These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ All facets and their registered selectors.\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_ is the list of selectors for the given function.\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_ are all facet addresses registered with this diamond.\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @notice If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/// @title ERC165 definition - interface implementation queryability.\ninterface IERC165 {\n    /// @notice Queries if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC165.\n    /// @notice Interface identification is specified in ERC-165. This method uses less than 30,000 gas.\n    /// @return A `bool` set to `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff.\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/**\n * @title ERC173 Contract Ownership Standard\n * @dev The ERC165 identifier for this interface is 0x7f5828d0.\n */\ninterface IERC173 {\n    /// @notice This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @notice Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/// @title ERC20 standard as defined in the EIP.\ninterface IERC20 {\n  /**\n   * @notice Allows to query the total number of tokens in circulation.\n   * @return An `uint256` representing how many tokens are currently in circulation.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @notice Allows to query the balance of a given address.\n   * @param account is the address for which the balance shall be queried.\n   * @return An `uint256` - the balance for the given address.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @notice Moves `amount` tokens from the caller's account to `recipient`.\n   * @param recipient is the address to which the funds should be sent to, if successful.\n   * @param amount is the amount of tokens to transfef.\n   * @return A `bool` which value is `true` when the operation was successful.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @notice Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner`\n   * through `transferFrom`. This is zero by default.\n   * @dev This value changes when `approve`, `disapprove` and `transferFrom` / `transferFromWithRef` are called.\n   * @param owner is the owner of the funds.\n   * @param spender is the address for which the allowance should be queried.\n   * @return A `uint256` representing the remaining allowance of `spender` over `owner`'s funds.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @notice Increases the allowance of `spender` by `amount`.\n   * @param spender is the address towards which the allowance should be given.\n   * @return A `bool` set to `true` when the operation was successful.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @notice Attempts to transfer `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's allowance.\n   * @return A `bool` set to `true` when the operation was successful.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IHasActiveMembers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\n/// @title An interface signifying that the inheriting contract implements the concept of active memberships.\ninterface IHasActiveMembers {\n  /**\n   * @notice Queries whether a given account is a member of the marketplace and flagged as active.\n   * @param member is the address to query.\n   * @return A `bool` set to `true` if the candidate is an active member.\n   */\n  function isActiveMember(address member) external view returns(bool);\n\n  /**\n   * @notice Deactivates a given member address.\n   * @param member is the address to deactivate.\n   */\n  function deactivateMember(address payable member) external;\n\n  /**\n   * @notice Activates a given member address.\n   * @param member is the address to activate.\n   */\n  function activateMember(address member) external;\n}\n"
    },
    "contracts/interfaces/IHasGovernors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\n/// @title An interface signifying that the inheriting contract implements the concept of governorship ACLs.\ninterface IHasGovernors {\n  /**\n   * @notice Queries whether a given address is a governor or not.\n   * @param candidate is the address to test.\n   * @return A `bool` equal to `true` when `candidate` is a governor.\n   */\n  function isGovernor(address candidate) external view returns(bool);\n\n  /**\n   * @notice Queries the number of governors.\n   * @return An `uint256`.\n   */\n  function governorCount() external view returns(uint256);\n\n  /**\n   * @notice Queries pages of governors based on a start index and a page size.\n   * @param index is the offset at which the pagination operation should start.\n   * @param perPage is how many items should be returned.\n   * @return A `(address[], uint256)` tuple, which first item is the list of addresses and the second item a cursor to the next page.\n   */\n  function paginateGovernors(uint256 index, uint256 perPage) external view returns(address[] memory, uint256);\n\n  /**\n   * @notice Adds a governor to the list of known governors.\n   * @param governor is the address to be added.\n   */\n  function addGovernor(address payable governor) external;\n\n  /**\n   * @notice Removes a governor from the list of known governors.\n   * @param governor is the address to be removed.\n   */\n  function removeGovernor(address governor) external;\n}\n"
    },
    "contracts/interfaces/IHasMembers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\n/// @title An interface signifying that the inheriting contract implements the concept of membership ACLs.\ninterface IHasMembers {\n  /**\n   * @notice Queries whether a given address is a member or not.\n   * @param candidate is the address to test.\n   * @return A `bool` equal to `true` when `candidate` is a member.\n   */\n  function isMember(address candidate) external view returns(bool);\n\n  /**\n   * @notice Queries the number of members.\n   * @return An `uint256`.\n   */\n  function memberCount() external view returns(uint256);\n\n  /**\n   * @notice Queries pages of members based on a start index and a page size.\n   * @param index is the offset at which the pagination operation should start.\n   * @param perPage is how many items should be returned.\n   * @return A `(address[], uint256)` tuple, which first item is the list of addresses and the second item a cursor to the next page.\n   */\n  function paginateMembers(uint256 index, uint256 perPage) external view returns(address[] memory, uint256);\n\n  /**\n   * @notice Adds a member to the list of known members.\n   * @param candidate is the address to be added.\n   */\n  function addMember(address payable candidate) external;\n\n  /**\n   * @notice Removes a member from the list of known members.\n   * @param member is the address to be removed.\n   */\n  function removeMember(address member) external;\n}\n"
    },
    "contracts/issuer/IssuerAccessFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../lib/LibAddressSet.sol';\nimport '../lib/LibPaginate.sol';\nimport '../lib/LibHelpers.sol';\nimport '../interfaces/ICustomErrors.sol';\nimport '../interfaces/IHasMembers.sol';\nimport '../fast/FastTopFacet.sol';\nimport '../fast/FastTokenFacet.sol';\nimport './lib/AIssuerFacet.sol';\nimport './lib/LibIssuerAccess.sol';\nimport './lib/IIssuerEvents.sol';\nimport '../issuer/IssuerTopFacet.sol';\n\n\ncontract IssuerAccessFacet is AIssuerFacet, IHasMembers {\n  using LibAddressSet for LibAddressSet.Data;\n  // Membership management.\n\n  /**\n   * @notice Queries whether a given address is a member of this Issuer or not.\n   * @param candidate The address to test.\n   * @return A `boolean` flag.\n   */\n  function isMember(address candidate)\n      external override view returns(bool) {\n    return LibIssuerAccess.data().memberSet.contains(candidate);\n  }\n\n  /**\n   * @notice Counts the numbers of members present in this Issuer.\n   * @return The number of members in this Issuer.\n   */\n  function memberCount()\n      external override view returns(uint256) {\n    return LibIssuerAccess.data().memberSet.values.length;\n  }\n\n  /**\n   * @notice Paginates the members of this Issuer based on a starting cursor and a number of records per page.\n   * @param cursor The index at which to start.\n   * @param perPage How many records should be returned at most.\n   * @return A `address[]` list of values at most `perPage` big.\n   * @return A `uint256` index to the next page.\n   */\n  function paginateMembers(uint256 cursor, uint256 perPage)\n      external override view returns(address[] memory, uint256) {\n    return LibPaginate.addresses(LibIssuerAccess.data().memberSet.values, cursor, perPage);\n  }\n\n  /**\n   * @notice Adds a member to this Issuer member list.\n   * @param member The address of the member to be added.\n   * @notice Requires that the caller is a member of this Issuer.\n   * @notice Emits a `IHasMembers.MemberAdded` event.\n   */\n  function addMember(address payable member)\n      external override\n      onlyMember(msg.sender) {\n    // Add the member to our list.\n    LibIssuerAccess.data().memberSet.add(member, false);\n    // Emit!\n    emit MemberAdded(member);\n  }\n\n  /**\n   * @notice Removes a member from this Issuer.\n   * @param member The address of the member to be removed.\n   * @notice Requires that the caller is a member of this Issuer.\n   * @notice Emits a `IHasMembers.MemberRemoved` event.\n   */\n  function removeMember(address member)\n      external override\n      onlyDiamondOwner() {\n    // Remove the member from the set.\n    LibIssuerAccess.data().memberSet.remove(member, false);\n    // Emit!\n    emit MemberRemoved(member);\n  }\n\n  /** @notice Callback from FAST contracts allowing the Issuer contract to keep track of governorships.\n   * @param governor The governor added to a FAST.\n   */\n  function governorAddedToFast(address governor)\n      external {\n    // Verify that the given address is in fact a registered FAST contract.\n    if (!IssuerTopFacet(address(this)).isFastRegistered(msg.sender)) {\n      revert ICustomErrors.RequiresFastContractCaller();\n    }\n    // Keep track of the governorship.\n    LibIssuerAccess.data().fastGovernorships[governor].add(msg.sender, false);\n\n    emit GovernorshipAdded(msg.sender, governor);\n  }\n\n  /** @notice Callback from FAST contracts allowing the Issuer contract to keep track of governorships.\n   * @param governor The governor removed from a FAST.\n   */\n  function governorRemovedFromFast(address governor)\n      external {\n    // Verify that the given address is in fact a registered FAST contract.\n    if (!IssuerTopFacet(address(this)).isFastRegistered(msg.sender)) {\n      revert ICustomErrors.RequiresFastContractCaller();\n    }\n    // Remove the tracked governorship.\n    LibIssuerAccess.data().fastGovernorships[governor].remove(msg.sender, false);\n\n    emit GovernorshipRemoved(msg.sender, governor);\n  }\n\n  /** @notice Returns a list of FASTs that the passed address is a governor of.\n   * @param governor is the address to check governorships of.\n   * @param cursor is the index at which to start.\n   * @param perPage is how many records should be returned at most.\n   * @return A `address[]` list of values at most `perPage` big.\n   * @return A `uint256` index to the next page.\n   */\n  function paginateGovernorships(address governor, uint256 cursor, uint256 perPage)\n      external view\n      returns(address[] memory, uint256) {\n    return LibPaginate.addresses(LibIssuerAccess.data().fastGovernorships[governor].values, cursor, perPage);\n  }\n}\n"
    },
    "contracts/issuer/IssuerFrontendFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../lib/LibPaginate.sol';\nimport '../fast/FastFrontendFacet.sol';\nimport './lib/AIssuerFacet.sol';\nimport './lib/LibIssuer.sol';\n\n\ncontract IssuerFrontendFacet is AIssuerFacet {\n\n  // Public functions.\n\n  /**\n   * @notice Paginates the FAST diamonds registered with this Issuer based on a starting cursor and\n   *        a number of records per page. It returns rich details for each FAST diamond.\n   * @param cursor The index at which to start.\n   * @param perPage How many records should be returned at most.\n   * @return A `address[]` list of values at most `perPage` big.\n   * @return A `uint256` index to the next page.\n   */\n  function paginateDetailedFasts(uint256 cursor, uint256 perPage)\n      external view\n      returns(FastFrontendFacet.Details[] memory, uint256) {\n    (address[] memory addresses, uint256 nextCursor) = LibPaginate.addresses(LibIssuer.data().fastSet.values, cursor, perPage);\n    FastFrontendFacet.Details[] memory fastDetails = new FastFrontendFacet.Details[](addresses.length);\n    uint256 length = addresses.length;\n    for (uint256 i = 0; i < length;) {\n      fastDetails[i] = FastFrontendFacet(addresses[i]).details();\n      unchecked { ++i; }\n    }\n    return (fastDetails, nextCursor);\n  }\n}\n"
    },
    "contracts/issuer/IssuerInitFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../interfaces/IERC165.sol';       // Interface Support.\nimport '../interfaces/IERC173.sol';       // Ownership.\nimport '../interfaces/IDiamondCut.sol';   // Facet management.\nimport '../interfaces/IDiamondLoupe.sol'; // Facet introspection.\nimport '../interfaces/IHasMembers.sol';   // Membership management.\nimport '../interfaces/ICustomErrors.sol';\nimport '../lib/LibDiamond.sol';\nimport '../lib/LibAddressSet.sol';\nimport './lib/AIssuerFacet.sol';\nimport './lib/LibIssuer.sol';\nimport './lib/LibIssuerAccess.sol';\n\n\n/**\n * @title The Issuer Smart Contract.\n * @notice The marketplace contract is in charge of keeping track of marketplace members and has logic\n * related to trading.\n * It requires an Issuer contract instance at construct-time, as it relies on Issuer membership\n * to permission governance functions.\n */\ncontract IssuerInitFacet is AIssuerFacet {\n  using LibAddressSet for LibAddressSet.Data;\n\n  /// Initializers.\n\n  struct InitializerParams {\n    address payable member;\n  }\n\n  function initialize(InitializerParams calldata params)\n      external\n      onlyDiamondOwner() {\n    // Grab our top-level storage.\n    // Make sure we haven't initialized yet.\n    if (LibIssuer.data().version >= LibIssuer.STORAGE_VERSION) {\n      revert ICustomErrors.AlreadyInitialized();\n    }\n\n    // Register interfaces.\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n    ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n    ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n    ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n    ds.supportedInterfaces[type(IHasMembers).interfaceId] = true;\n\n    // ------------------------------------- //\n\n    // Initialize top-level storage.\n    LibIssuer.data().version = LibIssuer.STORAGE_VERSION;\n\n    // ------------------------------------- //\n\n    // Initialize access storage.\n    LibIssuerAccess.Data storage s = LibIssuerAccess.data();\n    s.version = LibIssuerAccess.STORAGE_VERSION;\n    // Add the member and emit.\n    s.memberSet.add(params.member, false);\n    emit MemberAdded(params.member);\n  }\n}\n"
    },
    "contracts/issuer/IssuerTopFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../interfaces/ICustomErrors.sol';\nimport '../lib/LibAddressSet.sol';\nimport '../lib/LibPaginate.sol';\nimport '../lib/LibHelpers.sol';\nimport '../fast/FastTopFacet.sol';\nimport '../fast/FastTokenFacet.sol';\nimport './lib/AIssuerFacet.sol';\nimport './lib/LibIssuer.sol';\n\n\ncontract IssuerTopFacet is AIssuerFacet {\n  using LibAddressSet for LibAddressSet.Data;\n  // FAST management related methods.\n\n  /**\n   * @notice Queries whether a given address is a known and registered FAST contract.\n   * @param fast The address of the contract to check.\n   * @return A boolean.\n   */\n  function isFastRegistered(address fast)\n      external view returns(bool) {\n    return LibIssuer.data().fastSet.contains(fast);\n  }\n\n  /**\n   * @notice Allows to retrieve the address of a FAST diamond given its symbol.\n   * @param symbol The symbol of the FAST diamond to get the address of.\n   * @return The address of the corresponding FAST diamond, or the Zero Address if not found.\n   */\n  function fastBySymbol(string calldata symbol)\n      external view returns(address) {\n    return LibIssuer.data().fastSymbols[symbol];\n  }\n\n  /**\n   * @notice Allows the registration of a given FAST diamond with this Issuer.\n   * @param fast The address of the FAST diamond to be registered.\n   * @notice Requires that the caller is a member of this Issuer.\n   * @notice Emits a `FastRegistered` event.\n   */\n  function registerFast(address fast)\n      external\n      onlyMember(msg.sender) {\n    LibIssuer.Data storage s = LibIssuer.data();\n    string memory symbol = FastTokenFacet(fast).symbol();\n    if (s.fastSymbols[symbol] != address(0)) {\n      revert ICustomErrors.DuplicateEntry();\n    }\n\n    // Add the FAST to our list.\n    s.fastSet.add(fast, false);\n    // Add the fast symbol to our list.\n    s.fastSymbols[symbol] = fast;\n\n    // Emit!\n    emit FastRegistered(fast);\n  }\n\n  /**\n   * @notice Counts the number of FAST diamonds registered with this Issuer.\n   * @return The number of FAST diamonds registered with this Issuer.\n   */\n  function fastCount()\n      external view returns(uint256) {\n    return LibIssuer.data().fastSet.values.length;\n  }\n\n  /**\n   * @notice Paginates the FAST diamonds registered with this Issuer based on a starting cursor and a number of records per page.\n   * @param cursor The index at which to start.\n   * @param perPage How many records should be returned at most.\n   * @return A `address[]` list of values at most `perPage` big.\n   * @return A `uint256` index to the next page.\n   */\n  function paginateFasts(uint256 cursor, uint256 perPage)\n      external view\n      returns(address[] memory, uint256) {\n    return LibPaginate.addresses(LibIssuer.data().fastSet.values, cursor, perPage);\n  }\n}\n"
    },
    "contracts/issuer/lib/AIssuerFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../../lib/LibConstants.sol';\nimport '../../lib/LibHelpers.sol';\nimport '../../lib/LibAddressSet.sol';\nimport '../../interfaces/IERC173.sol';\nimport '../../interfaces/ICustomErrors.sol';\nimport '../lib/LibIssuerAccess.sol';\nimport './IIssuerEvents.sol';\n\n\n/**\n* @notice This abstract contract encapsulates modifiers allowing inheriting facets to guard against\n* certain permissions.\n*/\nabstract contract AIssuerFacet is IIssuerEvents {\n  using LibAddressSet for LibAddressSet.Data;\n\n  /// Modifiers.\n\n  /// @notice Ensures that a method can only be called by another facet of the same diamond.\n  modifier onlyDiamondFacet() {\n    if (msg.sender != address(this)) {\n      revert ICustomErrors.InternalMethod();\n    }\n    _;\n  }\n\n  /// @notice Ensures that a method can only be called by the owner of this diamond.\n  modifier onlyDiamondOwner() {\n    if (msg.sender != IERC173(address(this)).owner()) {\n      revert ICustomErrors.RequiresDiamondOwnership(msg.sender);\n    }\n    _;\n  }\n\n  /// @notice Ensures that the given address is a member of the current FAST.\n  modifier onlyMember(address candidate) {\n    if (!LibIssuerAccess.data().memberSet.contains(candidate)) {\n      revert ICustomErrors.RequiresIssuerMembership(candidate);\n    }\n    _;\n  }\n}\n"
    },
    "contracts/issuer/lib/IIssuerEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\n// WARNING: These events must be maintained 1:1 with LibIssuerEvents!\n// They also should never be emitted directly, they only help us defining\n// typescript types!\ninterface IIssuerEvents {\n  // Fast registration events.\n\n  /**\n   * @notice Emited when a new FAST is registered.\n   * @param fast The address of the newly registered FAST diamond.\n   */\n  event FastRegistered(address indexed fast);\n\n  // IHasMembers.\n\n  event MemberAdded(address indexed member);\n  event MemberRemoved(address indexed member);\n\n  // Governors.\n\n  event GovernorshipRemoved(address indexed fast, address indexed governor);\n  event GovernorshipAdded(address indexed fast, address indexed governor);\n}\n"
    },
    "contracts/issuer/lib/LibIssuer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../../lib/LibAddressSet.sol';\n\n\nlibrary LibIssuer {\n  // The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  // This is keccak256('Issuer.storage'):\n  bytes32 internal constant STORAGE_SLOT = 0xd681d5f1de7bc4b7442c088939dc202585e09699e92a94c9717ace8d0f4fcaa5;\n\n  // Data structures.\n\n  struct Data {\n    /// @notice The latest intializer version that was called.\n    uint16 version;\n    // This is where we keep our list of deployed fast FASTs.\n    LibAddressSet.Data fastSet;\n    // We keep track of the FAST symbols that were already used.\n    mapping(string => address) fastSymbols;\n  }\n\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/issuer/lib/LibIssuerAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../../lib/LibAddressSet.sol';\n\n\nlibrary LibIssuerAccess {\n  // The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  // This is keccak256('Issuer.storage.Access'):\n  bytes32 internal constant STORAGE_SLOT = 0x3ceaa4d5edf9c96fbd56140abe6389d65a87143d4f11819874ff2fe0ae9574db;\n\n  struct Data {\n    /// @notice The latest intializer version that was called.\n    uint16 version;\n    // This is where we hold our members data.\n    LibAddressSet.Data memberSet;\n    // For a given address we store list of FASTs where that address is a governor.\n    mapping(address => LibAddressSet.Data) fastGovernorships;\n  }\n\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/lib/LibAddressSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\nlibrary LibAddressSet {\n  /// @notice Represents a list of addresses.\n  struct Data {\n    mapping(address => uint256) indices;\n    address[] values;\n  }\n\n  /**\n   * @notice Adds an item into the storage set. If the address already exists in the set, the method reverts.\n   * @param d is the internal data storage to use.\n   * @param key is the address to be added.\n   */\n  function add(Data storage d, address key, bool noThrow)\n      internal {\n    bool exists = contains(d, key);\n    if (noThrow && exists) { return; }\n    require(!exists, 'Address already in set');\n    d.indices[key] = d.values.length;\n    d.values.push(key);\n  }\n\n  /**\n   * @notice Removes an item from the storage set. If the address does not exist in the set, the method reverts.\n   * @param d is the internal data storage to use.\n   * @param key is the address to be removed.\n   */\n  function remove(Data storage d, address key, bool noThrow)\n      internal {\n    bool exists = contains(d, key);\n    if (noThrow && !exists) { return; }\n    require(exists, 'Address does not exist in set');\n    address keyToMove = d.values[d.values.length - 1];\n    uint256 idxToReplace = d.indices[key];\n    d.indices[keyToMove] = idxToReplace;\n    d.values[idxToReplace] = keyToMove;\n\n    delete d.indices[key];\n    d.values.pop();\n  }\n\n  /**\n   * @notice Tests whether or not a given item already exists in the set.\n   * @param d is the internal data storage to use.\n   * @param key is the address to test.\n   * @return a boolean.\n   */\n  function contains(Data storage d, address key)\n      internal view returns(bool) {\n    return d.values.length == 0\n      ? false\n      : d.values[d.indices[key]] == key;\n  }\n}\n"
    },
    "contracts/lib/LibConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\nlibrary LibConstants {\n  address internal constant ZERO_ADDRESS = address(0);\n  address internal constant DEPLOYER_CONTRACT = 0x6DF2D25d8C6FD680730ee658b530A05a99BB769a;\n\n  string internal constant INSUFFICIENT_TRANSFER_CREDITS = 'Insufficient transfer credits';\n  string internal constant REQUIRES_MARKETPLACE_MEMBERSHIP = 'Requires Marketplace membership';\n  string internal constant REQUIRES_FAST_MEMBERSHIP = 'Requires FAST membership';\n  string internal constant REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT = 'Requires different sender and recipient';\n\n  string internal constant DEAD_TOKENS_RETRIEVAL = 'Dead tokens retrieval';\n}"
    },
    "contracts/lib/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/lib/LibHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nlibrary LibHelpers {\n}\n"
    },
    "contracts/lib/LibPaginate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../fast/lib/LibFastHistory.sol';\n\n\nlibrary LibPaginate {\n  function addresses(address[] storage collection, uint256 cursor, uint256 perPage)\n    internal view returns(address[] memory, uint256) {\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\n      address[] memory values = new address[](length);\n      for (uint256 i = 0; i < length;) {\n        values[i] = collection[cursor + i];\n        unchecked { ++i; }\n      }\n      return (values, cursor + length);\n  }\n\n  function uint256s(uint256[] storage collection, uint256 cursor, uint256 perPage)\n    internal view returns(uint256[] memory, uint256) {\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\n      uint256[] memory values = new uint256[](length);\n      for (uint256 i = 0; i < length;) {\n        values[i] = collection[cursor + i];\n        unchecked { ++i; }\n      }\n      return (values, cursor + length);\n  }\n\n  function supplyProofs(LibFastHistory.SupplyProof[] storage collection, uint256 cursor, uint256 perPage)\n    internal view returns(LibFastHistory.SupplyProof[] memory, uint256) {\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\n      LibFastHistory.SupplyProof[] memory values = new LibFastHistory.SupplyProof[](length);\n      for (uint256 i = 0; i < length;) {\n        values[i] = collection[cursor + i];\n        unchecked { ++i; }\n      }\n      return (values, cursor + length);\n  }\n\n  function transferProofs(LibFastHistory.TransferProof[] storage collection, uint256 cursor, uint256 perPage)\n    internal view returns(LibFastHistory.TransferProof[] memory, uint256) {\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\n      LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\n      for (uint256 i = 0; i < length;) {\n        values[i] = collection[cursor + i];\n        unchecked { ++i; }\n      }\n      return (values, cursor + length);\n  }\n}"
    },
    "contracts/marketplace/lib/AMarketplaceFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../../lib/LibConstants.sol';\nimport '../../lib/LibAddressSet.sol';\nimport '../lib/LibMarketplace.sol';\nimport '../lib/LibMarketplaceAccess.sol';\nimport '../lib/LibMarketplaceTokenHolders.sol';\nimport '../../interfaces/IERC173.sol';\nimport '../../interfaces/ICustomErrors.sol';\nimport '../../interfaces/IHasMembers.sol';\nimport './IMarketplaceEvents.sol';\n\n\n/**\n* @notice This contract is a group of modifiers that can be used by any Marketplace facets to guard against\n*       certain permissions.\n*/\nabstract contract AMarketplaceFacet is IMarketplaceEvents {\n  using LibAddressSet for LibAddressSet.Data;\n\n  // Modifiers.\n\n  /// @notice Ensures that a method can only be called by the singleton deployer contract factory.\n  modifier onlyDeployer() {\n    if (msg.sender != LibConstants.DEPLOYER_CONTRACT) {\n      revert ICustomErrors.InternalMethod();\n    }\n    _;\n  }\n\n  /**\n   * @notice Requires that the message sender is a member of the linked Issuer.\n   */\n  modifier onlyIssuerMember() {\n    if (!IHasMembers(LibMarketplace.data().issuer).isMember(msg.sender)) {\n      revert ICustomErrors.RequiresIssuerMembership(msg.sender);\n    }\n    _;\n  }\n\n  /**\n   * @notice Requires that the given address is a member of the marketplace.\n   * @param candidate is the address to be checked.\n   */\n  modifier onlyMember(address candidate) {\n    if (!LibMarketplaceAccess.data().memberSet.contains(candidate)) {\n      revert ICustomErrors.RequiresMarketplaceMembership(candidate);\n    }\n    _;\n  }\n}\n"
    },
    "contracts/marketplace/lib/IMarketplaceEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\ninterface IMarketplaceEvents {\n  // IHasMembers.\n\n  event MemberAdded(address indexed member);\n  event MemberRemoved(address indexed member);\n\n  // IHasActiveMembers.\n  event MemberActivated(address indexed member);\n  event MemberDeactivated(address indexed member);\n}\n"
    },
    "contracts/marketplace/lib/LibMarketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../../lib/LibAddressSet.sol';\n\n\nlibrary LibMarketplace {\n  // The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  // This is keccak256('Marketplace.storage'):\n  bytes32 internal constant STORAGE_SLOT = 0xb59ec141376cee83f618e10e881bbb4789cdeee27e0d441a8c37ead3cb8b93c1;\n\n  struct Data {\n    /// @notice The latest intializer version that was called.\n    uint16 version;\n    /// @notice The internal pointer to the Issuer contract.\n    address issuer;\n  }\n\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/marketplace/lib/LibMarketplaceAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../../lib/LibAddressSet.sol';\n\n\nlibrary LibMarketplaceAccess {\n  // The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  // This is keccak256('Marketplace.storage.Access'):\n  bytes32 internal constant STORAGE_SLOT = 0xecb992c7a1185ca18ac50bc1672192fb67e7c3e74465887a8fcaab265dab37bd;\n\n  struct Data {\n    /// @notice The latest intializer version that was called.\n    uint16 version;\n    /// @notice This is where we hold our members data.\n    LibAddressSet.Data memberSet;\n    /// @notice This is where we keep track of our member FAST memberships.\n    mapping(address => LibAddressSet.Data) fastMemberships;\n    /// @notice This is where we keep track of our deactivated memberships.\n    LibAddressSet.Data deactivatedMemberSet;\n  }\n\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/marketplace/lib/LibMarketplaceTokenHolders.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../../lib/LibAddressSet.sol';\n\n\nlibrary LibMarketplaceTokenHolders {\n  // The current version of the storage.\n  uint16 internal constant STORAGE_VERSION = 1;\n  // This is keccak256('Marketplace.TokenHolders.storage'):\n  bytes32 internal constant STORAGE_SLOT = 0xecf50453542504034bd40d376fb1408ada3025f2fe86ca1b9b4b1440b8d4a2f4;\n\n  struct Data {\n    /// @dev The latest intializer version that was called.\n    uint16 version;\n    /// @dev The tracked FAST holdings of a user.\n    mapping(address => LibAddressSet.Data) fastHoldings;\n  }\n\n  function data()\n      internal pure returns(Data storage s) {\n    assembly {s.slot := STORAGE_SLOT}\n  }\n}\n"
    },
    "contracts/marketplace/MarketplaceAccessFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../lib/LibAddressSet.sol';\nimport '../lib/LibPaginate.sol';\nimport '../issuer/IssuerTopFacet.sol';\nimport '../interfaces/ICustomErrors.sol';\nimport '../interfaces/IHasMembers.sol';\nimport '../interfaces/IHasActiveMembers.sol';\nimport './lib/LibMarketplaceAccess.sol';\nimport './lib/AMarketplaceFacet.sol';\n\n\n/**\n * @title The Marketplace Smart Contract.\n * @notice The Marketplace Access facet is in charge of keeping track of marketplace members.\n */\ncontract MarketplaceAccessFacet is AMarketplaceFacet, IHasMembers, IHasActiveMembers {\n  using LibAddressSet for LibAddressSet.Data;\n\n  // Membership management.\n\n  /**\n   * @notice Queries whether a given address is a member of this Marketplace or not.\n   * @param candidate is the address to test.\n   * @return A `boolean` flag.\n   */\n  function isMember(address candidate)\n      external override view returns(bool) {\n    return LibMarketplaceAccess.data().memberSet.contains(candidate);\n  }\n\n  /**\n   * @notice Counts the numbers of members present in this Marketplace.\n   * @return The number of members in this marketplace.\n   */\n  function memberCount()\n      external override view returns(uint256) {\n    return LibMarketplaceAccess.data().memberSet.values.length;\n  }\n\n  /**\n   * @notice Paginates the members of this Marketplace based on a starting cursor and a number of records per page.\n   * @param cursor is the index at which to start.\n   * @param perPage is how many records should be returned at most.\n   * @return A `address[]` list of values at most `perPage` big.\n   * @return A `uint256` index to the next page.\n   */\n  function paginateMembers(uint256 cursor, uint256 perPage)\n      external override view returns(address[] memory, uint256) {\n    return LibPaginate.addresses(LibMarketplaceAccess.data().memberSet.values, cursor, perPage);\n  }\n\n  /**\n   * @notice Adds a member to this Marketplace member list.\n   * @param member is the address of the member to be added.\n   * @notice Requires that the caller is a member of the linked Issuer.\n   * @notice Emits a `IHasMembers.MemberAdded` event.\n   */\n  function addMember(address payable member)\n      external override\n      onlyIssuerMember {\n    // Add the member to our list.\n    LibMarketplaceAccess.data().memberSet.add(member, false);\n    // Emit!\n    emit MemberAdded(member);\n  }\n\n  /**\n   * @notice Removes a member from this Marketplace.\n   * @param member is the address of the member to be removed.\n   * @notice Requires that the caller is a member of the linked Issuer.\n   * @notice Emits a `IHasMembers.MemberRemoved` event.\n   */\n  function removeMember(address member)\n      external override\n      onlyIssuerMember {\n    LibMarketplaceAccess.Data storage s = LibMarketplaceAccess.data();\n    // Ensure that member doesn't have any FAST membership.\n    if (s.fastMemberships[member].values.length != 0) {\n      revert ICustomErrors.RequiresNoFastMemberships(member);\n    }\n    // Remove member.\n    s.memberSet.remove(member, false);\n    // Emit!\n    emit MemberRemoved(member);\n  }\n\n  /**\n   * @notice Allows to query FAST memberships for a given member address.\n   * @param member Is the address to check.\n   * @param cursor The index at which to start.\n   * @param perPage How many records should be returned at most.\n   */\n  function fastMemberships(address member, uint256 cursor, uint256 perPage)\n      external view returns(address[] memory, uint256) {\n    return LibPaginate.addresses(LibMarketplaceAccess.data().fastMemberships[member].values, cursor, perPage);\n  }\n\n  /**\n   * @notice Callback from FAST contracts allowing the Marketplace contract to keep track of FAST memberships.\n   * @param member The member for which a new FAST membership has been added.\n   */\n  function memberAddedToFast(address member) \n      external {\n    // Verify that the given address is in fact a registered FAST contract.\n    if (!IssuerTopFacet(LibMarketplace.data().issuer).isFastRegistered(msg.sender)) {\n      revert ICustomErrors.RequiresFastContractCaller();\n    }\n    // Keep track of the member's FAST membership.\n    LibMarketplaceAccess.data().fastMemberships[member].add(msg.sender, false);\n  }\n\n  /**\n   * @notice Callback from FAST contracts allowing the Marketplace contract to keep track of FAST memberships.\n   * @param member The member for which a FAST membership has been removed.\n   */\n  function memberRemovedFromFast(address member)\n      external {\n    if (!IssuerTopFacet(LibMarketplace.data().issuer).isFastRegistered(msg.sender)) {\n      revert ICustomErrors.RequiresFastContractCaller();\n    }\n    // Remove the tracked membership.\n    LibMarketplaceAccess.data().fastMemberships[member].remove(msg.sender, false);\n  }\n\n  /**\n   * @notice Given a member returns it's activation status.\n   * @param candidate The address to check activation status on.\n   */\n  function isActiveMember(address candidate) external override view returns(bool) {\n    return IHasMembers(this).isMember(candidate) &&\n           !LibMarketplaceAccess.data().deactivatedMemberSet.contains(candidate);\n  }\n\n  /**\n   * @notice Activates a member at the Marketplace level.\n   * @param member The member to remove from the deactivation member set.\n   */\n  function activateMember(address member)\n    external\n    override\n    onlyIssuerMember\n    onlyMember(member) {\n    // Guard against attempting to activate an already active member.\n    if (this.isActiveMember(member)) {\n      revert ICustomErrors.RequiresMarketplaceDeactivatedMember(member);\n    }\n\n    // Remove the member from the deactivated members list.\n    LibMarketplaceAccess.data().deactivatedMemberSet.remove(member, false);\n\n    // Emit!\n    emit MemberActivated(member);\n  }\n\n  /**\n   * @notice Deactivates a member at the Marketplace level.\n   * @param member The member to add to the deactivation member set.\n   */\n  function deactivateMember(address payable member)\n    external\n    override\n    onlyIssuerMember\n    onlyMember(member) {\n    // Guard against attempting to deactivate an already deactivated member.\n    if (!this.isActiveMember(member)) {\n      revert ICustomErrors.RequiresMarketplaceActiveMembership(member);\n    }\n\n    // Add the member to the deactivated members list.\n    LibMarketplaceAccess.data().deactivatedMemberSet.add(member, false);\n\n    // Emit!\n    emit MemberDeactivated(member);\n  }\n}\n"
    },
    "contracts/marketplace/MarketplaceInitFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../interfaces/IERC165.sol';        // Interface Support.\nimport '../interfaces/IERC173.sol';        // Ownership.\nimport '../interfaces/IDiamondCut.sol';    // Facet management.\nimport '../interfaces/IDiamondLoupe.sol';  // Facet introspection.\nimport '../interfaces/IHasMembers.sol';    // Membership management.\nimport '../interfaces/ICustomErrors.sol';\nimport '../lib/LibDiamond.sol';\nimport './lib/AMarketplaceFacet.sol';\n\n\n/// @notice The Marketplace initialization facet.\ncontract MarketplaceInitFacet is AMarketplaceFacet {\n  struct InitializerParams {\n    address issuer;\n  }\n\n  function initialize(InitializerParams calldata params)\n      external\n      onlyDeployer {\n    // Make sure we haven't initialized yet.\n    if (LibMarketplace.data().version >= LibMarketplace.STORAGE_VERSION) {\n      revert ICustomErrors.AlreadyInitialized();\n    }\n\n    // Register interfaces.\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n    ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n    ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n    ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n    ds.supportedInterfaces[type(IHasMembers).interfaceId] = true;\n\n    // ------------------------------------- //\n\n    // Initialize top-level storage.\n    LibMarketplace.Data storage topData = LibMarketplace.data();\n    topData.version = LibMarketplace.STORAGE_VERSION;\n    topData.issuer = params.issuer;\n\n    // ------------------------------------- //\n\n    // Initialize access storage.\n    LibMarketplaceAccess.data().version = LibMarketplaceAccess.STORAGE_VERSION;\n\n    // ------------------------------------- //\n\n    // Initialize token holders storage.\n    LibMarketplaceTokenHolders.data().version = LibMarketplaceTokenHolders.STORAGE_VERSION;\n  }\n}\n"
    },
    "contracts/marketplace/MarketplaceTokenHoldersFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport './lib/AMarketplaceFacet.sol';\nimport '../issuer/IssuerTopFacet.sol';\nimport '../interfaces/IERC20.sol';\nimport '../interfaces/ICustomErrors.sol';\n\n/** @dev The Marketplace FAST balances facet.\n */\ncontract MarketplaceTokenHoldersFacet is AMarketplaceFacet {\n  using LibAddressSet for LibAddressSet.Data;\n\n  /** @dev The callback used when a balance changes on a FAST.\n   */\n  function fastBalanceChanged(address account, uint256 balance)\n    external {\n    // Return early if this is the zero address.\n    if (account == address(0)) {\n      return;\n    }\n\n    // Verify that the given address is in fact a registered FAST contract.\n    if (!IssuerTopFacet(LibMarketplace.data().issuer).isFastRegistered(msg.sender)) {\n      revert ICustomErrors.RequiresFastContractCaller();\n    }\n\n    // Get the storage pointer and balance of the token holder.\n    LibMarketplaceTokenHolders.Data storage s = LibMarketplaceTokenHolders.data();\n\n    // If this is a positive balance and it doesn't already exist in the set, add address.\n    if (balance > 0 && !s.fastHoldings[account].contains(msg.sender)) {\n      s.fastHoldings[account].add(msg.sender, false);\n    }\n    // If the balance is 0 and it exists in the set, remove it.\n    else if (balance == 0 && s.fastHoldings[account].contains(msg.sender)) {\n      s.fastHoldings[account].remove(msg.sender, false);\n    }\n  }\n\n  /** @dev A way to get a list of FASTs for an account.\n   *  @return list of FAST addresses.\n   */\n  function holdings(address account)\n    external view\n    returns(address[] memory) {\n    LibMarketplaceTokenHolders.Data storage s = LibMarketplaceTokenHolders.data();\n    return s.fastHoldings[account].values;\n  }\n}\n"
    },
    "contracts/marketplace/MarketplaceTopFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport '../lib/LibAddressSet.sol';\nimport '../lib/LibPaginate.sol';\nimport '../issuer/IssuerTopFacet.sol';\nimport './lib/LibMarketplace.sol';\nimport '../interfaces/IHasMembers.sol';\nimport './lib/AMarketplaceFacet.sol';\n\n\n/**\n * @title The Marketplace Smart Contract.\n * @notice The Marketplace Top facet is in charge of keeping track of common parameters and provides\n * generic functionality.\n */\ncontract MarketplaceTopFacet is AMarketplaceFacet {\n  // Getters.\n\n  function issuerAddress()\n    external view returns(address) {\n      return LibMarketplace.data().issuer;\n  }\n}\n"
    }
  },
  "settings": {
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}