{
  "address": "0x3F90655De4d6FDdFf31e56e1320Fc473eE24432d",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "governor",
          "type": "address"
        }
      ],
      "name": "GovernorAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "governor",
          "type": "address"
        }
      ],
      "name": "GovernorRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "MemberAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "MemberRemoved",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "governor",
          "type": "address"
        }
      ],
      "name": "addGovernor",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "addMember",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "a",
          "type": "address"
        }
      ],
      "name": "flags",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bool",
              "name": "isGovernor",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "isMember",
              "type": "bool"
            }
          ],
          "internalType": "struct FastAccessFacet.Flags",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "governorCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "candidate",
          "type": "address"
        }
      ],
      "name": "isGovernor",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "candidate",
          "type": "address"
        }
      ],
      "name": "isMember",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "memberCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "perPage",
          "type": "uint256"
        }
      ],
      "name": "paginateGovernors",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "perPage",
          "type": "uint256"
        }
      ],
      "name": "paginateMembers",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "governor",
          "type": "address"
        }
      ],
      "name": "removeGovernor",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "member",
          "type": "address"
        }
      ],
      "name": "removeMember",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xc0349767c2a7716af6e5b2576d220159c57e620effd3fb4a8e7aed647cb1aecd",
  "receipt": {
    "to": "0x6DF2D25d8C6FD680730ee658b530A05a99BB769a",
    "from": "0x717634cfe06FFAB2CEAA7fcf1b9019813f4B25FE",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "1824219",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa9a5bd9e2af01fdd01f3cd271d2ed7590d8abcc57b076827797c8b7821f15061",
    "transactionHash": "0xc0349767c2a7716af6e5b2576d220159c57e620effd3fb4a8e7aed647cb1aecd",
    "logs": [],
    "blockNumber": 12762522,
    "cumulativeGasUsed": "1824219",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "ff01faa9007aa585a44363003101a726",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"}],\"name\":\"GovernorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"}],\"name\":\"GovernorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"governor\",\"type\":\"address\"}],\"name\":\"addGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"addMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"flags\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isGovernor\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isMember\",\"type\":\"bool\"}],\"internalType\":\"struct FastAccessFacet.Flags\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governorCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"}],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"}],\"name\":\"isMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"memberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perPage\",\"type\":\"uint256\"}],\"name\":\"paginateGovernors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perPage\",\"type\":\"uint256\"}],\"name\":\"paginateMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"}],\"name\":\"removeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"The FAST Access Smart Contract is the source of truth when it comes to permissioning and ACLs within a given FAST network.\",\"kind\":\"dev\",\"methods\":{\"addGovernor(address)\":{\"details\":\"Adds a governor to the governorship list.\"},\"addMember(address)\":{\"details\":\"Adds a member to the membership list.\"},\"flags(address)\":{\"details\":\"Retrieves flags for a given address.\"},\"governorCount()\":{\"details\":\"Queries the number of governors in the governorship list.\"},\"isGovernor(address)\":{\"details\":\"Queries whether a given address is a governor or not.\"},\"isMember(address)\":{\"details\":\"Queries whether a given address is a member or not.\"},\"memberCount()\":{\"details\":\"Queries the number of members in the membership list.\"},\"paginateGovernors(uint256,uint256)\":{\"details\":\"Returns a page of governors.\"},\"paginateMembers(uint256,uint256)\":{\"details\":\"Returns a page of members.\"},\"removeGovernor(address)\":{\"details\":\"Removes a governor from the governorship list.\"},\"removeMember(address)\":{\"details\":\"Removes a member from the membership list.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/fast/FastAccessFacet.sol\":\"FastAccessFacet\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/exchange/ExchangeTopFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../spc/SpcTopFacet.sol';\\nimport './lib/LibExchange.sol';\\nimport '../interfaces/IHasMembers.sol';\\nimport './lib/AExchangeFacet.sol';\\n\\n\\n/** @title The Exchange Smart Contract.\\n *  @dev The exchange facet is in charge of keeping track of exchange members and has logic\\n *  related to trading.\\n *  It requires an SPC contract instance at initialization-time, as it relies on SPC membership\\n *  to permission governance functions.\\n *  For now, the Exchange contract will only have one facet. Later on, we should split its\\n *  business logic into as many facets as we have domains.\\n */\\ncontract ExchangeTopFacet is AExchangeFacet, IHasMembers {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Getters.\\n\\n  function spcAddress()\\n    external view returns(address) {\\n      return LibExchange.data().spc;\\n  }\\n\\n  // Membership management.\\n\\n  /** @dev Queries whether a given address is a member of this Exchange or not.\\n   *  @param candidate is the address to test.\\n   *  @return A `boolean` flag.\\n   */\\n  function isMember(address candidate)\\n      external override view returns(bool) {\\n    return LibExchange.data().memberSet.contains(candidate);\\n  }\\n\\n  /** @dev Counts the numbers of members present in this Exchange.\\n   *  @return The number of members in this exchange.\\n   */\\n  function memberCount()\\n      external override view returns(uint256) {\\n    return LibExchange.data().memberSet.values.length;\\n  }\\n\\n  /** @dev Paginates the members of this Exchange based on a starting cursor and a number of records per page.\\n   *  @param cursor is the index at which to start.\\n   *  @param perPage is how many records should be returned at most.\\n   *  @return A `address[]` list of values at most `perPage` big.\\n   *  @return A `uint256` index to the next page.\\n   */\\n  function paginateMembers(uint256 cursor, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibExchange.data().memberSet.values, cursor, perPage);\\n  }\\n\\n  /** @dev Adds a member to this Exchange member list.\\n   *  @param member is the address of the member to be added.\\n   *  @notice Requires that the caller is a member of the linked SPC.\\n   *  @notice Emits a `IHasMembers.MemberAdded` event.\\n   */\\n  function addMember(address payable member)\\n      external override\\n      spcMembership(msg.sender) {\\n    // Add the member to our list.\\n    LibExchange.data().memberSet.add(member, false);\\n    // Emit!\\n    emit IHasMembers.MemberAdded(member);\\n  }\\n\\n  /** @dev Removes a member from this Exchange.\\n   *  @param member is the address of the member to be removed.\\n   *  @notice Requires that the caller is a member of the linked SPC.\\n   *  @notice Emits a `IHasMembers.MemberRemoved` event.\\n   */\\n  function removeMember(address member)\\n      external override\\n      spcMembership(msg.sender) {\\n    LibExchange.Data storage s = LibExchange.data();\\n    // Ensure that member doesn't have any FAST membership.\\n    require(s.fastMemberships[member].values.length == 0, LibConstants.REQUIRES_NO_FAST_MEMBERSHIPS);\\n    // Remove member.\\n    s.memberSet.remove(member, false);\\n    // Emit!\\n    emit IHasMembers.MemberRemoved(member);\\n  }\\n\\n  /** @dev Allows to query FAST memberships for a given member address.\\n   *  @param member Is the address to check.\\n   *  @param cursor The index at which to start.\\n   *  @param perPage How many records should be returned at most.\\n   */\\n  function fastMemberships(address member, uint256 cursor, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibExchange.data().fastMemberships[member].values, cursor, perPage);\\n  }\\n\\n  /** @dev Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.\\n   *  @param member The member for which a new FAST membership has been added.\\n   */\\n  function memberAddedToFast(address member) \\n      external {\\n    LibExchange.Data storage s = LibExchange.data();\\n    // Verify that the given address is in fact a registered FAST contract.\\n    require(SpcTopFacet(s.spc).isFastRegistered(msg.sender), LibConstants.REQUIRES_FAST_CONTRACT_CALLER);\\n    // Keep track of the member's FAST membership.\\n    LibAddressSet.Data storage memberFasts = s.fastMemberships[member];\\n    memberFasts.add(msg.sender, false);\\n  }\\n\\n  /** @dev Callback from FAST contracts allowing the Exchange contract to keep track of FAST memberships.\\n   *  @param member The member for which a FAST membership has been removed.\\n   */\\n  function memberRemovedFromFast(address member)\\n      external {\\n    LibExchange.Data storage s = LibExchange.data();\\n    require(SpcTopFacet(s.spc).isFastRegistered(msg.sender), LibConstants.REQUIRES_FAST_CONTRACT_CALLER);\\n    // Remove the tracked membership.\\n    LibAddressSet.Data storage memberFasts = s.fastMemberships[member];\\n    memberFasts.remove(msg.sender, false);\\n  }\\n}\\n\",\"keccak256\":\"0xcc14c96ccdbc94599a0b5d34e45461c825ee4c28a874cb078edf11018aae0077\",\"license\":\"MIT\"},\"contracts/exchange/lib/AExchangeFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../lib/LibExchange.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../../interfaces/IHasMembers.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any Exchange facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract AExchangeFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\\n  modifier diamondInternal() {\\n    require(msg.sender == address(this), LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\\n  modifier diamondOwner() {\\n    require(msg.sender == IERC173(address(this)).owner(), LibConstants.REQUIRES_DIAMOND_OWNERSHIP);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\\n  modifier deployerContract() {\\n    require(msg.sender == LibConstants.DEPLOYER_CONTRACT, LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /** @dev Requires that the given address is a member of the linked SPC.\\n   *  @param candidate is the address to be checked.\\n   */\\n  modifier spcMembership(address candidate) {\\n    require(IHasMembers(LibExchange.data().spc).isMember(candidate), LibConstants.REQUIRES_SPC_MEMBERSHIP);\\n    _;\\n  }\\n\\n  /** @dev Requires that the given address is a member of the exchange.\\n   *  @param candidate is the address to be checked.\\n   */\\n  modifier membership(address candidate) {\\n    require(LibExchange.data().memberSet.contains(candidate), LibConstants.REQUIRES_FAST_MEMBERSHIP);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x80a065d5ae056ce96159b02adac4fb5f877169f2a9fbaa05434e4644bdc5cef0\",\"license\":\"MIT\"},\"contracts/exchange/lib/LibExchange.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibExchange {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Exchange.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x58cca9481e011ced58c1d520ef5aad456e5805265d66de8df7c52f680c417394;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev The internal pointer to the SPC contract.\\n    address spc;\\n    /// @dev This is where we hold our members data.\\n    LibAddressSet.Data memberSet;\\n    /// @dev This is where we keep track of our member FAST memberships.\\n    mapping(address => LibAddressSet.Data) fastMemberships;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xbaff538549fe11007601a828a4359fbfdcf84253e5bf424e96eb0e55014de80a\",\"license\":\"MIT\"},\"contracts/fast/FastAccessFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../interfaces/IHasMembers.sol';\\nimport '../interfaces/IHasGovernors.sol';\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../exchange/ExchangeTopFacet.sol';\\nimport './FastTokenFacet.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFast.sol';\\nimport './lib/LibFastAccess.sol';\\nimport './FastTopFacet.sol';\\n\\n\\n/**\\n* @dev The FAST Access Smart Contract is the source of truth when it comes to\\n* permissioning and ACLs within a given FAST network.\\n*/\\ncontract FastAccessFacet is AFastFacet, IHasMembers, IHasGovernors {\\n  using LibAddressSet for LibAddressSet.Data;\\n  /// Structs.\\n\\n  /**\\n   * @dev This structure isn't used anywhere in storage. Instead, it\\n   * allows various methods of the contract to return all the flags\\n   * associated with a given address in one go.\\n   */\\n  struct Flags {\\n    bool isGovernor;\\n    bool isMember;\\n  }\\n\\n  /// Constants.\\n\\n  // This represents how much Eth we provision new governors with.\\n  uint256 constant private GOVERNOR_ETH_PROVISION = 10 ether;\\n  // This represents how much Eth we provision new members with.\\n  uint256 constant private MEMBER_ETH_PROVISION = 1 ether;\\n\\n  /// Governorship related stuff.\\n\\n  /**\\n   * @dev Queries whether a given address is a governor or not.\\n   */\\n  function isGovernor(address candidate)\\n      external view override returns(bool) {\\n    return LibFastAccess.data().governorSet.contains(candidate);\\n  }\\n\\n  /**\\n   * @dev Queries the number of governors in the governorship list.\\n   */\\n  function governorCount()\\n      external override view returns(uint256) {\\n    return LibFastAccess.data().governorSet.values.length;\\n  }\\n\\n  /**\\n   * @dev Returns a page of governors.\\n   */\\n  function paginateGovernors(uint256 index, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibFastAccess.\\n      data().governorSet.values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  /**\\n   * @dev Adds a governor to the governorship list.\\n   */\\n  function addGovernor(address payable governor)\\n      external override\\n      spcMembership(msg.sender) {\\n    // Add governor to list.\\n    LibFastAccess.data().governorSet.add(governor, false);\\n    // If the address is a regular wallet...\\n    if (!LibHelpers.isContract(governor)) {\\n      // Provision the new governor with Eth if possible.\\n      FastTopFacet(payable(address(this))).payUpTo(governor, GOVERNOR_ETH_PROVISION);\\n    }\\n    // Emit!\\n    emit LibFastAccess.GovernorAdded(governor);\\n  }\\n\\n  /**\\n   * @dev Removes a governor from the governorship list.\\n   */\\n  function removeGovernor(address governor)\\n      external override\\n      spcMembership(msg.sender) {\\n    // Remove governor.\\n    LibFastAccess.data().governorSet.remove(governor, false);\\n    // Emit!\\n    emit LibFastAccess.GovernorRemoved(governor);\\n  }\\n\\n  /// Membership related stuff.\\n\\n  /**\\n   * @dev Queries whether a given address is a member or not.\\n   */\\n  function isMember(address candidate)\\n      external override view returns(bool) {\\n    return LibFastAccess.data().memberSet.contains(candidate);\\n  }\\n\\n  /**\\n   * @dev Queries the number of members in the membership list.\\n   */\\n  function memberCount()\\n      external override view returns(uint256) {\\n    return LibFastAccess.data().memberSet.values.length;\\n  }\\n\\n  /**\\n   * @dev Returns a page of members.\\n   */\\n  function paginateMembers(uint256 index, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastAccess.data().memberSet.values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  /**\\n   * @dev Adds a member to the membership list.\\n   */\\n  function addMember(address payable member)\\n      external override \\n      governance(msg.sender) exchangeMember(member) {\\n    // Add the member.\\n    LibFastAccess.data().memberSet.add(member, false);\\n    // If the address is a regular wallet...\\n    if (!LibHelpers.isContract(member)) {\\n      // Provision the new member with Eth if possible.\\n      FastTopFacet(payable(address(this))).payUpTo(member, MEMBER_ETH_PROVISION);\\n    }\\n    // Notify exchange that this member was added to this FAST.\\n    ExchangeTopFacet(LibFast.data().exchange).memberAddedToFast(member);\\n    // Emit!\\n    emit IHasMembers.MemberAdded(member);\\n  }\\n\\n  /**\\n   * @dev Removes a member from the membership list.\\n   */\\n  function removeMember(address member)\\n      external override \\n      governance(msg.sender) {\\n    // Notify token contract.\\n    FastTokenFacet(address(this)).beforeRemovingMember(member);\\n    // Remove member.\\n    LibFastAccess.data().memberSet.remove(member, false);\\n    // Notify exchange that this member was removed from this FAST.\\n    ExchangeTopFacet(LibFast.data().exchange).memberRemovedFromFast(member);\\n    // Emit!\\n    emit IHasMembers.MemberRemoved(member);\\n  }\\n\\n  /// Flags.\\n\\n  /**\\n   * @dev Retrieves flags for a given address.\\n   */\\n  function flags(address a)\\n      external view returns(Flags memory) {\\n    LibFastAccess.Data storage s = LibFastAccess.data();\\n    return\\n      Flags({\\n        isGovernor: s.governorSet.contains(a),\\n        isMember: s.memberSet.contains(a)\\n      });\\n  }\\n}\\n\",\"keccak256\":\"0x952195d7a1d8fac0f5647d1e43fb0de9ee3e1674e6d5247fb2633c5506161388\",\"license\":\"MIT\"},\"contracts/fast/FastHistoryFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibPaginate.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFastHistory.sol';\\n\\n\\ncontract FastHistoryFacet is AFastFacet {\\n  /// Minting history-keeping methods.\\n\\n  function minted(uint256 amount, string calldata ref)\\n      external diamondInternal() {\\n    // Keep track of the mint.\\n    LibFastHistory.data().supplyProofs.push(\\n      LibFastHistory.SupplyProof({\\n        op: LibFastHistory.SupplyOp.Mint,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function burnt(uint256 amount, string calldata ref)\\n      external diamondInternal() {\\n    // Keep track of the unmint.\\n    LibFastHistory.data().supplyProofs.push(\\n      LibFastHistory.SupplyProof({\\n        op: LibFastHistory.SupplyOp.Burn,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function supplyProofCount()\\n      external view returns(uint256) {\\n    return LibFastHistory.data().supplyProofs.length;\\n  }\\n\\n  function paginateSupplyProofs(uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.SupplyProof[] memory, uint256) {\\n    return LibPaginate.supplyProofs(LibFastHistory.data().supplyProofs, cursor, perPage);\\n  }\\n\\n  /// Transfer history-keeping methods.\\n\\n  function transfered(address spender, address from, address to, uint256 amount, string calldata ref)\\n      external diamondInternal() {\\n    LibFastHistory.Data storage s = LibFastHistory.data();\\n    // Keep track of the transfer proof ID for the sender and for the recipient.\\n    s.transferProofInvolvements[from].push(s.transferProofs.length);\\n    s.transferProofInvolvements[to].push(s.transferProofs.length);\\n    // Keep track of the transfer proof globally.\\n    s.transferProofs.push(\\n      LibFastHistory.TransferProof({\\n        spender: spender,\\n        from: from,\\n        to: to,\\n        amount: amount,\\n        blockNumber: block.number,\\n        ref: ref\\n      })\\n    );\\n  }\\n\\n  function transferProofCount()\\n      external view returns(uint256) {\\n    return LibFastHistory.data().transferProofs.length;\\n  }\\n\\n  function paginateTransferProofs(uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n    return LibPaginate.transferProofs(LibFastHistory.data().transferProofs, cursor, perPage);\\n  }\\n\\n  function transferProofByInvolveeCount(address involvee)\\n      external view returns(uint256) {\\n    return LibFastHistory.data().transferProofInvolvements[involvee].length;\\n  }\\n\\n  function paginateTransferProofIndicesByInvolvee(address involvee, uint256 cursor, uint256 perPage)\\n      external view returns(uint256[] memory, uint256) {\\n    return LibPaginate.uint256s(LibFastHistory.data().transferProofInvolvements[involvee], cursor, perPage);\\n  }\\n\\n  function paginateTransferProofsByInvolvee(address involvee, uint256 cursor, uint256 perPage)\\n      external view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n    LibFastHistory.Data storage s = LibFastHistory.data();\\n    uint256[] storage collection  = s.transferProofInvolvements[involvee];\\n    uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n    LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\\n    for (uint256 i = 0; i < length; i++) {\\n      values[i] = s.transferProofs[collection[cursor + i]];\\n    }\\n    return (values, cursor + length);\\n  }\\n}\\n\",\"keccak256\":\"0x5596e26868dce38659495b3acddbaec7045698d0ecc9039f1170c5a9f1e21cb1\",\"license\":\"MIT\"},\"contracts/fast/FastTokenFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../interfaces/IERC20.sol';\\nimport '../interfaces/IERC1404.sol';\\nimport '../lib/LibDiamond.sol';\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport './FastAccessFacet.sol';\\nimport './FastHistoryFacet.sol';\\nimport './lib/AFastFacet.sol';\\n\\n\\ncontract FastTokenFacet is AFastFacet, IERC20, IERC1404 {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Constants.\\n\\n  // Restriction codes.\\n  uint8 private constant INSUFFICIENT_TRANSFER_CREDITS_CODE = 1;\\n  uint8 private constant REQUIRES_FAST_MEMBERSHIP_CODE = 2;\\n  uint8 private constant REQUIRES_EXCHANGE_MEMBERSHIP_CODE = 3;\\n  uint8 private constant REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE = 4;\\n\\n  // Events.\\n\\n  event Minted(uint256 indexed amount, string indexed ref);\\n  event Burnt(uint256 indexed amount, string indexed ref);\\n\\n  event TransferCreditsAdded(address indexed spcMember, uint256 amount);\\n  event TransferCreditsDrained(address indexed spcMember, uint256 amount);\\n\\n  event Disapproval(address indexed owner, address indexed spender);\\n\\n  // Public functions.\\n\\n  function isSemiPublic()\\n      external view returns(bool) {\\n    return LibFastToken.data().isSemiPublic;\\n  }\\n\\n  function setIsSemiPublic(bool flag)\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // Someone is trying to toggle back to private?... No can do!isSemiPublic\\n    require(!s.isSemiPublic || s.isSemiPublic == flag, LibConstants.UNSUPPORTED_OPERATION);\\n    s.isSemiPublic = flag;\\n  }\\n\\n  function hasFixedSupply()\\n      external view returns(bool) {\\n    return LibFastToken.data().hasFixedSupply;\\n  }\\n\\n  function setHasFixedSupply(bool flag)\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.data().hasFixedSupply = flag;\\n  }\\n\\n  /// Minting methods.\\n\\n  function mint(uint256 amount, string calldata ref)\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // We want to make sure that either of these two is true:\\n    // - The token doesn't have fixed supply.\\n    // - The token has fixed supply but has no tokens yet (First and only mint).\\n    require(\\n      !s.hasFixedSupply || (s.totalSupply == 0 && balanceOf(address(0)) == 0),\\n      LibConstants.REQUIRES_CONTINUOUS_SUPPLY\\n    );\\n\\n    // Prepare the minted amount on the zero address.\\n    s.balances[address(0)] += amount;\\n\\n    // Keep track of the minting operation.\\n    FastHistoryFacet(address(this)).minted(amount, ref);\\n\\n    // Emit!\\n    emit Minted(amount, ref);\\n  }\\n\\n  function burn(uint256 amount, string calldata ref)\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    require(!s.hasFixedSupply, LibConstants.REQUIRES_CONTINUOUS_SUPPLY);\\n    require(balanceOf(address(0)) >= amount, LibConstants.INSUFFICIENT_FUNDS);\\n\\n    // Remove the minted amount from the zero address.\\n    s.balances[address(0)] -= amount;\\n\\n    // Keep track of the minting operation.\\n    FastHistoryFacet(address(this)).burnt(amount, ref);\\n\\n    // Emit!\\n    emit Burnt(amount, ref);\\n  }\\n\\n  /// Tranfer Credit management.\\n\\n  function transferCredits()\\n      external view returns(uint256) {\\n    return LibFastToken.data().transferCredits;\\n  }\\n\\n  function addTransferCredits(uint256 amount)\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.data().transferCredits += amount;\\n    emit TransferCreditsAdded(msg.sender, amount);\\n  }\\n\\n  function drainTransferCredits()\\n      external\\n      spcMembership(msg.sender) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    emit TransferCreditsDrained(msg.sender, s.transferCredits);\\n    s.transferCredits = 0;\\n  }\\n\\n  /// ERC20 implementation and transfer related methods.\\n\\n  function name()\\n      external view returns(string memory) {\\n    return LibFastToken.data().name;\\n  }\\n\\n  function symbol()\\n      external view returns(string memory) {\\n    return LibFastToken.data().symbol;\\n  }\\n\\n  function decimals()\\n      external view returns(uint256) {\\n    return LibFastToken.data().decimals;\\n  }\\n\\n  function totalSupply()\\n      external override view returns(uint256) {\\n    return LibFastToken.data().totalSupply;\\n  }\\n\\n  function balanceOf(address owner)\\n      public view override returns(uint256) {\\n    return LibFastToken.data().balances[owner];\\n  }\\n\\n  function transfer(address to, uint256 amount)\\n      external override returns(bool) {\\n    _transfer(msg.sender, msg.sender, to, amount, 'Unspecified - via ERC20');\\n    return true;\\n  }\\n\\n  function transferWithRef(address to, uint256 amount, string memory ref)\\n      external {\\n    return _transfer(msg.sender, msg.sender, to, amount, ref);\\n  }\\n\\n  function allowance(address owner, address spender)\\n      public view override returns(uint256) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // If the allowance being queried is from the zero address and the spender\\n    // is a governor, we want to make sure that the spender has full rights over it.\\n    if (owner == address(0) && FastAccessFacet(address(this)).isGovernor(spender)) {\\n      return s.balances[address(0)];\\n   } else {\\n      return s.allowances[owner][spender];\\n    }\\n  }\\n\\n  function approve(address spender, uint256 amount)\\n      external override\\n      membership(msg.sender)\\n      returns(bool) {\\n    _approve(msg.sender, spender, amount);\\n    return true;\\n  }\\n\\n  function disapprove(address spender)\\n      external\\n      membership(msg.sender) {\\n    _disapprove(msg.sender, spender);\\n  }\\n\\n  function transferFrom(address from, address to, uint256 amount)\\n      external override returns(bool) {\\n    transferFromWithRef(from, to, amount, 'Unspecified - via ERC20');\\n    return true;\\n  }\\n\\n  function transferFromWithRef(address from, address to, uint256 amount, string memory ref)\\n      public {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    // If the funds are coming from the zero address, we must be a governor.\\n    if (from == address(0)) {\\n      require(FastAccessFacet(address(this)).isGovernor(msg.sender), LibConstants.REQUIRES_FAST_GOVERNORSHIP);\\n    } else {\\n      require(allowance(from, msg.sender) >= amount, LibConstants.INSUFFICIENT_ALLOWANCE);\\n\\n      // Only decrease allowances if the sender of the funds isn't the zero address.\\n      uint256 newAllowance = s.allowances[from][msg.sender] -= amount;\\n      // If the allowance reached zero, we want to remove that allowance from\\n      // the various other places where we keep track of them.\\n      if (newAllowance == 0) {\\n        s.allowancesByOwner[from].remove(msg.sender, true);\\n        s.allowancesBySpender[msg.sender].remove(from, true);\\n      }\\n    }\\n\\n    _transfer(msg.sender, from, to, amount, ref);\\n  }\\n\\n  /// Allowances query operations.\\n\\n  function givenAllowanceCount(address owner)\\n      external view returns(uint256) {\\n    return LibFastToken.data().allowancesByOwner[owner].values.length;\\n  }\\n\\n  function paginateAllowancesByOwner(address owner, uint256 index, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastToken.data().allowancesByOwner[owner].values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  function receivedAllowanceCount(address spender)\\n      external view returns(uint256) {\\n    return LibFastToken.data().allowancesBySpender[spender].values.length;\\n  }\\n\\n  function paginateAllowancesBySpender(address spender, uint256 index, uint256 perPage)\\n      external view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(\\n      LibFastToken.data().allowancesBySpender[spender].values,\\n      index,\\n      perPage\\n    );\\n  }\\n\\n  /// ERC1404 implementation.\\n\\n  function detectTransferRestriction(address from, address to, uint256 amount)\\n      external view override returns(uint8) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n    if (s.transferCredits < amount) {\\n      return INSUFFICIENT_TRANSFER_CREDITS_CODE;\\n    } else if (!FastAccessFacet(address(this)).isMember(from) ||\\n               !FastAccessFacet(address(this)).isMember(to)) {\\n      return s.isSemiPublic\\n        ? REQUIRES_EXCHANGE_MEMBERSHIP_CODE\\n        : REQUIRES_FAST_MEMBERSHIP_CODE;\\n    } else if (from == to) {\\n      return REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE;\\n    }\\n    return 0;\\n  }\\n\\n  function messageForTransferRestriction(uint8 restrictionCode)\\n      external override pure returns(string memory) {\\n    if (restrictionCode == INSUFFICIENT_TRANSFER_CREDITS_CODE) {\\n      return LibConstants.INSUFFICIENT_TRANSFER_CREDITS;\\n    } else if (restrictionCode == REQUIRES_EXCHANGE_MEMBERSHIP_CODE) {\\n      return LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP;\\n    } else if (restrictionCode == REQUIRES_FAST_MEMBERSHIP_CODE) {\\n      return LibConstants.REQUIRES_FAST_MEMBERSHIP;\\n    } else if (restrictionCode == REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT_CODE) {\\n      return LibConstants.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT;\\n    }\\n    revert(LibConstants.UNKNOWN_RESTRICTION_CODE);\\n  }\\n\\n  // Private.\\n\\n  function _transfer(address spender, address from, address to, uint256 amount, string memory ref)\\n      private\\n      membershipOrZero(from) membershipOrZero(to) differentAddresses(from, to) {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    require(s.balances[from] >= amount, LibConstants.INSUFFICIENT_FUNDS);\\n    require(\\n      from == address(0) ||\\n        s.transferCredits >= amount,\\n      LibConstants.INSUFFICIENT_TRANSFER_CREDITS\\n    );\\n\\n    // Keep track of the balances.\\n    s.balances[from] -= amount;\\n    s.balances[to] += amount;\\n\\n    // If the funds are going to the ZERO address, decrease total supply.\\n    if (to == address(0)) { s.totalSupply -= amount; }\\n    // If the funds are moving from the zero address, increase total supply.\\n    else if (from == address(0)) { s.totalSupply += amount; }\\n\\n    // Keep track of the transfer.\\n    FastHistoryFacet(address(this)).transfered(spender, from, to, amount, ref);\\n\\n    // Emit!\\n    emit IERC20.Transfer(from, to, amount);\\n  }\\n\\n  function _approve(address from, address spender, uint256 amount)\\n      private {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Store allowance...\\n    s.allowances[from][spender] += amount;\\n    // Keep track of given and received allowances.\\n    s.allowancesByOwner[from].add(spender, true);\\n    s.allowancesBySpender[spender].add(from, true);\\n\\n    // Emit!\\n    emit IERC20.Approval(from, spender, amount);\\n  }\\n\\n  function _disapprove(address from, address spender)\\n      private {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // Remove allowance.\\n    s.allowances[from][spender] = 0;\\n    s.allowancesByOwner[from].remove(spender, false);\\n    s.allowancesBySpender[spender].remove(from, false);\\n\\n    // Emit!\\n    emit Disapproval(from, spender);\\n  }\\n\\n  /// Callbacks from other contracts.\\n\\n  // WARNING: This function contains two loops. We know that this should never\\n  // happen in solidity. However:\\n  // - In the context of our private chain, gas is cheap.\\n  // - It can only be called by a governor.\\n  function beforeRemovingMember(address member)\\n      external diamondInternal() {\\n    LibFastToken.Data storage s = LibFastToken.data();\\n\\n    // If there are token at member's address, move them back to the zero address.\\n    {\\n      uint256 balance = balanceOf(member);\\n      if (balance > 0) {\\n        _transfer(address(0), member, address(0), balance, 'Member removal');\\n      }\\n    }\\n\\n    // Remove all given allowances.\\n    {\\n      address[] storage gaData = s.allowancesByOwner[member].values;\\n      while (gaData.length > 0) { _disapprove(member, gaData[0]); }\\n    }\\n\\n    // Remove all received allowances.\\n    {\\n      address[] storage raData = s.allowancesBySpender[member].values;\\n      while (raData.length > 0) { _disapprove(raData[0], member); }\\n    }\\n  }\\n\\n  // Modifiers.\\n\\n  modifier differentAddresses(address a, address b) {\\n    require(a != b, LibConstants.REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x07b3b7965ae0eca80446f0215ca0cb695d7d0989f564f9382e8e9d01390f2222\",\"license\":\"MIT\"},\"contracts/fast/FastTopFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibConstants.sol';\\nimport '../lib/LibHelpers.sol';\\nimport './lib/AFastFacet.sol';\\nimport './lib/LibFast.sol';\\n\\ncontract FastTopFacet is AFastFacet {\\n  // Events.\\n\\n  // Eth provisioning related events.\\n  event EthReceived(address indexed from, uint256 amount);\\n  event EthDrained(address indexed to, uint256 amount);\\n\\n  // Getters.\\n\\n  function spcAddress()\\n      external view returns(address) {\\n    return LibFast.data().spc;\\n  }\\n\\n  function exchangeAddress()\\n      external view returns(address) {\\n    return LibFast.data().exchange;\\n  }\\n\\n  // Provisioning functions.\\n\\n  function provisionWithEth()\\n      external payable {\\n    require(msg.value > 0, LibConstants.MISSING_ATTACHED_ETH);\\n    emit EthReceived(msg.sender, msg.value);\\n  }\\n\\n  function drainEth()\\n      external\\n      spcMembership(msg.sender) {\\n    uint256 amount = payable(address(this)).balance;\\n    payable(msg.sender).transfer(amount);\\n    emit EthDrained(msg.sender, amount);\\n  }\\n\\n  /**\\n  * @dev This function allows contracts of the FAST network to request ETH\\n  * provisioning to arbitrary addresses.\\n  */\\n  function payUpTo(address payable recipient, uint256 amount)\\n      external diamondInternal() {\\n    require(recipient != address(0), LibConstants.REQUIRES_NON_ZERO_ADDRESS);\\n    amount = LibHelpers.upTo(recipient, amount);\\n    // Transfer some eth!\\n    if (amount != 0) { recipient.transfer(amount); }\\n  }\\n}\\n\",\"keccak256\":\"0xc049fba76d7a8d7d937f7816423cac74eb0c79a12a270e95efa33fbe435cace7\",\"license\":\"MIT\"},\"contracts/fast/lib/AFastFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibHelpers.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../../interfaces/IHasMembers.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../lib/LibFast.sol';\\nimport '../lib/LibFastAccess.sol';\\nimport '../lib/LibFastToken.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract AFastFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\\n  modifier diamondInternal() {\\n    require(msg.sender == address(this), LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\\n  modifier diamondOwner() {\\n    require(msg.sender == IERC173(address(this)).owner(), LibConstants.REQUIRES_DIAMOND_OWNERSHIP);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\\n  modifier deployerContract() {\\n    require(msg.sender == LibConstants.DEPLOYER_CONTRACT, LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is **not** a contract.\\n   *  @param a The address to check.\\n   */\\n  modifier nonContract(address a) {\\n    require(!LibHelpers.isContract(a), LibConstants.REQUIRES_NON_CONTRACT_ADDR);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the Exchange.\\n   *  @param a The address to check.\\n   */\\n  modifier exchangeMember(address a) {\\n    require(IHasMembers(LibFast.data().exchange).isMember(a), LibConstants.REQUIRES_EXCHANGE_MEMBERSHIP);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the SPC.\\n   *  @param a The address to check.\\n   */\\n  modifier spcMembership(address a) {\\n    require(IHasMembers(LibFast.data().spc).isMember(a), LibConstants.REQUIRES_SPC_MEMBERSHIP);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a governor of the FAST.\\n   *  @param a The address to check.\\n   */\\n  modifier governance(address a) {\\n    require(LibFastAccess.data().governorSet.contains(a), LibConstants.REQUIRES_FAST_GOVERNORSHIP);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the FAST.\\n   *  @param a The address to check.\\n   */\\n  modifier membership(address a) {\\n    require(LibFastAccess.data().memberSet.contains(a), LibConstants.REQUIRES_FAST_MEMBERSHIP);\\n    _;\\n  }\\n\\n  /** @dev Ensures that the given address is a member of the current FAST or the Zero Address.\\n   *  @param a The address to check.\\n   */\\n  modifier membershipOrZero(address a) {\\n    require(\\n      LibFastAccess.data().memberSet.contains(a) ||\\n      (LibFastToken.data().isSemiPublic && IHasMembers(LibFast.data().exchange).isMember(a)) ||\\n        a == address(0),\\n      LibConstants.REQUIRES_FAST_MEMBERSHIP\\n    );\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x66b70f0d092b9488e84c47d35cd4f259bbfabcd27e212a9d2e1a6fdfc361f6c3\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibFast {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev The internal pointer to the SPC contract.\\n    address spc;\\n    /// @dev The internal pointer to the Exchange contract.\\n    address exchange;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x8b155db07484240635af56d629dbc7827ed126db9119c16d2d139fb6ad4c1c6f\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastAccess.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\nlibrary LibFastAccess {\\n  // These are from IHasMembers.\\n  event MemberAdded(address indexed member);\\n  event MemberRemoved(address indexed member);\\n  // These are from IHasGovernors.\\n  event GovernorAdded(address indexed governor);\\n  event GovernorRemoved(address indexed governor);\\n\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.Access'):\\n  bytes32 internal constant STORAGE_SLOT = 0x87ed8063ac9ead3b2eb7551ed3d89b29fcbf44d6733084b5c82e95d5120ece9a;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev We hold the list of the FAST governors in there.\\n    LibAddressSet.Data governorSet;\\n    // @dev The FAST members are held in there.\\n    LibAddressSet.Data memberSet;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xae5d13b3662db3727c189c24510bab551acb16946873cbaff0d485211a85d5dd\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastHistory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibFastHistory {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.History'):\\n  bytes32 internal constant STORAGE_SLOT = 0x6bc8b61a9dd5fc049ea98027492a801d74e35fdf4d80d7fecd551a16e88fdbb4;\\n\\n  // Storage structures.\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    /// @dev All minting proofs are kept here.\\n    SupplyProof[] supplyProofs;\\n    /// @dev All transfer proofs are kept here.\\n    TransferProof[] transferProofs;\\n    /// @dev All transfers indices involving a given address are kept here.\\n    mapping(address => uint256[]) transferProofInvolvements;\\n  }\\n\\n  // Other structures.\\n\\n  /// @dev A minting operation could either be to mint or unmint tokens.\\n  enum SupplyOp { Mint, Burn }\\n\\n  /// @dev Minting operations are recorded for papertrail. This is the structure that keeps track of them.\\n  struct SupplyProof {\\n    SupplyOp op;\\n    uint256 amount;\\n    uint256 blockNumber;\\n    string ref;\\n  }\\n\\n  /// @dev Every transfer in is recorded. This is the structure that keeps track of them.\\n  struct TransferProof {\\n    address spender;\\n    address from;\\n    address to;\\n    uint256 amount;\\n    uint256 blockNumber;\\n    string ref;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xd6af0fc0867dd0259fa6e0797f2b46cffac8a36f0380bf266e3ccf778aeb724c\",\"license\":\"MIT\"},\"contracts/fast/lib/LibFastToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibFastToken {\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Fast.storage.Token'):\\n  bytes32 internal constant STORAGE_SLOT = 0xb098747b87c5c0e2a32eb9b06725e9bad4263809bcda628ceadc1a686bcb8261;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    // ERC20 related properties for this FAST Token.\\n    string name;\\n    string symbol;\\n    uint256 decimals;\\n    uint256 totalSupply;\\n    // Every time a transfer is executed, the credit decreases by the amount\\n    // of said transfer.\\n    // It becomes impossible to transact once it reaches zero, and must\\n    // be provisioned by an SPC governor.\\n    uint256 transferCredits;\\n    // Whether or not external people can hold and transfer tokens on this FAST.\\n    bool isSemiPublic;\\n    // We have to track whether this token has continuous minting or fixed supply.\\n    bool hasFixedSupply;\\n    // Our members balances are held here.\\n    mapping(address => uint256) balances;\\n    // Allowances are stored here.\\n    mapping(address => mapping(address => uint256)) allowances;\\n    mapping(address => LibAddressSet.Data) allowancesByOwner;\\n    mapping(address => LibAddressSet.Data) allowancesBySpender;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0xb75ff5b945e308f7297c365aefadaf382ff31ab7ab5a03eb4dd7a8ec4065cc3e\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0x7aca95eacea757ff86be09ed6f309fde42e402530ac7beae002e3c2586439a01\",\"license\":\"MIT\"},\"contracts/interfaces/IERC1404.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\n/**\\n * @dev Interface of the ERC1404 standard as defined in the EIP.\\n */\\ninterface IERC1404 {\\n  /**\\n   * @dev Returns a transfer restriction error code if the transfer shoudln't be permitted,\\n   *      or otherwise returns zero if everything looks fine.\\n   * @param owner is the account from which the tokens should be transfered.\\n   * @param recipient is the target of the transfer.\\n   * @param amount is the amount to be transfered.\\n   * @return a uint8 error code if a problem was detected, otherwise zero.\\n   */\\n  function detectTransferRestriction(address owner, address recipient, uint256 amount)\\n    external\\n    view\\n    returns (uint8);\\n\\n  /**\\n   * @dev Maps a transfer restriction error code into a human-readable string.\\n   * @param code is the code that should be transformed into a string.\\n   * @return A string that describes the given error code.\\n   */\\n  function messageForTransferRestriction(uint8 code) external pure returns (string memory);\\n}\\n\",\"keccak256\":\"0x9ecaada095d66283dda203f77cdd17d18f82bdf58d6fbe7830fc87aed2a80c38\",\"license\":\"MIT\"},\"contracts/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\",\"keccak256\":\"0x6ab22e74708905d9c31867461fffbd2e24bc6ad094aa1aab39211d99e296ab32\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x506634b62ab640b6cfbc4f1299f93a6475b250ec29072c71ca92907c4f747dce\",\"license\":\"MIT\"},\"contracts/interfaces/IHasGovernors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IHasGovernors {\\n  event GovernorAdded(address indexed governor);\\n  event GovernorRemoved(address indexed governor);\\n\\n  function isGovernor(address a) external view returns(bool);\\n  function governorCount() external view returns(uint256);\\n  function paginateGovernors(uint256 index, uint256 perPage) external view returns(address[] memory, uint256);\\n  function addGovernor(address payable a) external;\\n  function removeGovernor(address a) external;\\n}\\n\",\"keccak256\":\"0x35836b162c19951d87848f098fab3f42b79a0b9f593640e8ad8f2f2fa5b74d25\",\"license\":\"MIT\"},\"contracts/interfaces/IHasMembers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\ninterface IHasMembers {\\n  event MemberAdded(address indexed member);\\n  event MemberRemoved(address indexed member);\\n\\n  function isMember(address a) external view returns(bool);\\n  function memberCount() external view returns(uint256);\\n  function paginateMembers(uint256 index, uint256 perPage) external view returns(address[] memory, uint256);\\n  function addMember(address payable a) external;\\n  function removeMember(address a) external;\\n}\\n\",\"keccak256\":\"0xab0d7cfb46a5a70bd13783d959df2e8f593269472994ea828273fa563a4c0c39\",\"license\":\"MIT\"},\"contracts/lib/LibAddressSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibAddressSet {\\n  /// @dev Represents a list of addresses.\\n  struct Data {\\n    mapping(address => uint256) indices;\\n    address[] values;\\n  }\\n\\n  /**\\n   * @dev Adds an item into the storage set. If the address already exists in the\\n   *      set, the function reverts.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to be added.\\n   */\\n  function add(Data storage d, address key, bool noThrow)\\n      internal {\\n    bool exists = contains(d, key);\\n    if (noThrow && exists) { return; }\\n    require(!exists, 'Address already in set');\\n    d.indices[key] = d.values.length;\\n    d.values.push(key);\\n  }\\n\\n  /**\\n   * @dev Removes an item from the storage set. If the address does not exist in the\\n   *      set, the function reverts.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to be removed.\\n   */\\n  function remove(Data storage d, address key, bool noThrow)\\n      internal {\\n    bool exists = contains(d, key);\\n    if (noThrow && !exists) { return; }\\n    require(exists, 'Address does not exist in set');\\n    uint256 lastIndex = d.values.length - 1;\\n    address keyToMove = d.values[lastIndex];\\n    uint256 idxToReplace = d.indices[key];\\n    d.indices[keyToMove] = idxToReplace;\\n    d.values[idxToReplace] = keyToMove;\\n    delete d.indices[key];\\n    d.values.pop();\\n  }\\n\\n  /**\\n   * @dev Tests whether or not a given item already exists in the set.\\n   * @param d is the internal data storage to use.\\n   * @param key is the address to test.\\n   * @return a boolean.\\n   */\\n  function contains(Data storage d, address key)\\n      internal view returns(bool) {\\n    return d.values.length == 0\\n      ? false\\n      : d.values[d.indices[key]] == key;\\n  }\\n}\\n\",\"keccak256\":\"0x7daf050d0864e085c227521b1157b4ea652fe75ea7e10f685027b42d6e1caf87\",\"license\":\"MIT\"},\"contracts/lib/LibConstants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\nlibrary LibConstants {\\n  address internal constant ZERO_ADDRESS = address(0);\\n  address internal constant DEPLOYER_CONTRACT = 0x6DF2D25d8C6FD680730ee658b530A05a99BB769a;\\n\\n  string internal constant INTERNAL_METHOD = 'Internal method';\\n  string internal constant REQUIRES_DIAMOND_OWNERSHIP = 'Requires diamond ownership';\\n  string internal constant REQUIRES_FAST_CONTRACT_CALLER = 'Caller must be a FAST contract';\\n  string internal constant REQUIRES_NO_FAST_MEMBERSHIPS = 'Member still part of at least one FAST';\\n\\n  string internal constant REQUIRES_SPC_MEMBERSHIP = 'Requires SPC membership';\\n  string internal constant REQUIRES_EXCHANGE_MEMBERSHIP = 'Requires Exchange membership';\\n  string internal constant REQUIRES_FAST_GOVERNORSHIP = 'Requires FAST governorship';\\n  string internal constant REQUIRES_FAST_MEMBERSHIP = 'Requires FAST membership';\\n\\n  string internal constant DUPLICATE_ENTRY = 'Duplicate entry';\\n  string internal constant UNSUPPORTED_OPERATION = 'Unsupported operation';\\n  string internal constant REQUIRES_NON_ZERO_ADDRESS = 'Requires non-zero address';\\n  string internal constant REQUIRES_NON_CONTRACT_ADDR = 'Address cannot be a contract';\\n\\n  string internal constant MISSING_ATTACHED_ETH = 'Missing attached ETH';\\n  string internal constant REQUIRES_CONTINUOUS_SUPPLY = 'Requires continuous supply';\\n  string internal constant INSUFFICIENT_FUNDS = 'Insufficient token balance';\\n  string internal constant INSUFFICIENT_ALLOWANCE = 'Insufficient allowance';\\n  string internal constant INSUFFICIENT_TRANSFER_CREDITS = 'Insufficient transfer credits';\\n  string internal constant REQUIRES_DIFFERENT_SENDER_AND_RECIPIENT = 'Requires different sender and recipient';\\n  string internal constant UNKNOWN_RESTRICTION_CODE = 'Unknown restriction code';\\n}\\n\",\"keccak256\":\"0x07122b717a522632f20b4bb1d397428df14a12511eea4893ae16a77ecb6d011f\",\"license\":\"MIT\"},\"contracts/lib/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x1c1bcc2f4ce958b3569ec95530879a584e4cf837d585a5059b3b612ad4a71a47\",\"license\":\"MIT\"},\"contracts/lib/LibHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nlibrary LibHelpers {\\n  function upTo(address payable to, uint256 amount)\\n      internal view returns(uint256) {\\n    // If the recipient has more than what is ought to be paid, return.\\n    uint256 toBalance = to.balance;\\n    if (toBalance >= amount) { return 0; }\\n    // If the recipient has some Eth we should only pay the top-up.\\n    amount = amount - toBalance;\\n    // If the available eth is less than what we should pay, just cap it.\\n    uint256 available = payable(address(this)).balance;\\n    if (available < amount) { amount = available; }\\n    // Provision the new fast with Eth.\\n    return amount;\\n  }\\n\\n  function isContract(address target)\\n      internal view returns (bool) {\\n    uint32 size;\\n    assembly { size := extcodesize(target) }\\n    return (size > 0);\\n  }\\n}\\n\",\"keccak256\":\"0xa3ac21d8e6e5f25d9125d2975e7157e5c660bd481fb102c39a64810955d6eaab\",\"license\":\"MIT\"},\"contracts/lib/LibPaginate.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../fast/lib/LibFastHistory.sol';\\n\\n\\nlibrary LibPaginate {\\n  function addresses(address[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(address[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      address[] memory values = new address[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function uint256s(uint256[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(uint256[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      uint256[] memory values = new uint256[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function supplyProofs(LibFastHistory.SupplyProof[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(LibFastHistory.SupplyProof[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      LibFastHistory.SupplyProof[] memory values = new LibFastHistory.SupplyProof[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n\\n  function transferProofs(LibFastHistory.TransferProof[] storage collection, uint256 cursor, uint256 perPage)\\n    internal view returns(LibFastHistory.TransferProof[] memory, uint256) {\\n      uint256 length = (perPage > collection.length - cursor) ? collection.length - cursor : perPage;\\n      LibFastHistory.TransferProof[] memory values = new LibFastHistory.TransferProof[](length);\\n      for (uint256 i = 0; i < length; i++) {\\n        values[i] = collection[cursor + i];\\n      }\\n      return (values, cursor + length);\\n  }\\n}\",\"keccak256\":\"0xedbf24531aa1b21a17a7962b2053fe1bd81ddf9e8869f508f14f7fb9087631d9\",\"license\":\"MIT\"},\"contracts/spc/SpcTopFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../lib/LibAddressSet.sol';\\nimport '../lib/LibPaginate.sol';\\nimport '../lib/LibHelpers.sol';\\nimport '../interfaces/IHasMembers.sol';\\nimport '../fast/FastTopFacet.sol';\\nimport '../fast/FastTokenFacet.sol';\\nimport './lib/ASpcFacet.sol';\\nimport './lib/LibSpc.sol';\\n\\n\\n/** @title The SPC Smart Contract.\\n *  @dev The SPC contract is the central place for top-level governorship. It requires that a\\n *        first member address is passed at construction time.\\n */\\ncontract SpcTopFacet is ASpcFacet, IHasMembers {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  // Constants.\\n\\n  // This represents how much Eth we provision new SPC members with.\\n  uint256 constant private MEMBER_ETH_PROVISION = 10 ether;\\n  // This represents how much Eth new FASTs are provisioned with.\\n  uint256 constant private FAST_ETH_PROVISION = 250 ether;\\n\\n  // Events.\\n\\n  /** @dev Emited when a new FAST is registered.\\n   *  @param fast The address of the newly registered FAST diamond.\\n   */\\n  event FastRegistered(address indexed fast);\\n\\n  /** @dev Emited when someone provisions this SPC with Eth.\\n   *  @param from The sender of the Eth.\\n   *  @param amount The quantity of Eth, expressed in Wei.\\n   */\\n  event EthReceived(address indexed from, uint256 amount);\\n  /** @dev Emited when Eth is drained from this SPC.\\n   *  @param to The caller and recipient of the drained Eth.\\n   *  @param amount The quantity of Eth that was drained, expressed in Wei.\\n   */\\n  event EthDrained(address indexed to, uint256 amount);\\n\\n  // Eth provisioning stuff.\\n\\n  /** @dev A function that alllows provisioning this SPC with Eth.\\n   *  @notice Emits a `EthReceived` event.\\n   */\\n  function provisionWithEth()\\n      external payable {\\n    require(msg.value > 0, LibConstants.MISSING_ATTACHED_ETH);\\n    emit EthReceived(msg.sender, msg.value);\\n  }\\n\\n  /** @dev A function that alllows draining this SPC from its Eth.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `EthDrained` event.\\n   */\\n  function drainEth()\\n      external\\n      membership(msg.sender) {\\n    uint256 amount = payable(address(this)).balance;\\n    payable(msg.sender).transfer(amount);\\n    emit EthDrained(msg.sender, amount);\\n  }\\n\\n  // Membership management.\\n\\n  /** @dev Queries whether a given address is a member of this SPC or not.\\n   *  @param candidate The address to test.\\n   *  @return A `boolean` flag.\\n   */\\n  function isMember(address candidate)\\n      external override view returns(bool) {\\n    return LibSpc.data().memberSet.contains(candidate);\\n  }\\n\\n  /** @dev Counts the numbers of members present in this SPC.\\n   *  @return The number of members in this SPC.\\n   */\\n  function memberCount()\\n      external override view returns(uint256) {\\n    return LibSpc.data().memberSet.values.length;\\n  }\\n\\n  /** @dev Paginates the members of this SPC based on a starting cursor and a number of records per page.\\n   *  @param cursor The index at which to start.\\n   *  @param perPage How many records should be returned at most.\\n   *  @return A `address[]` list of values at most `perPage` big.\\n   *  @return A `uint256` index to the next page.\\n   */\\n  function paginateMembers(uint256 cursor, uint256 perPage)\\n      external override view returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibSpc.data().memberSet.values, cursor, perPage);\\n  }\\n\\n  /** @dev Adds a member to this SPC member list.\\n   *  @param member The address of the member to be added.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `IHasMembers.MemberAdded` event.\\n   */\\n  function addMember(address payable member)\\n      external override\\n      membership(msg.sender) {\\n    // Add the member to our list.\\n    LibSpc.data().memberSet.add(member, false);\\n\\n    // Provision the member with some Eth.\\n    uint256 amount = LibHelpers.upTo(member, MEMBER_ETH_PROVISION);\\n    if (amount != 0) { member.transfer(amount); }\\n\\n    // Emit!\\n    emit IHasMembers.MemberAdded(member);\\n  }\\n\\n  /** @dev Removes a member from this SPC.\\n   *  @param member The address of the member to be removed.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `IHasMembers.MemberRemoved` event.\\n   */\\n  function removeMember(address member)\\n      external override\\n      membership(msg.sender) {\\n    // No suicide allowed.\\n    require(msg.sender != member, 'Cannot remove self');\\n    // Remove the member from the set.\\n    LibSpc.data().memberSet.remove(member, false);\\n    // Emit!\\n    emit IHasMembers.MemberRemoved(member);\\n  }\\n\\n  // FAST management related methods.\\n\\n  /** @dev Queries whether a given address is a known and registered FAST contract.\\n   * @param fast The address of the contract to check.\\n   * @return A boolean.\\n   */\\n  function isFastRegistered(address fast)\\n      external view returns(bool) {\\n    return LibSpc.data().fastSet.contains(fast);\\n  }\\n\\n  /** @dev Allows to retrieve the address of a FAST diamond given its symbol.\\n   *  @param symbol The symbol of the FAST diamond to get the address of.\\n   *  @return The address of the corresponding FAST diamond, or the Zero Address if not found.\\n   */\\n  function fastBySymbol(string calldata symbol)\\n      external view returns(address) {\\n    return LibSpc.data().fastSymbols[symbol];\\n  }\\n\\n  /** @dev Allows the registration of a given FAST diamond with this SPC.\\n   *  @param fast The address of the FAST diamond to be registered.\\n   *  @notice Requires that the caller is a member of this SPC.\\n   *  @notice Emits a `FastRegistered` event.\\n   */\\n  function registerFast(address fast)\\n      external\\n      membership(msg.sender) {\\n    LibSpc.Data storage s = LibSpc.data();\\n    string memory symbol = FastTokenFacet(fast).symbol();\\n    require(s.fastSymbols[symbol] == address(0), LibConstants.DUPLICATE_ENTRY);\\n\\n    // Add the FAST to our list.\\n    s.fastSet.add(fast, false);\\n    // Add the fast symbol to our list.\\n    s.fastSymbols[symbol] = fast;\\n\\n    // Provision the new fast with Eth.\\n    uint256 amount = LibHelpers.upTo(payable(fast), FAST_ETH_PROVISION);\\n    // Only provision the fast if possible.\\n    if (amount > 0) {\\n      FastTopFacet(fast).provisionWithEth{ value: amount }();\\n    }\\n    // Emit!\\n    emit FastRegistered(fast);\\n  }\\n\\n  /** @dev Counts the number of FAST diamonds registered with this SPC.\\n   *  @return The number of FAST diamonds registered with this SPC.\\n   */\\n  function fastCount()\\n      external view returns(uint256) {\\n    return LibSpc.data().fastSet.values.length;\\n  }\\n\\n  /** @dev Paginates the FAST diamonds registered with this SPC based on a starting cursor and a number of records per page.\\n   *  @param cursor The index at which to start.\\n   *  @param perPage How many records should be returned at most.\\n   *  @return A `address[]` list of values at most `perPage` big.\\n   *  @return A `uint256` index to the next page.\\n   */\\n  function paginateFasts(uint256 cursor, uint256 perPage)\\n      external view\\n      returns(address[] memory, uint256) {\\n    return LibPaginate.addresses(LibSpc.data().fastSet.values, cursor, perPage);\\n  }\\n}\\n\",\"keccak256\":\"0x3b549112526d2dd82ce4ab879ba940a9f7f512e026cdee91a6dc6d9534fe29cb\",\"license\":\"MIT\"},\"contracts/spc/lib/ASpcFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibConstants.sol';\\nimport '../../lib/LibAddressSet.sol';\\nimport '../../interfaces/IERC173.sol';\\nimport '../lib/LibSpc.sol';\\n\\n\\n/**\\n* @dev This contract is a group of modifiers that can be used by any facets to guard against\\n*       certain permissions.\\n*/\\nabstract contract ASpcFacet {\\n  using LibAddressSet for LibAddressSet.Data;\\n\\n  /// Modifiers.\\n\\n  /// @dev Ensures that a method can only be called by another facet of the same diamond.\\n  modifier diamondInternal() {\\n    require(msg.sender == address(this), LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the owner of this diamond.\\n  modifier diamondOwner() {\\n    require(msg.sender == IERC173(address(this)).owner(), LibConstants.REQUIRES_DIAMOND_OWNERSHIP);\\n    _;\\n  }\\n\\n  /// @dev Ensures that a method can only be called by the singleton deployer contract factory.\\n  modifier deployerContract() {\\n    require(msg.sender == LibConstants.DEPLOYER_CONTRACT, LibConstants.INTERNAL_METHOD);\\n    _;\\n  }\\n\\n  /// @dev Ensures that the given address is a member of the current FAST.\\n  modifier membership(address a) {\\n    require(LibSpc.data().memberSet.contains(a), LibConstants.REQUIRES_SPC_MEMBERSHIP);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x61e5365b6a0491b38d1f3bd59af0b2c882681b471dc86039698c734a212757f6\",\"license\":\"MIT\"},\"contracts/spc/lib/LibSpc.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '../../lib/LibAddressSet.sol';\\n\\n\\nlibrary LibSpc {\\n  // These are from IHasMembers.\\n  event MemberAdded(address indexed member);\\n\\n  // The current version of the storage.\\n  uint16 internal constant STORAGE_VERSION = 1;\\n  // This is keccak256('Spc.storage'):\\n  bytes32 internal constant STORAGE_SLOT = 0x89a652f66ca129ef71cab44916bb070742a08af428e08a99df145c8006c94285;\\n\\n  struct Data {\\n    /// @dev The latest intializer version that was called.\\n    uint16 version;\\n    // This is where we hold our members data.\\n    LibAddressSet.Data memberSet;\\n    // This is where we keep our list of deployed fast FASTs.\\n    LibAddressSet.Data fastSet;\\n    // We keep track of the FAST symbols that were already used.\\n    mapping(string => address) fastSymbols;\\n  }\\n\\n  function data()\\n      internal pure returns(Data storage s) {\\n    assembly {s.slot := STORAGE_SLOT}\\n  }\\n}\\n\",\"keccak256\":\"0x95acfb97e7269758dfaac36bac10782b6a6bb17c75d151c2c4fdea0fbeaa1a67\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50611a60806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c8063a230c52411610071578063a230c52414610165578063c6549ba414610195578063ca6d56dc146101c6578063e43581b8146101e2578063e8c9fd4514610212578063eecdac8814610230576100a9565b80630b1ca49a146100ae57806311aee380146100ca5780633c4a25d0146100e85780635a4c75d5146101045780639fef0c0114610135575b600080fd5b6100c860048036038101906100c391906113cb565b61024c565b005b6100d261044a565b6040516100df9190611736565b60405180910390f35b61010260048036038101906100fd91906113f4565b610463565b005b61011e60048036038101906101199190611446565b61067a565b60405161012c92919061166e565b60405180910390f35b61014f600480360381019061014a91906113cb565b6106a1565b60405161015c919061171b565b60405180910390f35b61017f600480360381019061017a91906113cb565b610700565b60405161018c919061169e565b60405180910390f35b6101af60048036038101906101aa9190611446565b610726565b6040516101bd92919061166e565b60405180910390f35b6101e060048036038101906101db91906113f4565b61074d565b005b6101fc60048036038101906101f791906113cb565b610a91565b604051610209919061169e565b60405180910390f35b61021a610ab7565b6040516102279190611736565b60405180910390f35b61024a600480360381019061024591906113cb565b610ad0565b005b3361026a81610259610c64565b600101610c8c90919063ffffffff16565b6040518060400160405280601a81526020017f5265717569726573204641535420676f7665726e6f7273686970000000000000815250906102e1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102d891906116b9565b60405180910390fd5b503073ffffffffffffffffffffffffffffffffffffffff16635d7b590f836040518263ffffffff1660e01b815260040161031b919061160f565b600060405180830381600087803b15801561033557600080fd5b505af1158015610349573d6000803e3d6000fd5b5050505061036d82600061035b610c64565b600301610d829092919063ffffffff16565b610375611038565b60010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631b09a281836040518263ffffffff1660e01b81526004016103d1919061160f565b600060405180830381600087803b1580156103eb57600080fd5b505af11580156103ff573d6000803e3d6000fd5b505050508173ffffffffffffffffffffffffffffffffffffffff167f6e76fb4c77256006d9c38ec7d82b45a8c8f3c27b1d6766fffc42dfb8de68449260405160405180910390a25050565b6000610454610c64565b60030160010180549050905090565b3361046c611038565b60000160029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a230c524826040518263ffffffff1660e01b81526004016104c8919061160f565b60206040518083038186803b1580156104e057600080fd5b505afa1580156104f4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610518919061141d565b6040518060400160405280601781526020017f526571756972657320535043206d656d626572736869700000000000000000008152509061058f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161058691906116b9565b60405180910390fd5b506105b082600061059e610c64565b6001016110609092919063ffffffff16565b6105b98261117d565b610633573073ffffffffffffffffffffffffffffffffffffffff16638a80e95583678ac7230489e800006040518363ffffffff1660e01b8152600401610600929190611645565b600060405180830381600087803b15801561061a57600080fd5b505af115801561062e573d6000803e3d6000fd5b505050505b8173ffffffffffffffffffffffffffffffffffffffff167fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b560405160405180910390a25050565b60606000610696610689610c64565b6001016001018585611196565b915091509250929050565b6106a9611359565b60006106b3610c64565b905060405180604001604052806106d68584600101610c8c90919063ffffffff16565b151581526020016106f38584600301610c8c90919063ffffffff16565b1515815250915050919050565b600061071f8261070e610c64565b600301610c8c90919063ffffffff16565b9050919050565b60606000610742610735610c64565b6003016001018585611196565b915091509250929050565b3361076b8161075a610c64565b600101610c8c90919063ffffffff16565b6040518060400160405280601a81526020017f5265717569726573204641535420676f7665726e6f7273686970000000000000815250906107e2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107d991906116b9565b60405180910390fd5b50816107ec611038565b60010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a230c524826040518263ffffffff1660e01b8152600401610848919061160f565b60206040518083038186803b15801561086057600080fd5b505afa158015610874573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610898919061141d565b6040518060400160405280601c81526020017f52657175697265732045786368616e6765206d656d62657273686970000000008152509061090f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161090691906116b9565b60405180910390fd5b5061093083600061091e610c64565b6003016110609092919063ffffffff16565b6109398361117d565b6109b3573073ffffffffffffffffffffffffffffffffffffffff16638a80e95584670de0b6b3a76400006040518363ffffffff1660e01b8152600401610980929190611645565b600060405180830381600087803b15801561099a57600080fd5b505af11580156109ae573d6000803e3d6000fd5b505050505b6109bb611038565b60010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663af827ff7846040518263ffffffff1660e01b8152600401610a17919061162a565b600060405180830381600087803b158015610a3157600080fd5b505af1158015610a45573d6000803e3d6000fd5b505050508273ffffffffffffffffffffffffffffffffffffffff167fb251eb052afc73ffd02ffe85ad79990a8b3fed60d76dbc2fa2fdd7123dffd91460405160405180910390a2505050565b6000610ab082610a9f610c64565b600101610c8c90919063ffffffff16565b9050919050565b6000610ac1610c64565b60010160010180549050905090565b33610ad9611038565b60000160029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a230c524826040518263ffffffff1660e01b8152600401610b35919061160f565b60206040518083038186803b158015610b4d57600080fd5b505afa158015610b61573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b85919061141d565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610bfc576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610bf391906116b9565b60405180910390fd5b50610c1d826000610c0b610c64565b600101610d829092919063ffffffff16565b8173ffffffffffffffffffffffffffffffffffffffff167f1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b60405160405180910390a25050565b60007f87ed8063ac9ead3b2eb7551ed3d89b29fcbf44d6733084b5c82e95d5120ece9a905090565b600080836001018054905014610d77578173ffffffffffffffffffffffffffffffffffffffff16836001018460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205481548110610d30577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610d7a565b60005b905092915050565b6000610d8e8484610c8c565b9050818015610d9b575080155b15610da65750611033565b80610de6576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ddd906116fb565b60405180910390fd5b600060018560010180549050610dfc91906117fc565b90506000856001018281548110610e3c577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060008660000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050808760000160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555081876001018281548110610f32577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508660000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000905586600101805480610ff9577f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b6001900381819060005260206000200160006101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690559055505050505b505050565b60007f80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705905090565b600061106c8484610c8c565b90508180156110785750805b156110835750611178565b80156110c4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110bb906116db565b60405180910390fd5b83600101805490508460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555083600101839080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505b505050565b600080823b905060008163ffffffff1611915050919050565b60606000808486805490506111ab91906117fc565b84116111b757836111c8565b8486805490506111c791906117fc565b5b905060008167ffffffffffffffff81111561120c577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405190808252806020026020018201604052801561123a5781602001602082028036833780820191505090505b50905060005b8281101561133d5787818861125591906117a6565b8154811061128c577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168282815181106112f0577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508080611335906118f3565b915050611240565b5080828761134b91906117a6565b935093505050935093915050565b60405180604001604052806000151581526020016000151581525090565b600081359050611386816119ce565b92915050565b60008135905061139b816119e5565b92915050565b6000815190506113b0816119fc565b92915050565b6000813590506113c581611a13565b92915050565b6000602082840312156113dd57600080fd5b60006113eb84828501611377565b91505092915050565b60006020828403121561140657600080fd5b60006114148482850161138c565b91505092915050565b60006020828403121561142f57600080fd5b600061143d848285016113a1565b91505092915050565b6000806040838503121561145957600080fd5b6000611467858286016113b6565b9250506020611478858286016113b6565b9150509250929050565b600061148e83836114b8565b60208301905092915050565b6114a38161188a565b82525050565b6114b281611842565b82525050565b6114c181611830565b82525050565b6114d081611830565b82525050565b60006114e182611761565b6114eb8185611784565b93506114f683611751565b8060005b8381101561152757815161150e8882611482565b975061151983611777565b9250506001810190506114fa565b5085935050505092915050565b61153d81611854565b82525050565b61154c81611854565b82525050565b600061155d8261176c565b6115678185611795565b93506115778185602086016118c0565b6115808161196b565b840191505092915050565b6000611598601683611795565b91506115a38261197c565b602082019050919050565b60006115bb601d83611795565b91506115c6826119a5565b602082019050919050565b6040820160008201516115e76000850182611534565b5060208201516115fa6020850182611534565b50505050565b61160981611880565b82525050565b600060208201905061162460008301846114c7565b92915050565b600060208201905061163f600083018461149a565b92915050565b600060408201905061165a60008301856114a9565b6116676020830184611600565b9392505050565b6000604082019050818103600083015261168881856114d6565b90506116976020830184611600565b9392505050565b60006020820190506116b36000830184611543565b92915050565b600060208201905081810360008301526116d38184611552565b905092915050565b600060208201905081810360008301526116f48161158b565b9050919050565b60006020820190508181036000830152611714816115ae565b9050919050565b600060408201905061173060008301846115d1565b92915050565b600060208201905061174b6000830184611600565b92915050565b6000819050602082019050919050565b600081519050919050565b600081519050919050565b6000602082019050919050565b600082825260208201905092915050565b600082825260208201905092915050565b60006117b182611880565b91506117bc83611880565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156117f1576117f061193c565b5b828201905092915050565b600061180782611880565b915061181283611880565b9250828210156118255761182461193c565b5b828203905092915050565b600061183b82611860565b9050919050565b600061184d82611860565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b60006118958261189c565b9050919050565b60006118a7826118ae565b9050919050565b60006118b982611860565b9050919050565b60005b838110156118de5780820151818401526020810190506118c3565b838111156118ed576000848401525b50505050565b60006118fe82611880565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156119315761193061193c565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000601f19601f8301169050919050565b7f4164647265737320616c726561647920696e2073657400000000000000000000600082015250565b7f4164647265737320646f6573206e6f7420657869737420696e20736574000000600082015250565b6119d781611830565b81146119e257600080fd5b50565b6119ee81611842565b81146119f957600080fd5b50565b611a0581611854565b8114611a1057600080fd5b50565b611a1c81611880565b8114611a2757600080fd5b5056fea2646970667358221220f8bff5a2579c281c82eba136a66c5f0e38797504c9d1e8e81e840605686d603964736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100a95760003560e01c8063a230c52411610071578063a230c52414610165578063c6549ba414610195578063ca6d56dc146101c6578063e43581b8146101e2578063e8c9fd4514610212578063eecdac8814610230576100a9565b80630b1ca49a146100ae57806311aee380146100ca5780633c4a25d0146100e85780635a4c75d5146101045780639fef0c0114610135575b600080fd5b6100c860048036038101906100c391906113cb565b61024c565b005b6100d261044a565b6040516100df9190611736565b60405180910390f35b61010260048036038101906100fd91906113f4565b610463565b005b61011e60048036038101906101199190611446565b61067a565b60405161012c92919061166e565b60405180910390f35b61014f600480360381019061014a91906113cb565b6106a1565b60405161015c919061171b565b60405180910390f35b61017f600480360381019061017a91906113cb565b610700565b60405161018c919061169e565b60405180910390f35b6101af60048036038101906101aa9190611446565b610726565b6040516101bd92919061166e565b60405180910390f35b6101e060048036038101906101db91906113f4565b61074d565b005b6101fc60048036038101906101f791906113cb565b610a91565b604051610209919061169e565b60405180910390f35b61021a610ab7565b6040516102279190611736565b60405180910390f35b61024a600480360381019061024591906113cb565b610ad0565b005b3361026a81610259610c64565b600101610c8c90919063ffffffff16565b6040518060400160405280601a81526020017f5265717569726573204641535420676f7665726e6f7273686970000000000000815250906102e1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102d891906116b9565b60405180910390fd5b503073ffffffffffffffffffffffffffffffffffffffff16635d7b590f836040518263ffffffff1660e01b815260040161031b919061160f565b600060405180830381600087803b15801561033557600080fd5b505af1158015610349573d6000803e3d6000fd5b5050505061036d82600061035b610c64565b600301610d829092919063ffffffff16565b610375611038565b60010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631b09a281836040518263ffffffff1660e01b81526004016103d1919061160f565b600060405180830381600087803b1580156103eb57600080fd5b505af11580156103ff573d6000803e3d6000fd5b505050508173ffffffffffffffffffffffffffffffffffffffff167f6e76fb4c77256006d9c38ec7d82b45a8c8f3c27b1d6766fffc42dfb8de68449260405160405180910390a25050565b6000610454610c64565b60030160010180549050905090565b3361046c611038565b60000160029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a230c524826040518263ffffffff1660e01b81526004016104c8919061160f565b60206040518083038186803b1580156104e057600080fd5b505afa1580156104f4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610518919061141d565b6040518060400160405280601781526020017f526571756972657320535043206d656d626572736869700000000000000000008152509061058f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161058691906116b9565b60405180910390fd5b506105b082600061059e610c64565b6001016110609092919063ffffffff16565b6105b98261117d565b610633573073ffffffffffffffffffffffffffffffffffffffff16638a80e95583678ac7230489e800006040518363ffffffff1660e01b8152600401610600929190611645565b600060405180830381600087803b15801561061a57600080fd5b505af115801561062e573d6000803e3d6000fd5b505050505b8173ffffffffffffffffffffffffffffffffffffffff167fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b560405160405180910390a25050565b60606000610696610689610c64565b6001016001018585611196565b915091509250929050565b6106a9611359565b60006106b3610c64565b905060405180604001604052806106d68584600101610c8c90919063ffffffff16565b151581526020016106f38584600301610c8c90919063ffffffff16565b1515815250915050919050565b600061071f8261070e610c64565b600301610c8c90919063ffffffff16565b9050919050565b60606000610742610735610c64565b6003016001018585611196565b915091509250929050565b3361076b8161075a610c64565b600101610c8c90919063ffffffff16565b6040518060400160405280601a81526020017f5265717569726573204641535420676f7665726e6f7273686970000000000000815250906107e2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107d991906116b9565b60405180910390fd5b50816107ec611038565b60010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a230c524826040518263ffffffff1660e01b8152600401610848919061160f565b60206040518083038186803b15801561086057600080fd5b505afa158015610874573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610898919061141d565b6040518060400160405280601c81526020017f52657175697265732045786368616e6765206d656d62657273686970000000008152509061090f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161090691906116b9565b60405180910390fd5b5061093083600061091e610c64565b6003016110609092919063ffffffff16565b6109398361117d565b6109b3573073ffffffffffffffffffffffffffffffffffffffff16638a80e95584670de0b6b3a76400006040518363ffffffff1660e01b8152600401610980929190611645565b600060405180830381600087803b15801561099a57600080fd5b505af11580156109ae573d6000803e3d6000fd5b505050505b6109bb611038565b60010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663af827ff7846040518263ffffffff1660e01b8152600401610a17919061162a565b600060405180830381600087803b158015610a3157600080fd5b505af1158015610a45573d6000803e3d6000fd5b505050508273ffffffffffffffffffffffffffffffffffffffff167fb251eb052afc73ffd02ffe85ad79990a8b3fed60d76dbc2fa2fdd7123dffd91460405160405180910390a2505050565b6000610ab082610a9f610c64565b600101610c8c90919063ffffffff16565b9050919050565b6000610ac1610c64565b60010160010180549050905090565b33610ad9611038565b60000160029054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a230c524826040518263ffffffff1660e01b8152600401610b35919061160f565b60206040518083038186803b158015610b4d57600080fd5b505afa158015610b61573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b85919061141d565b6040518060400160405280601781526020017f526571756972657320535043206d656d6265727368697000000000000000000081525090610bfc576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610bf391906116b9565b60405180910390fd5b50610c1d826000610c0b610c64565b600101610d829092919063ffffffff16565b8173ffffffffffffffffffffffffffffffffffffffff167f1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b60405160405180910390a25050565b60007f87ed8063ac9ead3b2eb7551ed3d89b29fcbf44d6733084b5c82e95d5120ece9a905090565b600080836001018054905014610d77578173ffffffffffffffffffffffffffffffffffffffff16836001018460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205481548110610d30577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610d7a565b60005b905092915050565b6000610d8e8484610c8c565b9050818015610d9b575080155b15610da65750611033565b80610de6576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ddd906116fb565b60405180910390fd5b600060018560010180549050610dfc91906117fc565b90506000856001018281548110610e3c577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060008660000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050808760000160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555081876001018281548110610f32577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508660000160008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000905586600101805480610ff9577f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b6001900381819060005260206000200160006101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690559055505050505b505050565b60007f80c187ea6f955fd624c41fb7a18011cc87d98c6f4c06d897b59142f65707e705905090565b600061106c8484610c8c565b90508180156110785750805b156110835750611178565b80156110c4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110bb906116db565b60405180910390fd5b83600101805490508460000160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555083600101839080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505b505050565b600080823b905060008163ffffffff1611915050919050565b60606000808486805490506111ab91906117fc565b84116111b757836111c8565b8486805490506111c791906117fc565b5b905060008167ffffffffffffffff81111561120c577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405190808252806020026020018201604052801561123a5781602001602082028036833780820191505090505b50905060005b8281101561133d5787818861125591906117a6565b8154811061128c577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168282815181106112f0577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508080611335906118f3565b915050611240565b5080828761134b91906117a6565b935093505050935093915050565b60405180604001604052806000151581526020016000151581525090565b600081359050611386816119ce565b92915050565b60008135905061139b816119e5565b92915050565b6000815190506113b0816119fc565b92915050565b6000813590506113c581611a13565b92915050565b6000602082840312156113dd57600080fd5b60006113eb84828501611377565b91505092915050565b60006020828403121561140657600080fd5b60006114148482850161138c565b91505092915050565b60006020828403121561142f57600080fd5b600061143d848285016113a1565b91505092915050565b6000806040838503121561145957600080fd5b6000611467858286016113b6565b9250506020611478858286016113b6565b9150509250929050565b600061148e83836114b8565b60208301905092915050565b6114a38161188a565b82525050565b6114b281611842565b82525050565b6114c181611830565b82525050565b6114d081611830565b82525050565b60006114e182611761565b6114eb8185611784565b93506114f683611751565b8060005b8381101561152757815161150e8882611482565b975061151983611777565b9250506001810190506114fa565b5085935050505092915050565b61153d81611854565b82525050565b61154c81611854565b82525050565b600061155d8261176c565b6115678185611795565b93506115778185602086016118c0565b6115808161196b565b840191505092915050565b6000611598601683611795565b91506115a38261197c565b602082019050919050565b60006115bb601d83611795565b91506115c6826119a5565b602082019050919050565b6040820160008201516115e76000850182611534565b5060208201516115fa6020850182611534565b50505050565b61160981611880565b82525050565b600060208201905061162460008301846114c7565b92915050565b600060208201905061163f600083018461149a565b92915050565b600060408201905061165a60008301856114a9565b6116676020830184611600565b9392505050565b6000604082019050818103600083015261168881856114d6565b90506116976020830184611600565b9392505050565b60006020820190506116b36000830184611543565b92915050565b600060208201905081810360008301526116d38184611552565b905092915050565b600060208201905081810360008301526116f48161158b565b9050919050565b60006020820190508181036000830152611714816115ae565b9050919050565b600060408201905061173060008301846115d1565b92915050565b600060208201905061174b6000830184611600565b92915050565b6000819050602082019050919050565b600081519050919050565b600081519050919050565b6000602082019050919050565b600082825260208201905092915050565b600082825260208201905092915050565b60006117b182611880565b91506117bc83611880565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156117f1576117f061193c565b5b828201905092915050565b600061180782611880565b915061181283611880565b9250828210156118255761182461193c565b5b828203905092915050565b600061183b82611860565b9050919050565b600061184d82611860565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b60006118958261189c565b9050919050565b60006118a7826118ae565b9050919050565b60006118b982611860565b9050919050565b60005b838110156118de5780820151818401526020810190506118c3565b838111156118ed576000848401525b50505050565b60006118fe82611880565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156119315761193061193c565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000601f19601f8301169050919050565b7f4164647265737320616c726561647920696e2073657400000000000000000000600082015250565b7f4164647265737320646f6573206e6f7420657869737420696e20736574000000600082015250565b6119d781611830565b81146119e257600080fd5b50565b6119ee81611842565b81146119f957600080fd5b50565b611a0581611854565b8114611a1057600080fd5b50565b611a1c81611880565b8114611a2757600080fd5b5056fea2646970667358221220f8bff5a2579c281c82eba136a66c5f0e38797504c9d1e8e81e840605686d603964736f6c63430008040033",
  "devdoc": {
    "details": "The FAST Access Smart Contract is the source of truth when it comes to permissioning and ACLs within a given FAST network.",
    "kind": "dev",
    "methods": {
      "addGovernor(address)": {
        "details": "Adds a governor to the governorship list."
      },
      "addMember(address)": {
        "details": "Adds a member to the membership list."
      },
      "flags(address)": {
        "details": "Retrieves flags for a given address."
      },
      "governorCount()": {
        "details": "Queries the number of governors in the governorship list."
      },
      "isGovernor(address)": {
        "details": "Queries whether a given address is a governor or not."
      },
      "isMember(address)": {
        "details": "Queries whether a given address is a member or not."
      },
      "memberCount()": {
        "details": "Queries the number of members in the membership list."
      },
      "paginateGovernors(uint256,uint256)": {
        "details": "Returns a page of governors."
      },
      "paginateMembers(uint256,uint256)": {
        "details": "Returns a page of members."
      },
      "removeGovernor(address)": {
        "details": "Removes a governor from the governorship list."
      },
      "removeMember(address)": {
        "details": "Removes a member from the membership list."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}